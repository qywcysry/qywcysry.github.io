<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CTF-Wiki]]></title>
    <url>%2F2019%2F06%2F20%2FCTF%2F</url>
    <content type="text"><![CDATA[CTF-Wiki中几道例题的思路 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;void success() &#123; puts(“You Hava already controlled it.”); &#125;void vulnerable() &#123;char s[12];gets(s);puts(s);return;&#125;int main(int argc, char **argv) &#123;vulnerable();return 0;&#125; 第一道题只开启了NX enabled，为什么不要用ROP呢？首先找到了gets（）函数，存在栈溢出漏洞。然后根据char[]开启的buf地址（EBP-0x14），计算出覆盖到ret addr的距离，构造出payload：0x14*‘a’+bbbb+p32（想要执行的函数地址）。 第二道题ret2text： 为什么不要用ROP呢？用了ROP的吧，不过链太短了。首先找到了gets（）函数，存在栈溢出漏洞。然后再secure函数中找到了system（”/bin/sh”)的调用。直接控制溢出，返回至该语句所在的地址即可。 属于特殊情况，”/bin/sh”的位置比较明显。 123456789101112&gt; ##!/usr/bin/env python&gt; &gt; from pwn import *&gt; &gt; sh = process(’./ret2text’)&gt; &gt; target = 0x804863a&gt; &gt; sh.sendline(‘A’ * (0x6c+4) + p32(target))&gt; &gt; sh.interactive()&gt; 1.找出buf地址与main函数返回地址之间的距离。2.找出需要使用的字符串所在位置，直接返回过去执行。有点晕，为啥不用计算输入点距离返回地址的值，直接用的’a’*字符串距离+retaddr。实际上没有仔细看清楚，他的长度计算就是buf开始点到ebp的距离，retaddr对应的才是/bin/sh存放的位置。 前两题的区别在于，第一题是控制ret到一个想要执行的函数，第二题是控制ret到/bin/sh对应的地址。 第三道题，ret2shellcode：此次文件的segments是NX disabled，RWX，将shellcode写入bss段中。可以不用ROP绕过。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。获得执行system(“/bin/sh”)汇编代码所对应的机器码asm(shellcraft.sh()) 第四道题：ret2syscall：即控制函数执行系统调用，简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell。 而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。 具体实现：only ‘pop|ret’ | grep ‘eax’这类的命令找到gadgets，找到能符合条件改变eax，ebx，ecx，edx的语句，实现execve(“/bin/sh”,NULL,NULL)此系统调用所需要改变四种寄存器的值。再寻找字符串/bin/sh的地址以及命令int 0x80的地址。#不同的系统调用所需要改变的寄存器个数与参数是不一样的，所以寻找到的gadgets也是不一样的。、 123456python [pattern.py](http://pattern.py/) create 150gdb Xrun(input)qpython [pattern.py](http://pattern.py/) offset (address) RWX,bss段具有可执行权限，即NX开没开有什么意义，看不到区别。 若生成的shellcode长度若不够112个，则用垃圾字符填充（指令：sh.sendline(shellcode.ljust(112,’a’) + bss段shellcode的地址)） 代码真是博大精深。 但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因 意思就是没开NX的就可以直接把asm（shellcode）写到栈里直接执行，开了NX的要去data，text等其他代码段去找shellcode。 注意是返回地址不是/bin/sh本身在栈上 再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。（手动观察左上角窗口中的函数名，对main函数和system函数及一些容易造成溢出的函数加以注意）。 payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80]) pop eax是把栈顶的数字先赋给eax，再弹出/释放。上述式子，binsh是参数。 flat中的字符都是一次性发过去的，静态存储，在栈空间有足够长的的地址。 具体的链内部的控制，每次布置好返回地址的实现。可以是一长串字符，主调函数地址+pop ebx（堆栈平衡）+buf+被调函数地址，两次以上的函数调用一定要做到堆栈平衡。最后一个调用的函数一般都是system函数，不需要返回地址作为参数，只需要输入“/bin/sh”的地址作为参数。 ropgadget，注意命令格式：ROPgadget –binary [文件名] –only’寄存器名|寄存器名’ | grep ‘eax’。 payload = flat([‘a’ * 112, system_plt, ‘b’ * 4, binsh_addr])system_plt就看成system的地址。 ret2libc3 = ELF（’/ret3libc3’)表示把文件加载到内存中，这样可以方便引用。 from LibcSearcher import LibcSearcher 导入libc的基本信息。 puts_plt = ret2libc3.plt[‘puts’]libc_start_main_got = ret2libc3.got[’__libc_start_main’]main = ret2libc3.symbols[‘main’]此类语句是进行重命名方便引用。 print是执行时给出的反馈，表示执行到了某一步。 r.sendlineafter(‘AAA’,payload)表示程序输出AAA后，将payload进行输入。 r.sendlineuntil(‘AAA’,payload）表示直到返回了AAA字符串进行输入。r.sendline()，直接对括号内内容进行输入。r.interactive()，交互。 Linux下的安全防护机制： canary：不管是设计还是实现都比较简单高效，就是插入一个值，在栈溢出发生的高危区域的尾部，当函数返回时检测canary的值是否经过了改变，以此判断栈溢出是否发生 。checksec可以对文件进行检测。如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。PIE：Position Independent Executable，ALSR：地址随机化可以使用echo 0 &gt; /proc/sys/kernel/randomize_va_space关闭 Linux 系统的 ASLR，类似的，也可以配置相应的参数。0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。NX（Windows平台上称其为DEP）：NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 gcc -m32(生成32位编译程序) -fno-stack-protector(不开启栈溢出保护，即不生成canary。）-no-pie(关闭pie）sudo -secho 0 &gt; /proc/sys/kernel/randomize_va_space（$ cat /proc/sys/kernel/randomize_va_space指令检查）exit（关闭ALSR)-z execstack（关闭NX保护） Exp中sh = process（‘./文件名’），打本地，日自己。 p32（），将括号内的数转换为机器码。u32（），将括号内的机器码转化为字符或者数字。关于shellcode的位置问题：正常情况下都是使用gds调试程序，然后查看内存来确定shellcode的为之。但实际上执行exp的时候会发现shellcode不在这个位置上，因为gdb的调试环境会影响buf在内存中的位置。关闭ALSR只能保证buf的地址在gdb的调试环境中不变，但是直接执行elf时，buf的位置会固定在别的地址上。解决此问题最简单的方法就是开启core dump功能，即：ulimit -c unlimitedsudo sh -c ‘echo “/tmp/core.%t” &gt; /proc/sys/kernel/core_pattern’开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。 gdb调试常用命令：start，开始执行程序。n（next），单步执行。b（breakpoint）+行号/函数名，下断点。c（continue），继续执行。i（information） breakpoints，展示当前所有断点。delete+行号，删除断点。条件断点：b 9 if a == 2finsh，连续运行到当前函数为止，然后停下。list+行号，列出该行源代码。list+函数名，列出该函数源代码。list（l），一次列出 l行源代码。print（p），打印表达式的值。set var，修改变量的值。steps，执行下一行语句，如果有函数则进入到函数中去。braek（b）…if…，设置条件断点。display+变量名，查看跟踪某个变量，每次停下来都显示它的值，取消为undisplay。disable/enable，禁用/启用断点。run，从头开始执行程序。 GOT定位：对于模块外部引用的全局变量和全局函数，用 GOT 表的表项内容作为地址来间接寻址；对于本模块内的静态变量和静态函数，用 GOT 表的首地址作为一个基准，用相对于该基准的偏移量来引用，因为不论程序被加载到何种地址空间，模块内的静态变量和静态函数与 GOT 的距离是固定的，并且在链接阶段就可知晓其距离的大小。这样，PIC 使用 GOT 来引用变量和函数的绝对地址，把位置独立的引用重定向到绝对位置。PLT表：过程链接表用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问。 整理下防护的几种类型及设置方法canary 堆栈溢出保护 -fno-stack-protectorPIE+ALSR 地址随机化 -no-pie/echo 0 &gt; /proc/sys/kernel/randomize_va_spaceDEP（NX） 堆栈不可执行 无法设置，只能绕过。 gdb调试寻找字符串命令：find+起始地址+长度+“字符串”,如：find 0xb7e393f0, +2200000, “/bin/sh” read函数（），从打开的设备或者文件中读取数据。 #include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);count是请求读取的字节数，读取的数据保存在缓冲区buf中，同时文件的当前读写位置后移。返回值是成功读取的字节数。 write函数，三个参数分别为(int fd，const void *buf，size_t nbyte)分别为文件描述符，指定的缓冲区（指向一段内存单元的指针）和要写入文件的字节数。 函数调用指令: call ret 大致过程: 参数入栈 返回地址入栈 代码区块跳转 栈帧调整: 保存当前栈帧的状态值，为了后面恢复本栈帧时使用(EBP入栈) 将当前的栈帧切换到新栈帧(ESP值装入EBP，更新栈帧底部) 给新栈帧分配空间(ESP减去所需要空间的大小，抬高栈顶)]]></content>
  </entry>
  <entry>
    <title><![CDATA[栈帧（stack frame）]]></title>
    <url>%2F2019%2F06%2F19%2FStack%20Frame%2F</url>
    <content type="text"><![CDATA[1.栈帧的作用：在程序中用于声明变量，调用函数。是利用EBP（栈帧指针）寄存器访问栈内局部变量，参数，函数返回地址等的手段。 2.在储存局部变量的值之前，都会执行SUB指令，为局部变量开辟空间。 3.汇编中的DWORD PTR SS:[EBP-4]理解为指针，意为地址EBP-4处有一个4字节大小 的内存空间。此句中，SS是Segment Memory Model的缩写，表示栈段，在Windows（使用段内存模型）下需要指出。EBP是指向栈的寄存器，所以加上SS寄存器。DWORD PTR与SS等字符串可以在OD设置中隐藏。 4.调用一个函数之前，先开辟出内存空间，在将参数压入栈，最后在执行函数之前，将返回地址压入栈。执行完毕之后将删除函数栈帧并返回至PUSH的返回地址。 5.注意参数入栈的顺序与C语言中参数顺序恰好相反（参数的逆向存储）。 6.调用约定（Calling Convention）：被调函数执行完后，由函数的调用者负责清理存储在栈中的参数，这种方式称为cdecl方式。由被调用者负责清理保存在栈中的参数，称为stdcall方式。 7.ESP为栈顶指针，EBP为栈帧指针。程序运行过程中，ESP是随时变化的，访问内存中的局部变量和参数等如果以此为基址会十分困难。所以程序开始时会PUSH EBP,MOV EBP,ESP.将ESP的值保存在EBP中并且维持在函数内部，这样无论ESP如何变化，以EBP为基准都能准确地访问到局部变量与参数。执行完这两条命令，就可以说栈帧已经生成了。 8.XOR命令用来进行异或运算，Exclusive OR bit，其特点为两个相同的值进行异或运算的结果为0.XOR命令的执行速度比 MOV EAX,0 要快，常用于寄存器初始化操作。 9.编译器中的”优化“（optimization）选项开启后，编译出来的简单函数将不会生成栈帧。 10.牢记：栈是用来存放参数，变量，地址等数据的，不是用来存放代码的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Genesis]]></title>
    <url>%2F2019%2F06%2F17%2FGenesis%2F</url>
    <content type="text"><![CDATA[Earthquake and Blog]]></content>
  </entry>
</search>
